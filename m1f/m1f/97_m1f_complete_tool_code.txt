======= __init__.py | CHECKSUM_SHA256: 02be5f461b2695ebd550b5e24aeabfe87cc7d7163b139d0718b6cb769f67775f ======
"""
Package containing the m1f suite of tools for file operations.

This package provides utilities for combining source files (m1f.py),
splitting them back (s1f.py), and other related functionality.
"""

from ._version import __version__, __version_info__

__all__ = ["__version__", "__version_info__"]

======= _version.py | CHECKSUM_SHA256: b012dabf4e15b3e5e4ba95201d0abf798058d0280dec4d1305e14a1ae0d13d4e ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Single source of truth for m1f version information.

This file is the only place where the version number should be updated.
All other files should import from here.
"""

__version__ = "3.2.0"
__version_info__ = tuple(int(x) for x in __version__.split(".")[:3])

======= claude_orchestrator.py | CHECKSUM_SHA256: e01c9869161a3416d31fbcf9a7e7daee53d04000a354e4e272ec8da7a2170be1 ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Claude Code Orchestrator for m1f Tools

This module provides intelligent automation of m1f tools using Claude Code.
It analyzes natural language requests and executes the appropriate tools
with optimal parameters.
"""

import subprocess
import json
import sys
from pathlib import Path
from typing import Dict, List, Any, Optional
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")
logger = logging.getLogger(__name__)


class ClaudeOrchestrator:
    """Orchestrate m1f tools using Claude Code as an AI assistant."""

    def __init__(self):
        """Initialize the orchestrator with available tools."""
        self.project_root = Path(__file__).parent.parent
        self.tools = {
            "m1f": {
                "path": "tools/m1f.py",
                "description": "Bundle multiple files into a single file",
            },
            "s1f": {
                "path": "tools/s1f.py",
                "description": "Split bundled files back to original structure",
            },
            "mf1-html2md": {
                "path": "tools/mf1-html2md",
                "description": "Convert HTML to Markdown with preprocessing",
            },
            "analyze_html": {
                "path": "tools/mf1-html2md/analyze_html.py",
                "description": "Analyze HTML files for preprocessing config",
            },
            "wp_export": {
                "path": "tools/wp_export_md.py",
                "description": "Export WordPress content to Markdown",
            },
        }

        # Check if Claude Code is available
        self.claude_available = self._check_claude_available()

    def _check_claude_available(self) -> bool:
        """Check if Claude Code is installed and accessible."""
        try:
            result = subprocess.run(
                ["claude", "--version"], capture_output=True, text=True, timeout=5
            )
            return result.returncode == 0
        except (subprocess.SubprocessError, FileNotFoundError):
            return False

    def _execute_claude_command(
        self, prompt: str, output_format: str = "json"
    ) -> Dict[str, Any]:
        """Execute a Claude Code command and return the result."""
        if not self.claude_available:
            logger.error(
                "Claude Code is not installed. Please run: npm install -g @anthropic-ai/claude-code"
            )
            return {"error": "Claude Code not available"}

        try:
            cmd = ["claude", "-p", prompt]
            if output_format == "json":
                cmd.extend(["--output-format", "json"])

            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)

            if result.returncode != 0:
                logger.error(f"Claude Code error: {result.stderr}")
                return {"error": result.stderr}

            if output_format == "json":
                return json.loads(result.stdout)
            else:
                return {"response": result.stdout}

        except subprocess.TimeoutExpired:
            logger.error("Claude Code command timed out")
            return {"error": "Command timed out"}
        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse Claude response: {e}")
            return {"error": "Invalid JSON response", "raw": result.stdout}
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            return {"error": str(e)}

    def analyze_request(self, user_prompt: str) -> Dict[str, Any]:
        """Use Claude to analyze user request and create an execution plan."""
        analysis_prompt = f"""
You are helping with the m1f tools project. Analyze this request and return a JSON object with:

1. "tool": which primary tool to use ({', '.join(self.tools.keys())}) or "multiple" for workflows
2. "parameters": object with parameters for the tool
3. "steps": array of step objects, each with:
   - "tool": tool name
   - "command": exact command to run
   - "description": what this step does
   - "check_output": boolean if output should be verified
4. "summary": brief summary of what will be done

Available tools:
{json.dumps(self.tools, indent=2)}

User request: {user_prompt}

Important rules:
- Use absolute paths or paths relative to project root
- For m1f, use appropriate separator styles (Standard, Detailed, Markdown, etc.)
- For mf1-html2md, consider if preprocessing is needed
- Include proper flags and options

Return only valid JSON, no other text.
"""

        return self._execute_claude_command(analysis_prompt, "json")

    def execute_plan(self, plan: Dict[str, Any], dry_run: bool = False) -> bool:
        """Execute the plan created by Claude."""
        if "error" in plan:
            logger.error(f"Cannot execute plan: {plan['error']}")
            return False

        if "summary" in plan:
            logger.info(f"Plan: {plan['summary']}")

        steps = plan.get("steps", [])
        if not steps:
            logger.warning("No steps to execute")
            return False

        for i, step in enumerate(steps, 1):
            logger.info(
                f"Step {i}/{len(steps)}: {step.get('description', 'Executing command')}"
            )

            command = step.get("command", "")
            if not command:
                logger.warning(f"Step {i} has no command")
                continue

            # Ensure we're using Python from the virtual environment
            if command.startswith("python "):
                command = command.replace("python ", "python ", 1)

            logger.info(f"Command: {command}")

            if dry_run:
                logger.info("(Dry run - not executing)")
                continue

            try:
                # Change to project root for consistent execution
                result = subprocess.run(
                    command,
                    shell=True,
                    capture_output=True,
                    text=True,
                    cwd=self.project_root,
                )

                if result.returncode != 0:
                    logger.error(f"Command failed: {result.stderr}")
                    if step.get("continue_on_error", False):
                        logger.warning("Continuing despite error...")
                    else:
                        return False
                else:
                    if result.stdout:
                        logger.debug(f"Output: {result.stdout[:200]}...")

            except Exception as e:
                logger.error(f"Failed to execute command: {e}")
                return False

        logger.info("All steps completed successfully")
        return True

    def interactive_mode(self):
        """Run in interactive mode, accepting user prompts."""
        print("Claude Orchestrator - Interactive Mode")
        print("Type 'help' for available commands, 'quit' to exit")
        print("-" * 50)

        while True:
            try:
                prompt = input("\n> ").strip()

                if not prompt:
                    continue

                if prompt.lower() in ["quit", "exit", "q"]:
                    break

                if prompt.lower() == "help":
                    self._show_help()
                    continue

                if prompt.lower() == "tools":
                    self._show_tools()
                    continue

                # Analyze the request
                logger.info("Analyzing request...")
                plan = self.analyze_request(prompt)

                if "error" in plan:
                    logger.error(f"Analysis failed: {plan['error']}")
                    continue

                # Show the plan
                print("\nExecution Plan:")
                print(json.dumps(plan, indent=2))

                # Ask for confirmation
                confirm = input("\nExecute this plan? (y/n/dry): ").lower()

                if confirm == "y":
                    self.execute_plan(plan)
                elif confirm == "dry":
                    self.execute_plan(plan, dry_run=True)
                else:
                    print("Plan cancelled")

            except KeyboardInterrupt:
                print("\nUse 'quit' to exit")
            except Exception as e:
                logger.error(f"Error: {e}")

    def _show_help(self):
        """Show help information."""
        print(
            """
Available commands:
  help      - Show this help
  tools     - List available tools
  quit      - Exit the program
  
Example requests:
  - Bundle all Python files in the tools directory
  - Convert HTML documentation to Markdown
  - Analyze HTML files and create preprocessing config
  - Create m1f bundles from markdown files by topic
  - Export WordPress site to markdown
        """
        )

    def _show_tools(self):
        """Show available tools."""
        print("\nAvailable tools:")
        for name, info in self.tools.items():
            print(f"  {name:<15} - {info['description']}")


def main():
    """Main entry point."""
    import argparse

    parser = argparse.ArgumentParser(
        description="Orchestrate m1f tools using Claude Code"
    )
    parser.add_argument(
        "prompt", nargs="?", help="Natural language prompt for what to do"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be done without executing",
    )
    parser.add_argument(
        "--interactive", "-i", action="store_true", help="Run in interactive mode"
    )

    args = parser.parse_args()

    orchestrator = ClaudeOrchestrator()

    if not orchestrator.claude_available:
        print("Claude Code is not installed.")
        print("Please run: npm install -g @anthropic-ai/claude-code")
        print("\nYou can still use the m1f tools directly:")
        orchestrator._show_tools()
        sys.exit(1)

    if args.interactive or not args.prompt:
        orchestrator.interactive_mode()
    else:
        # Single command mode
        logger.info("Analyzing request...")
        plan = orchestrator.analyze_request(args.prompt)

        if "error" in plan:
            logger.error(f"Failed to analyze request: {plan['error']}")
            sys.exit(1)

        print("\nExecution Plan:")
        print(json.dumps(plan, indent=2))

        if not args.dry_run:
            if orchestrator.execute_plan(plan):
                logger.info("Success!")
            else:
                logger.error("Execution failed")
                sys.exit(1)


if __name__ == "__main__":
    main()

======= html2md.py | CHECKSUM_SHA256: accf1d394c28c79e81ee44aa57c9d01e2544abb7f95275f287cb01db5e8468fc ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
HTML to Markdown converter - wrapper script.
"""

if __name__ == "__main__":
    from html2md_tool.cli import main

    main()

======= m1f.py | CHECKSUM_SHA256: ed4118edf5a5f76bd5fa88ae9515552c38312b1d757c19d745aec2544566a5de ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
m1f - Make One File (Refactored Version)
========================================

A modern Python tool to combine multiple text files into a single output file.

This is a refactored version using modern Python best practices:
- Type hints throughout (Python 3.10+ style)
- Dataclasses for configuration
- Better separation of concerns
- Dependency injection
- No global state
- Async I/O for better performance
- Structured logging
"""

import asyncio
import sys
from pathlib import Path
from typing import NoReturn

# Try absolute imports first (for module execution), fall back to relative
try:
    from tools.m1f.cli import create_parser, parse_args
    from tools.m1f.config import Config
    from tools.m1f.core import FileCombiner
    from tools.m1f.exceptions import M1FError
    from tools.m1f.logging import setup_logging, get_logger
    from tools.m1f.auto_bundle import AutoBundler
except ImportError:
    # Fallback for direct script execution
    from m1f.cli import create_parser, parse_args
    from m1f.config import Config
    from m1f.core import FileCombiner
    from m1f.exceptions import M1FError
    from m1f.logging import setup_logging, get_logger
    from m1f.auto_bundle import AutoBundler


try:
    from _version import __version__, __version_info__
except ImportError:
    # Fallback for when running as a script
    __version__ = "3.2.0"
    __version_info__ = (3, 2, 0)

__author__ = "Franz und Franz (https://franz.agency)"
__project__ = "https://m1f.dev"


async def async_main() -> int:
    """Async main function for the application."""
    try:
        # Check if we're running auto-bundle command
        if len(sys.argv) > 1 and sys.argv[1] == "auto-bundle":
            # Handle auto-bundle subcommand
            import argparse

            parser = argparse.ArgumentParser(
                prog="m1f auto-bundle", description="Auto-bundle functionality for m1f"
            )
            parser.add_argument(
                "bundle_name", nargs="?", help="Name of specific bundle to create"
            )
            parser.add_argument(
                "--list", action="store_true", help="List available bundles"
            )
            parser.add_argument(
                "--group", "-g", 
                type=str, 
                help="Only create bundles from specified group"
            )
            parser.add_argument(
                "-v", "--verbose", action="store_true", help="Enable verbose output"
            )
            parser.add_argument(
                "-q", "--quiet", action="store_true", help="Suppress all console output"
            )

            # Parse auto-bundle args
            args = parser.parse_args(sys.argv[2:])

            # Create and run auto-bundler
            bundler = AutoBundler(Path.cwd(), verbose=args.verbose, quiet=args.quiet)
            success = bundler.run(
                bundle_name=args.bundle_name, 
                list_bundles=args.list,
                bundle_group=args.group
            )
            return 0 if success else 1

        # Regular m1f execution
        # Parse command line arguments
        parser = create_parser()
        args = parse_args(parser)

        # Create configuration from arguments
        config = Config.from_args(args)

        # Setup logging
        logger_manager = setup_logging(config)
        logger = get_logger(__name__)

        try:
            # Create and run the file combiner
            combiner = FileCombiner(config, logger_manager)
            result = await combiner.run()

            # Log execution summary
            logger.info(f"Total execution time: {result.execution_time}")
            logger.info(f"Processed {result.files_processed} files")

            return 0

        finally:
            # Ensure proper cleanup
            await logger_manager.cleanup()

    except KeyboardInterrupt:
        print("\nOperation cancelled by user.", file=sys.stderr)
        return 130  # Standard exit code for Ctrl+C

    except M1FError as e:
        # Our custom exceptions
        logger = get_logger(__name__)
        logger.error(f"{e.__class__.__name__}: {e}")
        return e.exit_code

    except Exception as e:
        # Unexpected errors
        logger = get_logger(__name__)
        logger.critical(f"Unexpected error: {e}", exc_info=True)
        return 1


def main() -> NoReturn:
    """Entry point for the application."""
    exit_code = asyncio.run(async_main())
    sys.exit(exit_code)


if __name__ == "__main__":
    main()

======= m1f_claude.py | CHECKSUM_SHA256: 2747f30b0d1d612f9fe51c19e7a9924400345f5fa7c51d9ee4ade4686d8c983e ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
m1f-claude: Intelligent prompt enhancement for using Claude with m1f

This tool enhances your prompts to Claude by automatically providing context
about m1f capabilities and your project structure, making Claude much more
effective at helping you bundle and organize your code.
"""

import sys
import os
import json
import subprocess
from pathlib import Path
from typing import Dict, Optional, List
import argparse
import logging
from datetime import datetime

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(message)s"  # Simple format for user-facing messages
)
logger = logging.getLogger(__name__)


class M1FClaude:
    """Enhance Claude prompts with m1f knowledge and context."""

    def __init__(self, project_path: Path = None):
        """Initialize m1f-claude with project context."""
        self.project_path = project_path or Path.cwd()
        self.m1f_root = Path(__file__).parent.parent

        # Check for m1f documentation in various locations
        self.m1f_docs_link = self.project_path / ".m1f" / "m1f-docs.txt"
        self.m1f_docs_direct = self.project_path / ".m1f" / "m1f-doc" / "99_m1fdocs.txt"

        # Check if m1f-link has been run or docs exist directly
        self.has_m1f_docs = self.m1f_docs_link.exists() or self.m1f_docs_direct.exists()

        # Use whichever path exists
        if self.m1f_docs_link.exists():
            self.m1f_docs_path = self.m1f_docs_link
        elif self.m1f_docs_direct.exists():
            self.m1f_docs_path = self.m1f_docs_direct
        else:
            self.m1f_docs_path = self.m1f_docs_link  # Default to expected symlink path

    def create_enhanced_prompt(
        self, user_prompt: str, context: Optional[Dict] = None
    ) -> str:
        """Enhance user prompt with m1f context and best practices."""

        # Start with a strong foundation
        enhanced = []

        # Add m1f context
        enhanced.append("🚀 m1f Context Enhancement Active\n")
        enhanced.append("=" * 50)

        # Core m1f knowledge injection
        if self.has_m1f_docs:
            enhanced.append(
                f"""
m1f (Make One File) is installed and ready to use in this project.

📚 Complete m1f documentation is available at: @{self.m1f_docs_path.relative_to(self.project_path)}

This documentation includes:
- All m1f commands and parameters
- Preset system for file-specific processing
- Auto-bundle configuration with YAML
- Security scanning and encoding handling
- Integration with html2md, webscraper, and other tools
"""
            )
        else:
            enhanced.append(
                """
⚠️  m1f documentation not linked yet. Run 'm1f-link' first to give me full context!

Without the docs, I'll use my general knowledge of m1f, but I'll be much more helpful
if you run 'm1f-link' and then reference @.m1f/m1f-docs.txt
"""
            )

        # Add project context
        enhanced.append(self._analyze_project_context())

        # Add user's original prompt
        enhanced.append("\n" + "=" * 50)
        enhanced.append("\n🎯 User Request:\n")
        enhanced.append(user_prompt)

        # Add helpful hints based on common patterns
        enhanced.append("\n\n💡 m1f Quick Reference:")
        enhanced.append(self._get_contextual_hints(user_prompt))

        return "\n".join(enhanced)

    def _analyze_project_context(self) -> str:
        """Analyze the current project structure for better context."""
        context_parts = ["\n📁 Project Context:"]

        # Check for common project files
        config_files = {
            ".m1f.config.yml": "✅ Auto-bundle config found",
            "package.json": "📦 Node.js project detected",
            "requirements.txt": "🐍 Python project detected",
            "composer.json": "🎼 PHP project detected",
            "Gemfile": "💎 Ruby project detected",
            "Cargo.toml": "🦀 Rust project detected",
            "go.mod": "🐹 Go project detected",
            ".git": "📚 Git repository",
        }

        detected = []
        for file, desc in config_files.items():
            if (self.project_path / file).exists():
                detected.append(f"  {desc}")

        if detected:
            context_parts.extend(detected)
        else:
            context_parts.append("  📂 Standard project structure")

        # Check for m1f bundles
        m1f_dir = self.project_path / ".m1f"
        if m1f_dir.exists() and m1f_dir.is_dir():
            bundles = list(m1f_dir.glob("*.txt"))
            if bundles:
                context_parts.append(f"\n📦 Existing m1f bundles: {len(bundles)} found")
                for bundle in bundles[:3]:  # Show first 3
                    context_parts.append(f"  • {bundle.name}")
                if len(bundles) > 3:
                    context_parts.append(f"  • ... and {len(bundles) - 3} more")

        return "\n".join(context_parts)

    def _get_contextual_hints(self, user_prompt: str) -> str:
        """Provide contextual hints based on the user's prompt."""
        hints = []
        prompt_lower = user_prompt.lower()

        # Detect intent and provide relevant hints
        if any(word in prompt_lower for word in ["bundle", "combine", "merge"]):
            hints.append(
                """
- Basic bundling: m1f -s . -o output.txt
- With presets: m1f --preset wordpress -o bundle.txt
- Auto-bundle: m1f-update (if .m1f.config.yml exists)
"""
            )

        if any(word in prompt_lower for word in ["config", "configure", "setup"]):
            hints.append(
                """
- Create .m1f.config.yml for auto-bundling
- Use presets for file-specific processing
- Set up exclude/include patterns
"""
            )

        if any(word in prompt_lower for word in ["wordpress", "wp", "theme", "plugin"]):
            hints.append(
                """
- WordPress preset available: --preset presets/wordpress.m1f-presets.yml
- Excludes vendor/node_modules automatically
- Handles PHP/CSS/JS with appropriate processing
"""
            )

        if any(word in prompt_lower for word in ["ai", "context", "assistant"]):
            hints.append(
                """
- Keep bundles under 100KB for AI context windows
- Use Markdown separator style for AI readability
- Create topic-specific bundles, not everything at once
"""
            )

        if any(word in prompt_lower for word in ["test", "tests", "testing"]):
            hints.append(
                """
- Exclude tests: --excludes "**/test_*" "**/*_test.*"
- Or create test-only bundle for QA team
- Use include_extensions to filter by file type
"""
            )

        return (
            "\n".join(hints)
            if hints
            else "\nAsk me anything about bundling, organizing, or processing your files!"
        )

    def send_to_claude_code(self, enhanced_prompt: str) -> Optional[str]:
        """Send the enhanced prompt to Claude Code if available."""
        try:
            # Check if claude command exists
            result = subprocess.run(
                ["claude", "--version"], capture_output=True, text=True, timeout=5
            )

            if result.returncode != 0:
                logger.info(
                    "\n📝 Claude Code not found. Here's your enhanced prompt to copy:\n"
                )
                return None

            # Send to Claude Code
            logger.info("\n🤖 Sending to Claude Code...\n")

            # Create a temporary file with the prompt to handle complex prompts
            import tempfile

            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".txt", delete=False
            ) as f:
                f.write(enhanced_prompt)
                temp_path = f.name

            try:
                result = subprocess.run(
                    ["claude", "-f", temp_path],
                    capture_output=True,
                    text=True,
                    timeout=30,
                )

                if result.returncode == 0:
                    return result.stdout
                else:
                    logger.error(f"Claude Code error: {result.stderr}")
                    return None
            finally:
                os.unlink(temp_path)

        except FileNotFoundError:
            logger.info(
                "\n📝 Claude Code not installed. Install with: npm install -g @anthropic-ai/claude-code"
            )
            return None
        except subprocess.TimeoutExpired:
            logger.error("Claude Code timed out")
            return None
        except Exception as e:
            logger.error(f"Error communicating with Claude Code: {e}")
            return None

    def interactive_mode(self):
        """Run in interactive mode for continued conversation."""
        print("\n🤖 m1f-claude Interactive Mode")
        print("=" * 50)
        print("I'll enhance your prompts with m1f knowledge!")
        print("Commands: 'help', 'context', 'examples', 'quit'\n")

        if not self.has_m1f_docs:
            print("💡 Tip: Run 'm1f-link' first for better assistance!\n")

        while True:
            try:
                user_input = input("You: ").strip()

                if not user_input:
                    continue

                if user_input.lower() in ["quit", "exit", "q"]:
                    print("\n👋 Happy bundling!")
                    break

                if user_input.lower() == "help":
                    self._show_help()
                    continue

                if user_input.lower() == "context":
                    print(self._analyze_project_context())
                    continue

                if user_input.lower() == "examples":
                    self._show_examples()
                    continue

                # Enhance and process the prompt
                enhanced = self.create_enhanced_prompt(user_input)

                # Try to send to Claude Code
                response = self.send_to_claude_code(enhanced)

                if response:
                    print(f"\nClaude: {response}\n")
                else:
                    print("\n--- Enhanced Prompt ---")
                    print(enhanced)
                    print("\n--- Copy the above and paste into Claude! ---\n")

            except KeyboardInterrupt:
                print("\n\nUse 'quit' to exit properly")
            except Exception as e:
                logger.error(f"Error: {e}")

    def _show_help(self):
        """Show help information."""
        print(
            """
🎯 m1f-claude Help

Commands:
  help     - Show this help
  context  - Show current project context
  examples - Show example prompts
  quit     - Exit interactive mode

Tips:
  • Run 'm1f-link' first for best results
  • Be specific about your project type
  • Mention constraints (file size, AI context windows)
  • Ask for complete .m1f.config.yml examples
"""
        )

    def _show_examples(self):
        """Show example prompts that work well."""
        print(
            """
📚 Example Prompts That Work Great:

1. "Help me set up m1f for my Django project with separate bundles for models, views, and templates"

2. "Create a .m1f.config.yml that bundles my React app for code review, excluding tests and node_modules"

3. "I need to prepare documentation for a new developer. Create bundles that explain the codebase structure"

4. "Optimize my WordPress theme for AI assistance - create focused bundles under 100KB each"

5. "My project has Python backend and Vue frontend. Set up bundles for each team"

6. "Create a bundle of just the files that changed in the last week"

7. "Help me use m1f with GitHub Actions to auto-generate documentation bundles"
"""
        )


def main():
    """Main entry point for m1f-claude."""
    parser = argparse.ArgumentParser(
        description="Enhance your Claude prompts with m1f knowledge",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  m1f-claude "Help me bundle my Python project"
  m1f-claude -i                    # Interactive mode
  m1f-claude --check              # Check setup status
  
First time? Run 'm1f-link' to give Claude full m1f documentation!
""",
    )

    parser.add_argument(
        "prompt", nargs="*", help="Your prompt to enhance with m1f context"
    )

    parser.add_argument(
        "-i", "--interactive", action="store_true", help="Run in interactive mode"
    )

    parser.add_argument(
        "--check", action="store_true", help="Check m1f-claude setup status"
    )

    parser.add_argument(
        "--no-send",
        action="store_true",
        help="Don't send to Claude Code, just show enhanced prompt",
    )

    args = parser.parse_args()

    # Initialize m1f-claude
    m1f_claude = M1FClaude()

    # Check status
    if args.check:
        print("\n🔍 m1f-claude Status Check")
        print("=" * 50)
        print(f"✅ m1f-claude installed and ready")
        print(f"📁 Working directory: {m1f_claude.project_path}")

        if m1f_claude.has_m1f_docs:
            print(
                f"✅ m1f docs found at: {m1f_claude.m1f_docs_path.relative_to(m1f_claude.project_path)}"
            )
        else:
            print(f"⚠️  m1f docs not found - run 'm1f-link' first!")

        # Check for Claude Code
        try:
            result = subprocess.run(
                ["claude", "--version"], capture_output=True, text=True
            )
            if result.returncode == 0:
                print(f"✅ Claude Code is installed")
            else:
                print(
                    f"⚠️  Claude Code not found - install with: npm install -g @anthropic-ai/claude-code"
                )
        except:
            print(
                f"⚠️  Claude Code not found - install with: npm install -g @anthropic-ai/claude-code"
            )

        return

    # Interactive mode
    if args.interactive or not args.prompt:
        m1f_claude.interactive_mode()
        return

    # Single prompt mode
    prompt = " ".join(args.prompt)
    enhanced = m1f_claude.create_enhanced_prompt(prompt)

    if args.no_send:
        print("\n--- Enhanced Prompt ---")
        print(enhanced)
    else:
        response = m1f_claude.send_to_claude_code(enhanced)
        if response:
            print(response)
        else:
            print("\n--- Enhanced Prompt (copy this to Claude) ---")
            print(enhanced)


if __name__ == "__main__":
    main()

======= path_utils.py | CHECKSUM_SHA256: c054c621de1a9579eaf06829334e7b58fa072cdfd023bc7306ef902c2a281b0a ======
# Copyright 2025 Franz und Franz GmbH
# SPDX-License-Identifier: Apache-2.0

from pathlib import Path, PureWindowsPath
from typing import Union


def convert_to_posix_path(path_val: str) -> str:
    """Convert a path string to POSIX style."""
    return PureWindowsPath(path_val).as_posix()


def normalize_path(path: Union[Path, str]) -> str:
    """Normalize a Path or path-like object to POSIX style."""
    return PureWindowsPath(str(path)).as_posix()

======= prepare_docs.py | CHECKSUM_SHA256: 171bb130b2843a628ef57e15ecd893c12f8fc1e3e3692d5616306b4155cbb3f5 ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
prepare_docs.py - Documentation Preparation Tool

This script automates the process of converting HTML documentation to Markdown
and maintaining the documentation structure. It works in conjunction with the
mf1-html2md.py tool to provide a streamlined documentation workflow.

Usage:
    python tools/prepare_docs.py --convert-html  # Convert HTML docs to Markdown
    python tools/prepare_docs.py --build-bundle  # Create a bundled documentation file
    python tools/prepare_docs.py --all  # Perform all documentation preparation steps
"""

import argparse
import logging
import os
import subprocess
import sys
import time
from pathlib import Path

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format="%(levelname)-8s: %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)],
)
logger = logging.getLogger("prepare_docs")

# Configuration
BASE_DIR = Path(__file__).parent.parent
HTML_DOCS_DIR = BASE_DIR / "tests" / "mf1-html2md" / "source" / "html"
MD_DOCS_DIR = BASE_DIR / "tests" / "mf1-html2md" / "output" / "markdown"
BUNDLE_OUTPUT = (
    BASE_DIR / "tests" / "mf1-html2md" / "output" / "documentation-bundle.md"
)


def ensure_dir(directory: Path) -> None:
    """Ensure a directory exists, creating it if necessary."""
    if not directory.exists():
        directory.mkdir(parents=True)
        logger.info(f"Created directory: {directory}")


def convert_html_to_markdown() -> bool:
    """Convert HTML documentation to Markdown using mf1-html2md.py.

    Returns:
        bool: True if conversion was successful, False otherwise
    """
    logger.info("Starting HTML to Markdown conversion...")
    ensure_dir(HTML_DOCS_DIR)
    ensure_dir(MD_DOCS_DIR)

    # Check if there are any HTML files to convert
    html_files = list(HTML_DOCS_DIR.glob("**/*.html")) + list(
        HTML_DOCS_DIR.glob("**/*.htm")
    )

    if not html_files:
        logger.warning(f"No HTML files found in {HTML_DOCS_DIR}")
        logger.info(
            f"You can add HTML files to the {HTML_DOCS_DIR} directory for conversion"
        )
        return False

    # Build command for mf1-html2md.py
    html2md_script = BASE_DIR / "tools" / "mf1-html2md.py"

    if not html2md_script.exists():
        logger.error(f"HTML to Markdown conversion script not found: {html2md_script}")
        return False

    try:
        # Run the HTML to Markdown conversion with optimal settings
        cmd = [
            sys.executable,
            str(html2md_script),
            "--source-dir",
            str(HTML_DOCS_DIR),
            "--destination-dir",
            str(MD_DOCS_DIR),
            "--add-frontmatter",
            "--convert-code-blocks",
            "--force",  # Overwrite existing files
            "--remove-elements",
            "script",
            "style",
            "iframe",
            "noscript",
            "nav",
            "footer",
            ".advertisement",
        ]

        logger.info(f"Running command: {' '.join(cmd)}")
        result = subprocess.run(cmd, check=True, capture_output=True, text=True)

        logger.info(f"HTML to Markdown conversion completed successfully")
        logger.info(f"Converted files are available in: {MD_DOCS_DIR}")

        # Print any output from the command
        if result.stdout:
            for line in result.stdout.splitlines():
                logger.info(f"mf1-html2md: {line}")

        return True

    except subprocess.CalledProcessError as e:
        logger.error(
            f"HTML to Markdown conversion failed with exit code {e.returncode}"
        )
        if e.stdout:
            logger.info("Output:")
            for line in e.stdout.splitlines():
                logger.info(f"  {line}")
        if e.stderr:
            logger.error("Errors:")
            for line in e.stderr.splitlines():
                logger.error(f"  {line}")
        return False

    except Exception as e:
        logger.error(f"Error during HTML to Markdown conversion: {e}")
        return False


def build_documentation_bundle() -> bool:
    """Create a bundled documentation file using m1f.py.

    Returns:
        bool: True if bundling was successful, False otherwise
    """
    logger.info("Creating documentation bundle...")

    # Check if Markdown directory exists and has files
    if not MD_DOCS_DIR.exists():
        logger.warning(f"Markdown directory not found: {MD_DOCS_DIR}")
        logger.info("Run with --convert-html first to create Markdown files")
        return False

    md_files = list(MD_DOCS_DIR.glob("**/*.md"))
    if not md_files:
        logger.warning(f"No Markdown files found in {MD_DOCS_DIR}")
        return False

    # Build command for m1f.py
    m1f_script = BASE_DIR / "tools" / "m1f.py"

    if not m1f_script.exists():
        logger.error(f"m1f script not found: {m1f_script}")
        return False

    try:
        # Create docs directory if it doesn't exist
        ensure_dir(BUNDLE_OUTPUT.parent)

        # Run m1f to bundle the documentation
        cmd = [
            sys.executable,
            str(m1f_script),
            "--source-directory",
            str(MD_DOCS_DIR),
            "--output-file",
            str(BUNDLE_OUTPUT),
            "--separator-style",
            "Markdown",
            "--force",  # Overwrite existing bundle
            "--include-extensions",
            ".md",
        ]

        logger.info(f"Running command: {' '.join(cmd)}")
        result = subprocess.run(cmd, check=True, capture_output=True, text=True)

        logger.info(f"Documentation bundle created successfully: {BUNDLE_OUTPUT}")

        # Print any output from the command
        if result.stdout:
            for line in result.stdout.splitlines():
                logger.info(f"m1f: {line}")

        return True

    except subprocess.CalledProcessError as e:
        logger.error(f"Documentation bundling failed with exit code {e.returncode}")
        if e.stdout:
            logger.info("Output:")
            for line in e.stdout.splitlines():
                logger.info(f"  {line}")
        if e.stderr:
            logger.error("Errors:")
            for line in e.stderr.splitlines():
                logger.error(f"  {line}")
        return False

    except Exception as e:
        logger.error(f"Error during documentation bundling: {e}")
        return False


def main() -> None:
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description="Documentation preparation tool",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    parser.add_argument(
        "--convert-html", action="store_true", help="Convert HTML docs to Markdown"
    )

    parser.add_argument(
        "--build-bundle",
        action="store_true",
        help="Create a bundled documentation file",
    )

    parser.add_argument(
        "--all", action="store_true", help="Perform all documentation preparation steps"
    )

    parser.add_argument(
        "--verbose", "-v", action="store_true", help="Enable verbose output"
    )

    # Add the ability to override source and destination directories
    parser.add_argument(
        "--html-dir", help=f"Source HTML directory (default: {HTML_DOCS_DIR})"
    )

    parser.add_argument(
        "--markdown-dir",
        help=f"Destination Markdown directory (default: {MD_DOCS_DIR})",
    )

    parser.add_argument(
        "--output-bundle", help=f"Output bundle file path (default: {BUNDLE_OUTPUT})"
    )

    args = parser.parse_args()

    # Override directories if specified
    global HTML_DOCS_DIR, MD_DOCS_DIR, BUNDLE_OUTPUT
    if args.html_dir:
        HTML_DOCS_DIR = Path(args.html_dir)
    if args.markdown_dir:
        MD_DOCS_DIR = Path(args.markdown_dir)
    if args.output_bundle:
        BUNDLE_OUTPUT = Path(args.output_bundle)

    # If no arguments provided, show help
    if not (args.convert_html or args.build_bundle or args.all):
        parser.print_help()
        sys.exit(0)

    # Set logging level based on verbosity
    if args.verbose:
        logger.setLevel(logging.DEBUG)
        logger.debug("Verbose mode enabled")
        logger.debug(f"HTML source directory: {HTML_DOCS_DIR}")
        logger.debug(f"Markdown output directory: {MD_DOCS_DIR}")
        logger.debug(f"Bundle output file: {BUNDLE_OUTPUT}")

    # Track execution time
    start_time = time.time()

    success = True

    # Perform requested operations
    if args.convert_html or args.all:
        if not convert_html_to_markdown():
            success = False

    if (args.build_bundle or args.all) and success:
        if not build_documentation_bundle():
            success = False

    # Calculate execution time
    execution_time = time.time() - start_time
    if execution_time >= 60:
        minutes, seconds = divmod(execution_time, 60)
        time_str = f"{int(minutes)}m {seconds:.2f}s"
    else:
        time_str = f"{execution_time:.2f}s"

    if success:
        logger.info(f"Documentation preparation completed successfully in {time_str}")
    else:
        logger.warning(f"Documentation preparation completed with errors in {time_str}")
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        sys.exit(130)  # Standard exit code for Ctrl+C
    except Exception as e:
        logger.critical(f"An unexpected error occurred: {e}", exc_info=True)
        sys.exit(1)

======= s1f.py | CHECKSUM_SHA256: 886ec889cb8cb9f7ec32c40738b0da2ae0aa73bb35a3bde395555ec2f9b365a9 ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
# SPDX-License-Identifier: Apache-2.0

"""Main entry point for s1f - Split One File."""

import sys

# Try absolute imports first (for module execution), fall back to relative
try:
    from tools.s1f.cli import main
except ImportError:
    # Fallback for direct script execution
    from s1f.cli import main

if __name__ == "__main__":
    sys.exit(main())

======= scrape.py | CHECKSUM_SHA256: f292122f0eacc9122824d8e0f2856c3f505eb318817a69524b98eac4b852ea49 ======
#!/usr/bin/env python3
"""Wrapper script for m1f-scrape module."""

from scrape_tool.cli import main

if __name__ == "__main__":
    main()

======= setup.py | CHECKSUM_SHA256: 3f50b4e986d5c78e67b7642082a56f896f21055e9122d7cc4dadae520f02b98b ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Setup script for the m1f tool.
"""

import os
import re
from setuptools import setup, find_packages

# Read version from _version.py
version_file = os.path.join(os.path.dirname(__file__), "_version.py")
with open(version_file, "r", encoding="utf-8") as f:
    version_match = re.search(
        r'^__version__\s*=\s*[\'"]([^\'"]*)[\'"]', f.read(), re.MULTILINE
    )
    if version_match:
        version = version_match.group(1)
    else:
        raise RuntimeError("Unable to find version string in _version.py")

setup(
    name="m1f",
    version=version,
    description="m1f - Make One File - Combine multiple text files into a single output file",
    author="Franz und Franz",
    author_email="office@franz.agency",
    url="https://m1f.dev",
    packages=find_packages(),
    entry_points={
        "console_scripts": [
            "m1f=m1f_refactored:main",
        ],
    },
    python_requires=">=3.10",
    install_requires=[
        "pathspec>=0.11.0",
        "tiktoken>=0.5.0",
        "colorama>=0.4.6",
    ],
    extras_require={
        "full": [
            "chardet>=5.0.0",
            "detect-secrets>=1.4.0",
        ],
    },
    classifiers=[
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: Apache Software License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
    ],
)

======= token_counter.py | CHECKSUM_SHA256: 0913ce3f978ecbcc5da76ef01f9fd3e33c062c10f2960018bcdb9fab03beff12 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import tiktoken
import os


def count_tokens_in_file(file_path: str, encoding_name: str = "cl100k_base") -> int:
    """
    Reads a file and counts the number of tokens using a specified tiktoken encoding.

    Args:
        file_path (str): The path to the file.
        encoding_name (str): The name of the encoding to use (e.g., "cl100k_base", "p50k_base").
                             "cl100k_base" is the encoding used by gpt-4, gpt-3.5-turbo, text-embedding-ada-002.

    Returns:
        int: The number of tokens in the file.

    Raises:
        FileNotFoundError: If the specified file does not exist.
        Exception: For other issues like encoding errors or tiktoken issues.
    """
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"Error: File not found at {file_path}")

    try:
        with open(file_path, "r", encoding="utf-8") as f:
            text_content = f.read()
    except UnicodeDecodeError:
        # Fallback to reading as bytes if UTF-8 fails, then decode with replacement
        with open(file_path, "rb") as f:
            byte_content = f.read()
        text_content = byte_content.decode("utf-8", errors="replace")
    except Exception as e:
        raise Exception(f"Error reading file {file_path}: {e}")

    try:
        encoding = tiktoken.get_encoding(encoding_name)
        tokens = encoding.encode(text_content)
        return len(tokens)
    except Exception as e:
        # Fallback or error message if tiktoken fails
        # For simplicity, we'll raise an error here.
        # A more robust solution might try a simpler word count or character count.
        raise Exception(
            f"Error using tiktoken: {e}. Ensure tiktoken is installed and encoding_name is valid."
        )


def main():
    """
    Main function to parse arguments and print token count.
    """
    parser = argparse.ArgumentParser(
        description="Count tokens in a text file using OpenAI's tiktoken library.",
        epilog="Example: python token_counter.py myfile.txt -e p50k_base",
    )
    parser.add_argument(
        "file_path", type=str, help="Path to the text file (txt, php, md, etc.)."
    )
    parser.add_argument(
        "-e",
        "--encoding",
        type=str,
        default="cl100k_base",
        help='The tiktoken encoding to use. Defaults to "cl100k_base" (used by gpt-4, gpt-3.5-turbo).',
    )

    args = parser.parse_args()

    try:
        token_count = count_tokens_in_file(args.file_path, args.encoding)
        print(
            f"The file '{args.file_path}' contains approximately {token_count} tokens (using '{args.encoding}' encoding)."
        )
    except FileNotFoundError as e:
        print(e)
    except Exception as e:
        print(f"An error occurred: {e}")


if __name__ == "__main__":
    main()

======= wp_export_md.py | CHECKSUM_SHA256: deeb016926138aa6e0571a358822e144b8eb63a1a237b94c0c68539d451d4ef0 ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Export WordPress content to Markdown files using WP CLI.

This utility fetches posts and pages from a WordPress installation via
WP CLI and saves each as a separate Markdown file.
"""

import argparse
import json
import subprocess
from pathlib import Path
from typing import Iterable

from markdownify import markdownify as md


def run_wp_cli(args: Iterable[str], wp_path: str | None = None) -> str:
    """Run a WP CLI command and return its standard output."""
    cmd = ["wp", *args]
    if wp_path:
        cmd.append(f"--path={wp_path}")
    result = subprocess.run(cmd, capture_output=True, text=True, check=True)
    return result.stdout.strip()


def export_post(post_id: str, post_type: str, dest: Path, wp_path: str | None) -> None:
    """Export a single post to a Markdown file."""
    data = json.loads(run_wp_cli(["post", "get", post_id, "--format=json"], wp_path))
    title = data.get("post_title", "")
    slug = run_wp_cli(["post", "get", post_id, "--field=post_name"], wp_path) or post_id
    content = data.get("post_content", "")
    md_content = f"# {title}\n\n" + md(content)
    dest.mkdir(parents=True, exist_ok=True)
    outfile = dest / f"{slug}.md"
    outfile.write_text(md_content, encoding="utf-8")


def export_post_type(post_type: str, dest: Path, wp_path: str | None) -> None:
    """Export all posts of a given type."""
    ids = run_wp_cli(
        [
            "post",
            "list",
            f"--post_type={post_type}",
            "--format=ids",
        ],
        wp_path,
    )
    if not ids:
        return
    for post_id in ids.split():
        export_post(post_id, post_type, dest / post_type, wp_path)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Export WordPress content to Markdown using WP CLI"
    )
    parser.add_argument(
        "--output-dir", required=True, help="Directory to write Markdown files"
    )
    parser.add_argument(
        "--post-types",
        default="post,page",
        help="Comma-separated list of post types to export (default: post,page)",
    )
    parser.add_argument(
        "--wp-path",
        default=None,
        help="Path to the WordPress installation for WP CLI",
    )
    args = parser.parse_args()
    dest = Path(args.output_dir)
    for pt in [p.strip() for p in args.post_types.split(",") if p.strip()]:
        export_post_type(pt, dest, args.wp_path)


if __name__ == "__main__":
    main()

======= html2md_tool/__init__.py | CHECKSUM_SHA256: c1ed0a807b2922fa280777a578d27a83ad8518cb2bbfeb7168ff97a3f46f0f73 ======
"""
HTML to Markdown Converter - Modern Web Content Extraction Tool

A powerful, modular tool for converting HTML content to Markdown format,
optimized for processing entire websites and integration with m1f.
"""

try:
    from .._version import __version__, __version_info__
except ImportError:
    # Fallback when running as standalone script
    __version__ = "3.1.0"
    __version_info__ = (3, 1, 0)

__author__ = "Franz und Franz (https://franz.agency)"

from .api import Html2mdConverter
from .config import Config, ConversionOptions
from .core import HTMLParser, MarkdownConverter
from .utils import convert_html, adjust_internal_links, extract_title_from_html

# Alias for backward compatibility
HTML2MDConverter = Html2mdConverter

__all__ = [
    "Html2mdConverter",
    "HTML2MDConverter",  # Alias
    "Config",
    "ConversionOptions",
    "HTMLParser",
    "MarkdownConverter",
    "convert_html",
    "adjust_internal_links",
    "extract_title_from_html",
]

======= html2md_tool/__main__.py | CHECKSUM_SHA256: 1dfc79852e3bea6d920a63682ca7a847ecf66f4e756f0aa112d8f726acfbf443 ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
# SPDX-License-Identifier: Apache-2.0

"""Module execution entry point for mf1-html2md."""

from .cli import main

if __name__ == "__main__":
    main()

======= html2md_tool/analyze_html.py | CHECKSUM_SHA256: fc6c8891d160a582a34390cb7e3bd671fa98c82f34eab04fcfca99cc56debe43 ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Analyze HTML files to suggest preprocessing configuration."""

import argparse
from pathlib import Path
from bs4 import BeautifulSoup, Comment
from collections import Counter, defaultdict
from typing import List, Dict, Set, Tuple
import json
import sys


class HTMLAnalyzer:
    """Analyze HTML files to identify patterns for preprocessing."""

    def __init__(self):
        self.reset_stats()

    def reset_stats(self):
        """Reset analysis statistics."""
        self.element_counts = Counter()
        self.class_counts = Counter()
        self.id_counts = Counter()
        self.comment_samples = []
        self.url_patterns = defaultdict(set)
        self.meta_patterns = defaultdict(list)
        self.empty_elements = Counter()
        self.script_styles = {"script": [], "style": []}

    def analyze_file(self, file_path: Path) -> Dict:
        """Analyze a single HTML file."""
        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                html = f.read()
        except Exception as e:
            return {"error": str(e)}

        soup = BeautifulSoup(html, "html.parser")

        # Count all elements
        for tag in soup.find_all():
            self.element_counts[tag.name] += 1

            # Count classes
            if classes := tag.get("class"):
                for cls in classes:
                    self.class_counts[cls] += 1

            # Count IDs
            if tag_id := tag.get("id"):
                self.id_counts[tag_id] += 1

            # Check for empty elements
            if (
                tag.name not in ["img", "br", "hr", "input", "meta", "link"]
                and not tag.get_text(strip=True)
                and not tag.find_all(["img", "table", "ul", "ol"])
            ):
                self.empty_elements[tag.name] += 1

        # Analyze comments
        for comment in soup.find_all(string=lambda text: isinstance(text, Comment)):
            comment_text = str(comment).strip()
            if len(comment_text) < 200:  # Only short comments
                self.comment_samples.append(comment_text)

        # Analyze URLs
        for tag in soup.find_all(["a", "link", "img", "script"]):
            for attr in ["href", "src"]:
                if url := tag.get(attr):
                    # Identify patterns
                    if url.startswith("file://"):
                        self.url_patterns["file_urls"].add(url[:50] + "...")
                    elif url.startswith("http://") or url.startswith("https://"):
                        self.url_patterns["absolute_urls"].add(url[:50] + "...")
                    elif url.startswith("/"):
                        self.url_patterns["root_relative"].add(url[:50] + "...")

        # Analyze meta information sections
        # Look for common patterns like "Written by", "Last updated", etc.
        for text in soup.find_all(string=True):
            text_str = text.strip()
            if any(
                pattern in text_str
                for pattern in [
                    "Written by:",
                    "Last updated:",
                    "Created:",
                    "Modified:",
                    "Author:",
                    "Maintainer:",
                ]
            ):
                parent = text.parent
                if parent:
                    self.meta_patterns["metadata_text"].append(
                        {
                            "text": text_str[:100],
                            "parent_tag": parent.name,
                            "parent_class": parent.get("class", []),
                        }
                    )

        # Sample script/style content
        for tag_type in ["script", "style"]:
            for tag in soup.find_all(tag_type)[:3]:  # First 3 of each
                content = tag.get_text()[:200]
                if content:
                    self.script_styles[tag_type].append(content + "...")

        return {"file": str(file_path), "success": True}

    def suggest_config(self) -> Dict:
        """Suggest preprocessing configuration based on analysis."""
        suggestions = {
            "remove_elements": ["script", "style"],  # Always remove these
            "remove_selectors": [],
            "remove_ids": [],
            "remove_classes": [],
            "remove_comments_containing": [],
            "fix_url_patterns": {},
            "remove_empty_elements": False,
        }

        # Suggest removing rare IDs (likely unique to layout)
        total_files = sum(1 for count in self.id_counts.values())
        for id_name, count in self.id_counts.items():
            if count == 1 and any(
                pattern in id_name.lower()
                for pattern in [
                    "header",
                    "footer",
                    "nav",
                    "sidebar",
                    "menu",
                    "path",
                    "breadcrumb",
                ]
            ):
                suggestions["remove_ids"].append(id_name)

        # Suggest removing common layout classes
        layout_keywords = [
            "header",
            "footer",
            "nav",
            "menu",
            "sidebar",
            "toolbar",
            "breadcrumb",
            "metadata",
            "pageinfo",
        ]
        for class_name, count in self.class_counts.items():
            if any(keyword in class_name.lower() for keyword in layout_keywords):
                suggestions["remove_classes"].append(class_name)

        # Suggest comment patterns to remove
        comment_keywords = ["Generated", "HTTrack", "Mirrored", "Added by"]
        seen_patterns = set()
        for comment in self.comment_samples:
            for keyword in comment_keywords:
                if keyword in comment and keyword not in seen_patterns:
                    suggestions["remove_comments_containing"].append(keyword)
                    seen_patterns.add(keyword)

        # Suggest URL fixes
        if self.url_patterns["file_urls"]:
            suggestions["fix_url_patterns"]["file://"] = "./"

        # Suggest removing empty elements if many found
        total_empty = sum(self.empty_elements.values())
        if total_empty > 10:
            suggestions["remove_empty_elements"] = True

        # Remove empty lists from suggestions
        suggestions = {k: v for k, v in suggestions.items() if v or isinstance(v, bool)}

        return suggestions

    def get_report(self) -> Dict:
        """Get detailed analysis report."""
        return {
            "statistics": {
                "total_elements": sum(self.element_counts.values()),
                "unique_elements": len(self.element_counts),
                "unique_classes": len(self.class_counts),
                "unique_ids": len(self.id_counts),
                "empty_elements": sum(self.empty_elements.values()),
                "comments_found": len(self.comment_samples),
            },
            "top_elements": self.element_counts.most_common(10),
            "top_classes": self.class_counts.most_common(10),
            "top_ids": self.id_counts.most_common(10),
            "url_patterns": {k: list(v)[:5] for k, v in self.url_patterns.items()},
            "comment_samples": self.comment_samples[:5],
            "metadata_patterns": self.meta_patterns,
        }


def main():
    parser = argparse.ArgumentParser(
        description="Analyze HTML files for preprocessing configuration"
    )
    parser.add_argument("files", nargs="+", help="HTML files to analyze")
    parser.add_argument("--output", "-o", help="Output configuration file (JSON)")
    parser.add_argument(
        "--report", "-r", action="store_true", help="Show detailed report"
    )

    args = parser.parse_args()

    analyzer = HTMLAnalyzer()

    # Analyze all files
    print(f"Analyzing {len(args.files)} files...")
    for file_path in args.files:
        path = Path(file_path)
        if path.exists() and path.suffix.lower() in [".html", ".htm"]:
            result = analyzer.analyze_file(path)
            if "error" in result:
                print(f"Error analyzing {path}: {result['error']}")

    # Get suggestions
    config = analyzer.suggest_config()

    # Show report if requested
    if args.report:
        report = analyzer.get_report()
        print("\n=== Analysis Report ===")
        print(json.dumps(report, indent=2))

    # Show suggested configuration
    print("\n=== Suggested Preprocessing Configuration ===")
    print(json.dumps(config, indent=2))

    # Save to file if requested
    if args.output:
        with open(args.output, "w") as f:
            json.dump(config, f, indent=2)
        print(f"\nConfiguration saved to: {args.output}")

    print(
        "\nTo use this configuration, create a preprocessing config in your conversion script."
    )
    print("Example usage in Python:")
    print("```python")
    print("from tools.mf1-html2md.preprocessors import PreprocessingConfig")
    print("config = PreprocessingConfig(**<loaded_json>)")
    print("```")


if __name__ == "__main__":
    main()

======= html2md_tool/api.py | CHECKSUM_SHA256: eb79a069b366fd5d7b4a37af37af2712d7a777b5382a7ac64f4c317945c43b1d ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""High-level API for HTML to Markdown conversion."""

import asyncio
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor
from pathlib import Path
from typing import Dict, List, Optional, Union

from rich.console import Console
from rich.progress import Progress

from .config import (
    Config,
    ConversionOptions,
    OutputFormat,
    ExtractorConfig,
    ProcessorConfig,
)
from .core import HTMLParser, MarkdownConverter
from .extractors import BaseExtractor, DefaultExtractor, load_extractor
from .utils import configure_logging, get_logger

logger = get_logger(__name__)


class Html2mdConverter:
    """Main API class for HTML to Markdown conversion."""

    def __init__(
        self,
        config: Union[Config, ConversionOptions, Dict, Path, str, None] = None,
        extractor: Optional[Union[BaseExtractor, Path, str]] = None,
    ):
        """Initialize converter with configuration.

        Args:
            config: Configuration object, ConversionOptions, dict, path to config file, or None
            extractor: Custom extractor instance, path to extractor file, or None
        """
        if config is None:
            self.config = Config(source=Path("."), destination=Path("."))
        elif isinstance(config, Config):
            self.config = config
        elif isinstance(config, ConversionOptions):
            # Create Config from ConversionOptions
            self.config = Config(
                source=Path(config.source_dir) if config.source_dir else Path("."),
                destination=(
                    config.destination_dir if config.destination_dir else Path(".")
                ),
                conversion=config,
            )
        elif isinstance(config, dict):
            self.config = Config(**config)
        elif isinstance(config, (Path, str)):
            from .config import load_config

            self.config = load_config(Path(config))
        else:
            raise TypeError(f"Invalid config type: {type(config)}")

        # Configure logging
        configure_logging(
            verbose=getattr(self.config, "verbose", False),
            quiet=getattr(self.config, "quiet", False),
            log_file=getattr(self.config, "log_file", None),
        )

        # Initialize components
        self._parser = HTMLParser(getattr(self.config, "extractor", ExtractorConfig()))
        self._converter = MarkdownConverter(
            getattr(self.config, "processor", ProcessorConfig())
        )
        self._console = Console()

        # Initialize extractor
        if extractor is None:
            self._extractor = DefaultExtractor()
        elif isinstance(extractor, BaseExtractor):
            self._extractor = extractor
        elif isinstance(extractor, (Path, str)):
            self._extractor = load_extractor(Path(extractor))
        else:
            raise TypeError(f"Invalid extractor type: {type(extractor)}")

    def convert_html(
        self,
        html_content: str,
        base_url: Optional[str] = None,
        source_file: Optional[str] = None,
    ) -> str:
        """Convert HTML content to Markdown.

        Args:
            html_content: HTML content to convert
            base_url: Optional base URL for resolving relative links
            source_file: Optional source file name

        Returns:
            Markdown content
        """
        # Apply custom extractor preprocessing
        html_content = self._extractor.preprocess(html_content, self.config.__dict__)

        # Apply preprocessing if configured
        if hasattr(self.config, "preprocessing") and self.config.preprocessing:
            from .preprocessors import preprocess_html

            html_content = preprocess_html(html_content, self.config.preprocessing)

        # Parse HTML
        parsed = self._parser.parse(html_content, base_url)

        # Apply custom extractor
        parsed = self._extractor.extract(parsed, self.config.__dict__)

        # Handle CSS selectors if specified (after extraction)
        if self.config.conversion.outermost_selector:
            from bs4 import BeautifulSoup

            selected = parsed.select_one(self.config.conversion.outermost_selector)
            if selected:
                # Remove ignored elements
                if self.config.conversion.ignore_selectors:
                    for selector in self.config.conversion.ignore_selectors:
                        for elem in selected.select(selector):
                            elem.decompose()
                # Create new soup from selected element
                parsed = BeautifulSoup(str(selected), "html.parser")

        # Remove script and style tags that may have been missed
        for tag in parsed.find_all(["script", "style", "noscript"]):
            tag.decompose()

        # Apply heading offset if specified
        if self.config.conversion.heading_offset:
            for i in range(1, 7):
                for tag in parsed.find_all(f"h{i}"):
                    new_level = max(
                        1, min(6, i + self.config.conversion.heading_offset)
                    )
                    tag.name = f"h{new_level}"

        # Convert to markdown
        options = {}
        if self.config.conversion.code_language:
            options["code_language"] = self.config.conversion.code_language
        if self.config.conversion.heading_style:
            options["heading_style"] = self.config.conversion.heading_style

        markdown = self._converter.convert(parsed, options)

        # Add frontmatter if requested
        if self.config.conversion.generate_frontmatter:
            import yaml

            frontmatter = self.config.conversion.frontmatter_fields or {}

            # Extract title from HTML if not provided
            if "title" not in frontmatter:
                title_tag = parsed.find("title")
                if title_tag and title_tag.string:
                    frontmatter["title"] = title_tag.string.strip()

            # Add source file if provided
            if source_file and "source_file" not in frontmatter:
                frontmatter["source_file"] = source_file

            if frontmatter:
                fm_str = yaml.dump(frontmatter, default_flow_style=False)
                markdown = f"---\n{fm_str}---\n\n{markdown}"

        # Apply custom extractor postprocessing
        markdown = self._extractor.postprocess(markdown, self.config.__dict__)

        return markdown

    async def convert_directory_from_urls(self, urls: List[str]) -> List[Path]:
        """Convert multiple URLs in parallel.

        Args:
            urls: List of URLs to convert

        Returns:
            List of output file paths
        """
        # Simple implementation for tests
        results = []
        for url in urls:
            # Actually convert the URL
            output_path = self.convert_url(url)
            results.append(output_path)
        return results

    def convert_file(self, file_path: Path) -> Path:
        """Convert a single HTML file to Markdown.

        Args:
            file_path: Path to HTML file

        Returns:
            Path to generated Markdown file
        """
        logger.info(f"Converting {file_path}")

        # Read file content
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                html_content = f.read()
        except UnicodeDecodeError:
            # Try with different encodings
            for encoding in ["latin-1", "cp1252"]:
                try:
                    with open(file_path, "r", encoding=encoding) as f:
                        html_content = f.read()
                    break
                except UnicodeDecodeError:
                    continue
            else:
                # Last resort - ignore errors
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    html_content = f.read()

        # Convert using the convert_html method which includes preprocessing
        # Ensure we have an absolute path for the URI
        abs_file_path = file_path.resolve()
        markdown = self.convert_html(
            html_content, base_url=abs_file_path.as_uri(), source_file=str(file_path)
        )

        # Determine output path
        if file_path.is_relative_to(self.config.source):
            rel_path = file_path.relative_to(self.config.source)
        else:
            rel_path = file_path.name

        output_path = self.config.destination / rel_path.with_suffix(".md")
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Write file
        output_path.write_text(markdown, encoding=self.config.target_encoding)

        logger.debug(f"Written to {output_path}")
        return output_path

    def convert_directory(
        self, source_dir: Optional[Path] = None, recursive: bool = True
    ) -> List[Path]:
        """Convert all HTML files in a directory.

        Args:
            source_dir: Source directory (uses config if not specified)
            recursive: Whether to search recursively

        Returns:
            List of generated Markdown files
        """
        source_dir = source_dir or self.config.source

        # Find HTML files
        pattern = "**/*" if recursive else "*"
        html_files = []

        for ext in self.config.file_extensions:
            html_files.extend(source_dir.glob(f"{pattern}{ext}"))

        # Filter excluded patterns
        if self.config.exclude_patterns:
            import fnmatch

            filtered = []
            for file in html_files:
                excluded = False
                for pattern in self.config.exclude_patterns:
                    if fnmatch.fnmatch(str(file), pattern):
                        excluded = True
                        break
                if not excluded:
                    filtered.append(file)
            html_files = filtered

        logger.info(f"Found {len(html_files)} files to convert")

        # Convert files
        if self.config.parallel and len(html_files) > 1:
            return self._convert_parallel(html_files)
        else:
            return self._convert_sequential(html_files)

    def convert_url(self, url: str) -> Path:
        """Convert a web page to Markdown.

        Args:
            url: URL to convert

        Returns:
            Path to generated Markdown file
        """
        import requests
        from urllib.parse import urlparse

        logger.info(f"Fetching {url}")

        # Fetch HTML
        response = requests.get(url)
        response.raise_for_status()

        # Convert HTML to Markdown
        markdown = self.convert_html(response.text, base_url=url)

        # Determine output filename
        parsed_url = urlparse(url)
        path_parts = parsed_url.path.strip("/").split("/")
        filename = path_parts[-1] if path_parts and path_parts[-1] else "index"
        if not filename.endswith(".md"):
            filename = filename.replace(".html", "") + ".md"
        output_path = Path(self.config.destination) / filename
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Write file
        encoding = getattr(self.config, "target_encoding", "utf-8")
        output_path.write_text(markdown, encoding=encoding)

        logger.info(f"Saved to {output_path}")
        return output_path

    def convert_website(self, start_url: str) -> Dict[str, Path]:
        """Convert an entire website to Markdown.

        DEPRECATED: Use the m1f-scrape tool to download websites first,
        then use convert_directory to convert the downloaded HTML files.

        Args:
            start_url: Starting URL for crawling

        Returns:
            Dictionary mapping source files to generated markdown files
        """
        logger.warning(
            "convert_website is deprecated. Use m1f-scrape tool for downloading."
        )
        logger.info(f"Website conversion starting from {start_url}")

        # Import crawler from m1f-scrape module
        raise NotImplementedError(
            "Website crawling has been moved to the m1f-scrape tool. "
            "Please use: python -m tools.m1f-scrape <url> -o <output_dir>"
        )

    async def convert_website_async(self, start_url: str) -> Dict[str, Path]:
        """Async version of convert_website for backward compatibility.

        Args:
            start_url: Starting URL for crawling

        Returns:
            Dictionary mapping URLs to generated files
        """
        # HTTrack runs synchronously, so we just wrap the sync method
        return self.convert_website(start_url)

    def _convert_sequential(self, files: List[Path]) -> List[Path]:
        """Convert files sequentially."""
        results = []

        with Progress() as progress:
            task = progress.add_task("Converting files...", total=len(files))

            for file in files:
                try:
                    output = self.convert_file(file)
                    results.append(output)
                except Exception as e:
                    logger.error(f"Failed to convert {file}: {e}")
                finally:
                    progress.update(task, advance=1)

        return results

    def _convert_parallel(self, files: List[Path]) -> List[Path]:
        """Convert files in parallel."""
        results = []
        max_workers = self.config.max_workers or None

        with Progress() as progress:
            task = progress.add_task("Converting files...", total=len(files))

            with ProcessPoolExecutor(max_workers=max_workers) as executor:
                futures = {
                    executor.submit(self._convert_file_wrapper, file): file
                    for file in files
                }

                for future in futures:
                    try:
                        output = future.result()
                        if output:
                            results.append(output)
                    except Exception as e:
                        logger.error(f"Failed to convert {futures[future]}: {e}")
                    finally:
                        progress.update(task, advance=1)

        return results

    def _convert_file_wrapper(self, file_path: Path) -> Optional[Path]:
        """Wrapper for parallel processing."""
        try:
            # Re-initialize parser and converter in worker process
            parser = HTMLParser(self.config.extractor)
            converter = MarkdownConverter(self.config.processor)

            parsed = parser.parse_file(file_path)
            markdown = converter.convert(parsed)

            # Determine output path
            if file_path.is_relative_to(self.config.source):
                rel_path = file_path.relative_to(self.config.source)
            else:
                rel_path = file_path.name

            output_path = self.config.destination / rel_path.with_suffix(".md")
            output_path.parent.mkdir(parents=True, exist_ok=True)
            output_path.write_text(markdown, encoding=self.config.target_encoding)

            return output_path
        except Exception as e:
            logger.error(f"Error in worker: {e}")
            return None

    def generate_m1f_bundle(self) -> Path:
        """Generate an m1f bundle from converted files.

        Returns:
            Path to generated m1f bundle
        """
        if not self.config.m1f.create_bundle:
            raise ValueError("m1f bundle creation not enabled in config")

        logger.info("Generating m1f bundle...")

        # Import m1f integration
        from .processors.m1f_integration import M1FBundler

        bundler = M1FBundler(self.config.m1f)
        bundle_path = bundler.create_bundle(
            self.config.destination, bundle_name=self.config.m1f.bundle_name
        )

        logger.info(f"Created m1f bundle: {bundle_path}")
        return bundle_path


# Convenience functions
def convert_file(file_path: Union[str, Path], **kwargs) -> Path:
    """Convert a single HTML file to Markdown.

    Args:
        file_path: Path to HTML file
        **kwargs: Additional configuration options

    Returns:
        Path to generated Markdown file
    """
    config = Config(
        source=Path(file_path).parent,
        destination=kwargs.pop("destination", Path(".")),
        **kwargs,
    )
    converter = Html2mdConverter(config)
    return converter.convert_file(Path(file_path))


def convert_directory(
    source_dir: Union[str, Path], destination_dir: Union[str, Path], **kwargs
) -> List[Path]:
    """Convert all HTML files in a directory to Markdown.

    Args:
        source_dir: Source directory containing HTML files
        destination_dir: Destination directory for Markdown files
        **kwargs: Additional configuration options

    Returns:
        List of generated Markdown files
    """
    config = Config(
        source=Path(source_dir), destination=Path(destination_dir), **kwargs
    )
    converter = Html2mdConverter(config)
    return converter.convert_directory()


def convert_url(url: str, destination_dir: Union[str, Path] = ".", **kwargs) -> Path:
    """Convert a web page to Markdown.

    Args:
        url: URL to convert
        destination_dir: Destination directory
        **kwargs: Additional configuration options

    Returns:
        Path to generated Markdown file
    """
    config = Config(
        source=Path("."),  # Not used for URL conversion
        destination=Path(destination_dir),
        **kwargs,
    )
    converter = Html2mdConverter(config)
    return converter.convert_url(url)


def convert_html(html_content: str, **kwargs) -> str:
    """Convert HTML content to Markdown.

    Args:
        html_content: HTML content to convert
        **kwargs: Additional options

    Returns:
        Markdown content
    """
    from pathlib import Path
    from .config.models import ConversionOptions, Config

    # Create minimal config
    config = Config(
        source=Path("."),
        destination=Path("."),
    )

    # Apply conversion options
    if kwargs:
        for key, value in kwargs.items():
            if hasattr(config.conversion, key):
                setattr(config.conversion, key, value)

    converter = Html2mdConverter(config)
    return converter.convert_html(html_content)

======= html2md_tool/cli.py | CHECKSUM_SHA256: 26aa3eb75a7848aa244b8a9fb59bf11bacc3a3ef564cd23af96d6550c66825c5 ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Command-line interface for HTML to Markdown converter."""

import argparse
import sys
from pathlib import Path
from typing import List, Optional

from rich.console import Console

from . import __version__
from .api import Html2mdConverter
from .config import Config, OutputFormat

console = Console()


def create_parser() -> argparse.ArgumentParser:
    """Create the argument parser."""
    parser = argparse.ArgumentParser(
        prog="mf1-html2md",
        description="Convert HTML files to Markdown format with advanced options",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Convert a single file
  mf1-html2md convert file.html -o file.md
  
  # Convert entire directory
  mf1-html2md convert ./docs/html/ -o ./docs/markdown/
  
  # Convert a website
  mf1-html2md crawl https://example.com -o ./example-docs/
  
  # Use configuration file
  mf1-html2md convert ./html/ -c config.yaml
  
  # Extract specific content
  mf1-html2md convert ./html/ -o ./md/ --content-selector "article.post"
""",
    )

    parser.add_argument(
        "--version", action="version", version=f"%(prog)s {__version__}"
    )

    # Global options
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose output"
    )

    parser.add_argument(
        "-q", "--quiet", action="store_true", help="Suppress all output except errors"
    )

    parser.add_argument("--log-file", type=Path, help="Log to file")

    # Subcommands
    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Convert command
    convert_parser = subparsers.add_parser(
        "convert", help="Convert HTML files to Markdown"
    )
    add_convert_arguments(convert_parser)

    # Analyze command
    analyze_parser = subparsers.add_parser(
        "analyze", help="Analyze HTML structure for selector suggestions"
    )
    add_analyze_arguments(analyze_parser)

    # Config command
    config_parser = subparsers.add_parser("config", help="Generate configuration file")
    add_config_arguments(config_parser)

    return parser


def add_convert_arguments(parser: argparse.ArgumentParser) -> None:
    """Add arguments for convert command."""
    parser.add_argument("source", type=Path, help="Source file or directory")

    parser.add_argument(
        "-o", "--output", type=Path, required=True, help="Output file or directory"
    )

    parser.add_argument("-c", "--config", type=Path, help="Configuration file")

    parser.add_argument(
        "--format",
        choices=["markdown", "m1f_bundle", "json"],
        default="markdown",
        help="Output format",
    )

    # Content extraction options
    parser.add_argument("--content-selector", help="CSS selector for main content")

    parser.add_argument("--ignore-selectors", nargs="+", help="CSS selectors to ignore")

    parser.add_argument(
        "--heading-offset", type=int, default=0, help="Offset heading levels"
    )

    parser.add_argument(
        "--no-frontmatter", action="store_true", help="Don't add YAML frontmatter"
    )

    parser.add_argument(
        "--parallel", action="store_true", help="Enable parallel processing"
    )

    parser.add_argument(
        "--extractor", type=Path, help="Path to custom extractor Python file"
    )


def add_analyze_arguments(parser: argparse.ArgumentParser) -> None:
    """Add arguments for analyze command."""
    parser.add_argument(
        "files",
        nargs="+",
        type=Path,
        help="HTML files to analyze (2-3 files recommended)",
    )

    parser.add_argument(
        "--show-structure", action="store_true", help="Show detailed HTML structure"
    )

    parser.add_argument(
        "--common-patterns",
        action="store_true",
        help="Find common patterns across files",
    )

    parser.add_argument(
        "--suggest-selectors",
        action="store_true",
        help="Suggest CSS selectors for content extraction",
    )


def add_config_arguments(parser: argparse.ArgumentParser) -> None:
    """Add arguments for config command."""
    parser.add_argument(
        "-o",
        "--output",
        type=Path,
        default=Path("config.yaml"),
        help="Output configuration file",
    )

    parser.add_argument(
        "--format",
        choices=["yaml", "toml", "json"],
        default="yaml",
        help="Configuration format",
    )


def handle_convert(args: argparse.Namespace) -> None:
    """Handle convert command."""
    # Load configuration
    if args.config:
        from .config import load_config

        config = load_config(args.config)
    else:
        config = Config(source=args.source, destination=args.output)

    # Update config with CLI arguments
    if args.content_selector:
        config.extractor.content_selector = args.content_selector

    if args.ignore_selectors:
        config.extractor.ignore_selectors = args.ignore_selectors

    if args.heading_offset:
        config.processor.heading_offset = args.heading_offset

    if args.no_frontmatter:
        config.processor.add_frontmatter = False

    if args.parallel:
        config.parallel = True

    if hasattr(args, "format"):
        config.output_format = OutputFormat(args.format)

    config.verbose = args.verbose
    config.quiet = args.quiet
    config.log_file = args.log_file

    # Create converter
    extractor = args.extractor if hasattr(args, "extractor") else None
    converter = Html2mdConverter(config, extractor=extractor)

    # Convert based on source type
    if args.source.is_file():
        console.print(f"Converting file: {args.source}")
        output = converter.convert_file(args.source)
        console.print(f"✅ Converted to: {output}", style="green")

    elif args.source.is_dir():
        console.print(f"Converting directory: {args.source}")
        outputs = converter.convert_directory()
        console.print(f"✅ Converted {len(outputs)} files", style="green")

    else:
        console.print(f"❌ Source not found: {args.source}", style="red")
        sys.exit(1)


def handle_analyze(args: argparse.Namespace) -> None:
    """Handle analyze command."""
    from bs4 import BeautifulSoup
    from collections import Counter
    import json

    console.print(f"Analyzing {len(args.files)} HTML files...")

    # Read and parse all files
    parsed_files = []
    for file_path in args.files:
        if not file_path.exists():
            console.print(f"❌ File not found: {file_path}", style="red")
            continue

        try:
            content = file_path.read_text(encoding="utf-8")
            soup = BeautifulSoup(content, "html.parser")
            parsed_files.append((file_path, soup))
            console.print(f"✅ Parsed: {file_path.name}", style="green")
        except Exception as e:
            console.print(f"❌ Error parsing {file_path}: {e}", style="red")

    if not parsed_files:
        console.print("No files could be parsed", style="red")
        sys.exit(1)

    # Analyze structure
    if args.show_structure:
        console.print("\n[bold]HTML Structure Analysis:[/bold]")
        for file_path, soup in parsed_files:
            console.print(f"\n[blue]{file_path.name}:[/blue]")
            _show_structure(soup)

    # Find common patterns
    if args.common_patterns:
        console.print("\n[bold]Common Patterns:[/bold]")
        _find_common_patterns(parsed_files)

    # Suggest selectors
    if args.suggest_selectors or (not args.show_structure and not args.common_patterns):
        console.print("\n[bold]Suggested CSS Selectors:[/bold]")
        suggestions = _suggest_selectors(parsed_files)

        console.print("\n[yellow]Content selectors:[/yellow]")
        for selector, confidence in suggestions["content"]:
            console.print(f"  {selector} (confidence: {confidence:.0%})")

        console.print("\n[yellow]Elements to ignore:[/yellow]")
        for selector in suggestions["ignore"]:
            console.print(f"  {selector}")

        # Print example configuration
        console.print("\n[bold]Example configuration:[/bold]")
        console.print("```yaml")
        console.print("extractor:")
        if suggestions["content"]:
            console.print(f"  content_selector: \"{suggestions['content'][0][0]}\"")
        console.print("  ignore_selectors:")
        for selector in suggestions["ignore"]:
            console.print(f'    - "{selector}"')
        console.print("```")


def _show_structure(soup):
    """Show the structure of an HTML document."""
    # Find main content areas
    main_areas = soup.find_all(["main", "article", "section", "div"], limit=10)

    for area in main_areas:
        # Get identifying attributes
        attrs = []
        if area.get("id"):
            attrs.append(f"id=\"{area.get('id')}\"")
        if area.get("class"):
            classes = " ".join(area.get("class"))
            attrs.append(f'class="{classes}"')

        attr_str = " ".join(attrs) if attrs else ""
        console.print(f"  <{area.name} {attr_str}>")

        # Show child elements
        for child in area.find_all(recursive=False, limit=5):
            if child.name:
                child_attrs = []
                if child.get("id"):
                    child_attrs.append(f"id=\"{child.get('id')}\"")
                if child.get("class"):
                    child_classes = " ".join(child.get("class"))
                    child_attrs.append(f'class="{child_classes}"')
                child_attr_str = " ".join(child_attrs) if child_attrs else ""
                console.print(f"    <{child.name} {child_attr_str}>")


def _find_common_patterns(parsed_files):
    """Find common patterns across HTML files."""
    # Collect all class names and IDs
    all_classes = Counter()
    all_ids = Counter()
    tag_patterns = Counter()

    for _, soup in parsed_files:
        # Count classes
        for elem in soup.find_all(class_=True):
            for cls in elem.get("class", []):
                all_classes[cls] += 1

        # Count IDs
        for elem in soup.find_all(id=True):
            all_ids[elem.get("id")] += 1

        # Count tag patterns
        for elem in soup.find_all(
            ["main", "article", "section", "header", "footer", "nav", "aside"]
        ):
            tag_patterns[elem.name] += 1

    # Show most common patterns
    console.print("\n[yellow]Most common classes:[/yellow]")
    for cls, count in all_classes.most_common(10):
        console.print(f"  .{cls} (found {count} times)")

    console.print("\n[yellow]Most common IDs:[/yellow]")
    for id_name, count in all_ids.most_common(10):
        console.print(f"  #{id_name} (found {count} times)")

    console.print("\n[yellow]Common structural elements:[/yellow]")
    for tag, count in tag_patterns.most_common():
        console.print(f"  <{tag}> (found {count} times)")


def _suggest_selectors(parsed_files):
    """Suggest CSS selectors for content extraction."""
    suggestions = {"content": [], "ignore": []}

    # Common content selectors to try
    content_selectors = [
        "main",
        "article",
        "[role='main']",
        "#content",
        "#main",
        ".content",
        ".main-content",
        ".entry-content",
        ".post-content",
        ".page-content",
    ]

    # Common elements to ignore
    ignore_patterns = [
        "nav",
        "header",
        "footer",
        "aside",
        ".sidebar",
        ".navigation",
        ".menu",
        ".header",
        ".footer",
        ".ads",
        ".advertisement",
        ".cookie-notice",
        ".popup",
        ".modal",
        "#comments",
        ".comments",
    ]

    # Test content selectors
    for selector in content_selectors:
        found_count = 0
        total_files = len(parsed_files)

        for _, soup in parsed_files:
            if soup.select(selector):
                found_count += 1

        if found_count > 0:
            confidence = found_count / total_files
            suggestions["content"].append((selector, confidence))

    # Sort by confidence
    suggestions["content"].sort(key=lambda x: x[1], reverse=True)

    # Add ignore selectors that exist
    for _, soup in parsed_files:
        for pattern in ignore_patterns:
            if soup.select(pattern):
                if pattern not in suggestions["ignore"]:
                    suggestions["ignore"].append(pattern)

    return suggestions


def handle_config(args: argparse.Namespace) -> None:
    """Handle config command."""
    from .config import Config

    # Create default configuration
    config = Config(source=Path("./html"), destination=Path("./markdown"))

    # Generate config file
    config_dict = config.model_dump()

    if args.format == "yaml":
        import yaml

        content = yaml.dump(config_dict, default_flow_style=False, sort_keys=False)
    elif args.format == "toml":
        import toml

        content = toml.dumps(config_dict)
    elif args.format == "json":
        import json

        content = json.dumps(config_dict, indent=2)
    else:
        console.print(f"❌ Unsupported format: {args.format}", style="red")
        sys.exit(1)

    # Write config file
    args.output.write_text(content, encoding="utf-8")
    console.print(f"✅ Created configuration file: {args.output}", style="green")


def create_simple_parser() -> argparse.ArgumentParser:
    """Create a simple parser for test compatibility."""
    parser = argparse.ArgumentParser(
        prog="mf1-html2md", description="Convert HTML to Markdown"
    )

    parser.add_argument(
        "--version", action="version", version=f"%(prog)s {__version__}"
    )
    parser.add_argument("--source-dir", type=str, help="Source directory or URL")
    parser.add_argument("--destination-dir", type=Path, help="Destination directory")
    parser.add_argument(
        "--outermost-selector", type=str, help="CSS selector for content"
    )
    parser.add_argument("--ignore-selectors", nargs="+", help="CSS selectors to ignore")
    parser.add_argument("--include-patterns", nargs="+", help="Patterns to include")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    return parser


def main() -> None:
    """Main entry point."""
    # Check if running in simple mode (for tests)
    if len(sys.argv) > 1 and sys.argv[1] in ["--help", "--version", "--source-dir"]:
        parser = create_simple_parser()
        args = parser.parse_args()

        if args.source_dir and args.destination_dir:
            # Simple conversion mode
            from .config import ConversionOptions

            options = ConversionOptions(
                source_dir=args.source_dir,
                destination_dir=args.destination_dir,
                outermost_selector=args.outermost_selector,
                ignore_selectors=args.ignore_selectors,
            )
            converter = Html2mdConverter(options)

            # For URL sources, convert them
            if args.source_dir.startswith("http"):
                console.print(f"Converting {args.source_dir}")

                # Handle include patterns if specified
                if args.include_patterns:
                    # Convert specific pages
                    import asyncio

                    urls = [
                        f"{args.source_dir}/{pattern}"
                        for pattern in args.include_patterns
                    ]
                    results = asyncio.run(converter.convert_directory_from_urls(urls))
                    console.print(f"Converted {len(results)} pages")
                else:
                    # Convert single URL
                    output_path = converter.convert_url(args.source_dir)
                    console.print(f"Converted to {output_path}")

                console.print("Conversion completed successfully")
            sys.exit(0)
        sys.exit(0)

    # Regular mode with subcommands
    parser = create_parser()
    args = parser.parse_args()

    # Handle no command
    if not args.command:
        parser.print_help()
        sys.exit(1)

    # Configure console
    if args.quiet:
        console.quiet = True

    # Dispatch to command handlers
    try:
        if args.command == "convert":
            handle_convert(args)
        elif args.command == "analyze":
            handle_analyze(args)
        elif args.command == "config":
            handle_config(args)
        else:
            console.print(f"❌ Unknown command: {args.command}", style="red")
            sys.exit(1)

    except KeyboardInterrupt:
        console.print("\n❌ Interrupted by user", style="yellow")
        sys.exit(1)
    except Exception as e:
        console.print(f"❌ Error: {e}", style="red")
        if args.verbose:
            import traceback

            console.print(traceback.format_exc())
        sys.exit(1)


if __name__ == "__main__":
    main()

======= html2md_tool/core.py | CHECKSUM_SHA256: f13ec4618b5df779ee5cf2ccd87f9620cb58dfd8c6439047297b93aaebf3f17f ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Core HTML parsing and Markdown conversion functionality."""

import re
from typing import Any, Dict, List, Optional, Tuple
from urllib.parse import urljoin, urlparse

from bs4 import BeautifulSoup, NavigableString, Tag
from markdownify import markdownify

from .config.models import ExtractorConfig, ProcessorConfig


class HTMLParser:
    """HTML parsing and extraction."""

    def __init__(self, config: ExtractorConfig):
        """Initialize parser with configuration."""
        self.config = config

    def parse(self, html: str, base_url: Optional[str] = None) -> BeautifulSoup:
        """Parse HTML content.

        Args:
            html: HTML content
            base_url: Base URL for resolving relative links

        Returns:
            BeautifulSoup object
        """
        soup = BeautifulSoup(html, self.config.parser)

        if base_url:
            self._resolve_urls(soup, base_url)

        if self.config.prettify:
            return BeautifulSoup(soup.prettify(), self.config.parser)

        return soup

    def parse_file(self, file_path) -> BeautifulSoup:
        """Parse HTML file.

        Args:
            file_path: Path to HTML file

        Returns:
            BeautifulSoup object
        """
        from pathlib import Path

        file_path = Path(file_path)

        # Read file with proper encoding detection
        encodings = [self.config.encoding, "utf-8", "latin-1", "cp1252"]
        html_content = None

        for encoding in encodings:
            try:
                with open(file_path, "r", encoding=encoding) as f:
                    html_content = f.read()
                break
            except (UnicodeDecodeError, LookupError):
                continue

        if html_content is None:
            # Fallback: read as binary and decode with errors='ignore'
            with open(file_path, "rb") as f:
                html_content = f.read().decode(
                    self.config.encoding, errors=self.config.decode_errors
                )

        # Get base URL from file path for relative URL resolution
        base_url = file_path.as_uri()

        return self.parse(html_content, base_url)

    def _resolve_urls(self, soup: BeautifulSoup, base_url: str) -> None:
        """Resolve relative URLs to absolute.

        Args:
            soup: BeautifulSoup object
            base_url: Base URL
        """
        # Parse base URL to check if it's a file:// URL
        parsed_base = urlparse(base_url)
        is_file_url = parsed_base.scheme == "file"

        # Resolve links
        for tag in soup.find_all(["a", "link"]):
            if href := tag.get("href"):
                # Skip javascript: and mailto: links
                if href.startswith(("javascript:", "mailto:", "#")):
                    continue

                # For file:// base URLs, convert relative links to relative paths
                if is_file_url:
                    if not href.startswith(("http://", "https://", "//")):
                        # Keep relative links as-is for file:// URLs
                        continue

                tag["href"] = urljoin(base_url, href)

        # Resolve images and other resources
        for tag in soup.find_all(["img", "script", "source"]):
            if src := tag.get("src"):
                # For file:// base URLs, keep relative paths
                if is_file_url:
                    if not src.startswith(("http://", "https://", "//")):
                        continue

                tag["src"] = urljoin(base_url, src)

    def extract_metadata(self, soup: BeautifulSoup) -> Dict[str, str]:
        """Extract metadata from HTML.

        Args:
            soup: BeautifulSoup object

        Returns:
            Dictionary of metadata
        """
        metadata = {}

        # Title
        if title := soup.find("title"):
            metadata["title"] = title.get_text(strip=True)

        # Meta tags
        for meta in soup.find_all("meta"):
            if name := meta.get("name"):
                if content := meta.get("content"):
                    metadata[name] = content
            elif prop := meta.get("property"):
                if content := meta.get("content"):
                    metadata[prop] = content

        return metadata


class MarkdownConverter:
    """Convert HTML to Markdown."""

    def __init__(self, config: ProcessorConfig):
        """Initialize converter with configuration."""
        self.config = config

    def convert(
        self, soup: BeautifulSoup, options: Optional[Dict[str, Any]] = None
    ) -> str:
        """Convert BeautifulSoup object to Markdown.

        Args:
            soup: BeautifulSoup object
            options: Additional conversion options

        Returns:
            Markdown content
        """
        # Pre-process code blocks to preserve language info
        for code_block in soup.find_all("code"):
            if code_block.parent and code_block.parent.name == "pre":
                # Get language from class
                classes = code_block.get("class", [])
                for cls in classes:
                    if cls.startswith("language-"):
                        lang = cls.replace("language-", "")
                        # Add language marker
                        code_block.string = f"```{lang}\n{code_block.get_text()}\n```"
                        code_block.parent.unwrap()  # Remove pre tag
                        break

        # Merge options
        opts = {
            "heading_style": "atx",
            "bullets": "-",
            "code_language": "",
            "strip": ["script", "style"],
        }
        if options:
            opts.update(options)

        # Remove script and style tags before conversion
        for tag in soup.find_all(["script", "style", "noscript"]):
            tag.decompose()

        # Convert to markdown
        markdown = markdownify(str(soup), **opts)

        # Post-process
        markdown = self._post_process(markdown)

        # Add frontmatter if enabled
        if self.config.frontmatter and self.config.metadata:
            markdown = self._add_frontmatter(markdown)

        # Add TOC if enabled
        if self.config.toc:
            markdown = self._add_toc(markdown)

        return markdown

    def _post_process(self, markdown: str) -> str:
        """Post-process markdown content.

        Args:
            markdown: Raw markdown

        Returns:
            Processed markdown
        """
        # Remove excessive blank lines
        markdown = re.sub(r"\n{3,}", "\n\n", markdown)

        # Fix spacing around headings
        markdown = re.sub(r"(^|\n)(#{1,6})\s+", r"\1\n\2 ", markdown)

        # Ensure single blank line before headings
        markdown = re.sub(r"([^\n])\n(#{1,6})\s+", r"\1\n\n\2 ", markdown)

        # Fix list formatting
        markdown = re.sub(r"(\n\s*[-*+]\s+)", r"\n\1", markdown)

        # Trim
        return markdown.strip()

    def _add_frontmatter(self, markdown: str) -> str:
        """Add frontmatter to markdown.

        Args:
            markdown: Markdown content

        Returns:
            Markdown with frontmatter
        """
        import yaml

        frontmatter = yaml.dump(self.config.metadata, default_flow_style=False)
        return f"---\n{frontmatter}---\n\n{markdown}"

    def _add_toc(self, markdown: str) -> str:
        """Add table of contents to markdown.

        Args:
            markdown: Markdown content

        Returns:
            Markdown with TOC
        """
        toc_lines = ["## Table of Contents\n"]

        # Extract headings
        heading_pattern = re.compile(r"^(#{1,6})\s+(.+)$", re.MULTILINE)

        for match in heading_pattern.finditer(markdown):
            level = len(match.group(1))
            if level <= self.config.toc_depth:
                title = match.group(2)
                indent = "  " * (level - 1)
                anchor = re.sub(r"[^\w\s-]", "", title.lower())
                anchor = re.sub(r"\s+", "-", anchor)
                toc_lines.append(f"{indent}- [{title}](#{anchor})")

        if len(toc_lines) > 1:
            toc = "\n".join(toc_lines) + "\n\n"
            return toc + markdown

        return markdown

======= html2md_tool/extractors.py | CHECKSUM_SHA256: 3a8e05da2a774bf7af6650e177737bab37edce4aba75cc1d7f3dd7df7d416031 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Custom extractor system for mf1-html2md."""

import importlib.util
import sys
from pathlib import Path
from typing import Optional, Dict, Any
from bs4 import BeautifulSoup
from .utils import get_logger

logger = get_logger(__name__)


class BaseExtractor:
    """Base class for custom extractors."""

    def extract(
        self, soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None
    ) -> BeautifulSoup:
        """Extract content from HTML soup.

        Args:
            soup: BeautifulSoup object
            config: Optional configuration dict

        Returns:
            Processed BeautifulSoup object
        """
        raise NotImplementedError("Subclasses must implement extract()")

    def preprocess(self, html: str, config: Optional[Dict[str, Any]] = None) -> str:
        """Optional preprocessing of raw HTML.

        Args:
            html: Raw HTML string
            config: Optional configuration dict

        Returns:
            Preprocessed HTML string
        """
        return html

    def postprocess(
        self, markdown: str, config: Optional[Dict[str, Any]] = None
    ) -> str:
        """Optional postprocessing of converted markdown.

        Args:
            markdown: Converted markdown string
            config: Optional configuration dict

        Returns:
            Postprocessed markdown string
        """
        return markdown


def load_extractor(extractor_path: Path) -> BaseExtractor:
    """Load a custom extractor from a Python file.

    Args:
        extractor_path: Path to the extractor Python file

    Returns:
        Extractor instance

    Raises:
        ValueError: If extractor cannot be loaded
    """
    if not extractor_path.exists():
        raise ValueError(f"Extractor file not found: {extractor_path}")

    # Load the module dynamically
    spec = importlib.util.spec_from_file_location("custom_extractor", extractor_path)
    if spec is None or spec.loader is None:
        raise ValueError(f"Cannot load extractor from {extractor_path}")

    module = importlib.util.module_from_spec(spec)
    sys.modules["custom_extractor"] = module
    spec.loader.exec_module(module)

    # Look for extractor class or function
    if hasattr(module, "Extractor") and isinstance(module.Extractor, type):
        # Class-based extractor
        return module.Extractor()
    elif hasattr(module, "extract"):
        # Function-based extractor - wrap in a class
        class FunctionExtractor(BaseExtractor):
            def extract(
                self, soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None
            ) -> BeautifulSoup:
                return module.extract(soup, config)

            def preprocess(
                self, html: str, config: Optional[Dict[str, Any]] = None
            ) -> str:
                if hasattr(module, "preprocess"):
                    return module.preprocess(html, config)
                return html

            def postprocess(
                self, markdown: str, config: Optional[Dict[str, Any]] = None
            ) -> str:
                if hasattr(module, "postprocess"):
                    return module.postprocess(markdown, config)
                return markdown

        return FunctionExtractor()
    else:
        raise ValueError(
            f"Extractor must define either an 'Extractor' class or an 'extract' function"
        )


class DefaultExtractor(BaseExtractor):
    """Default extractor with basic cleaning."""

    def extract(
        self, soup: BeautifulSoup, config: Optional[Dict[str, Any]] = None
    ) -> BeautifulSoup:
        """Basic extraction that removes common navigation elements."""
        # Remove script and style tags
        for tag in soup.find_all(["script", "style", "noscript"]):
            tag.decompose()

        # Remove common navigation elements
        nav_selectors = [
            "nav",
            '[role="navigation"]',
            "header",
            '[role="banner"]',
            "footer",
            '[role="contentinfo"]',
            ".sidebar",
            "aside",
            '[role="search"]',
            ".menu",
            ".toolbar",
        ]

        for selector in nav_selectors:
            for elem in soup.select(selector):
                elem.decompose()

        return soup

======= html2md_tool/preprocessors.py | CHECKSUM_SHA256: 313172cf5bca29e65de9cd4eb83f8bf60afd19990fdf5e47a84c8ad92b060c70 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""HTML preprocessors for cleaning up content before conversion."""

from bs4 import BeautifulSoup, Comment
import re
from typing import Optional, List, Dict, Any
from dataclasses import dataclass, field


@dataclass
class PreprocessingConfig:
    """Configuration for HTML preprocessing."""

    # Elements to completely remove
    remove_elements: List[str] = field(default_factory=lambda: ["script", "style"])

    # CSS selectors for elements to remove
    remove_selectors: List[str] = field(default_factory=list)

    # ID selectors for elements to remove
    remove_ids: List[str] = field(default_factory=list)

    # Class names for elements to remove
    remove_classes: List[str] = field(default_factory=list)

    # Comments containing these strings will be removed
    remove_comments_containing: List[str] = field(default_factory=list)

    # Text patterns to remove (regex)
    remove_text_patterns: List[str] = field(default_factory=list)

    # URL patterns to fix (from -> to)
    fix_url_patterns: Dict[str, str] = field(default_factory=dict)

    # Remove empty elements
    remove_empty_elements: bool = True

    # Custom processing function name
    custom_processor: Optional[str] = None


class GenericPreprocessor:
    """Generic HTML preprocessor based on configuration."""

    def __init__(self, config: PreprocessingConfig):
        self.config = config

    def preprocess(self, soup: BeautifulSoup) -> BeautifulSoup:
        """Apply preprocessing based on configuration."""

        # Remove specified elements
        for tag_name in self.config.remove_elements:
            for tag in soup.find_all(tag_name):
                tag.extract()

        # Remove elements by CSS selector
        for selector in self.config.remove_selectors:
            for element in soup.select(selector):
                element.extract()

        # Remove elements by ID
        for element_id in self.config.remove_ids:
            element = soup.find(id=element_id)
            if element:
                element.extract()

        # Remove elements by class
        for class_name in self.config.remove_classes:
            for element in soup.find_all(class_=class_name):
                element.extract()

        # Remove comments containing specific text
        if self.config.remove_comments_containing:
            for comment in soup.find_all(string=lambda text: isinstance(text, Comment)):
                comment_text = str(comment)
                for pattern in self.config.remove_comments_containing:
                    if pattern in comment_text:
                        comment.extract()
                        break

        # Remove text matching patterns
        if self.config.remove_text_patterns:
            for pattern in self.config.remove_text_patterns:
                regex = re.compile(pattern)
                for text in soup.find_all(string=regex):
                    if text.parent and text.parent.name not in ["script", "style"]:
                        text.replace_with("")

        # Fix URLs
        if self.config.fix_url_patterns:
            for tag in soup.find_all(["a", "link", "img", "script"]):
                for attr in ["href", "src"]:
                    if url := tag.get(attr):
                        for (
                            pattern,
                            replacement,
                        ) in self.config.fix_url_patterns.items():
                            if pattern in url:
                                tag[attr] = url.replace(pattern, replacement)

        # Remove empty elements
        if self.config.remove_empty_elements:
            # Multiple passes to catch nested empty elements
            for _ in range(3):
                for tag in soup.find_all():
                    if (
                        tag.name not in ["img", "br", "hr", "input", "meta", "link"]
                        and not tag.get_text(strip=True)
                        and not tag.find_all(
                            ["img", "table", "ul", "ol", "video", "audio", "iframe"]
                        )
                    ):
                        tag.extract()

        return soup


def preprocess_html(html_content: str, config: PreprocessingConfig) -> str:
    """Preprocess HTML content before conversion.

    Args:
        html_content: Raw HTML content
        config: Preprocessing configuration

    Returns:
        Cleaned HTML content
    """
    soup = BeautifulSoup(html_content, "html.parser")

    preprocessor = GenericPreprocessor(config)
    soup = preprocessor.preprocess(soup)

    return str(soup)

======= html2md_tool/utils.py | CHECKSUM_SHA256: ff11fabe1dcb7a651afa00b5d01346445de8ec141cc100df8cf4c2b7003a6cf1 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Utility functions for mf1-html2md."""

import logging
import sys
from pathlib import Path
from typing import Optional

from rich.console import Console
from rich.logging import RichHandler


def get_logger(name: str) -> logging.Logger:
    """Get a logger instance.

    Args:
        name: Logger name

    Returns:
        Logger instance
    """
    return logging.getLogger(name)


def configure_logging(
    verbose: bool = False, quiet: bool = False, log_file: Optional[Path] = None
) -> None:
    """Configure logging for the application.

    Args:
        verbose: Enable verbose logging
        quiet: Suppress all but error messages
        log_file: Optional log file path
    """
    # Determine log level
    if quiet:
        level = logging.ERROR
    elif verbose:
        level = logging.DEBUG
    else:
        level = logging.INFO

    # Create handlers
    handlers = []

    # Console handler with rich formatting
    console_handler = RichHandler(
        console=Console(stderr=True),
        show_path=verbose,
        show_time=verbose,
    )
    console_handler.setLevel(level)
    handlers.append(console_handler)

    # File handler if specified
    if log_file:
        file_handler = logging.FileHandler(log_file)
        file_handler.setLevel(logging.DEBUG)
        file_formatter = logging.Formatter(
            "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
        )
        file_handler.setFormatter(file_formatter)
        handlers.append(file_handler)

    # Configure root logger
    logging.basicConfig(
        level=logging.DEBUG,
        handlers=handlers,
        force=True,
    )

    # Suppress some noisy loggers
    logging.getLogger("urllib3").setLevel(logging.WARNING)
    logging.getLogger("requests").setLevel(logging.WARNING)


def validate_url(url: str) -> bool:
    """Validate URL format.

    Args:
        url: URL to validate

    Returns:
        True if valid, False otherwise
    """
    from urllib.parse import urlparse

    try:
        result = urlparse(url)
        return all([result.scheme, result.netloc])
    except Exception:
        return False


def sanitize_filename(filename: str) -> str:
    """Sanitize filename for filesystem.

    Args:
        filename: Original filename

    Returns:
        Sanitized filename
    """
    import re

    # Remove invalid characters
    filename = re.sub(r'[<>:"/\\|?*]', "_", filename)

    # Remove control characters
    filename = re.sub(r"[\x00-\x1f\x7f]", "", filename)

    # Limit length
    if len(filename) > 200:
        filename = filename[:200]

    # Ensure not empty
    if not filename:
        filename = "untitled"

    return filename


def format_size(size: int) -> str:
    """Format byte size to human readable format.

    Args:
        size: Size in bytes

    Returns:
        Formatted size string
    """
    for unit in ["B", "KB", "MB", "GB", "TB"]:
        if size < 1024.0:
            return f"{size:.1f} {unit}"
        size /= 1024.0
    return f"{size:.1f} PB"


def convert_html(
    html_content: str,
    base_url: Optional[str] = None,
    convert_code_blocks: bool = False,
    heading_offset: int = 0,
) -> str:
    """Convert HTML content to Markdown.

    Args:
        html_content: HTML content as string
        base_url: Optional base URL for resolving relative links
        convert_code_blocks: Whether to convert code blocks to fenced style
        heading_offset: Offset to apply to heading levels

    Returns:
        Markdown content
    """
    from .config.models import ExtractorConfig, ProcessorConfig
    from .core import HTMLParser, MarkdownConverter

    # Create default configs
    extractor_config = ExtractorConfig()
    processor_config = ProcessorConfig()

    # Parse HTML
    parser = HTMLParser(extractor_config)
    soup = parser.parse(html_content, base_url)

    # Apply heading offset if needed
    if heading_offset != 0:
        # Collect all heading tags first to avoid processing them multiple times
        headings = []
        for i in range(1, 7):
            headings.extend([(tag, i) for tag in soup.find_all(f"h{i}")])

        # Now modify them
        for tag, level in headings:
            new_level = max(1, min(6, level + heading_offset))
            tag.name = f"h{new_level}"

    # Convert to Markdown
    converter = MarkdownConverter(processor_config)
    options = {}
    if convert_code_blocks:
        options["code_language"] = "python"
        options["code_block_style"] = "fenced"

    result = converter.convert(soup, options)

    # Handle code blocks if needed
    if convert_code_blocks:
        import re

        # Convert indented code blocks to fenced
        result = re.sub(r"^    (.+)$", r"```\n\1\n```", result, flags=re.MULTILINE)
        # Fix language-specific code blocks
        result = re.sub(
            r'```\n(.*?)class="language-(\w+)"(.*?)\n```',
            r"```\2\n\1\3\n```",
            result,
            flags=re.DOTALL,
        )

    return result


def adjust_internal_links(content, base_path: str = "") -> None:
    """Adjust internal links in HTML content (BeautifulSoup object).

    Args:
        content: BeautifulSoup object or string
        base_path: Base path for links

    Returns:
        None (modifies in place)
    """
    from bs4 import BeautifulSoup

    if isinstance(content, str):
        # If string is passed, work with markdown links
        import re

        # Pattern for markdown links
        link_pattern = re.compile(r"\[([^\]]+)\]\(([^)]+)\)")

        def replace_link(match):
            text = match.group(1)
            url = match.group(2)

            # Skip external links
            if url.startswith(("http://", "https://", "#", "mailto:")):
                return match.group(0)

            # Adjust internal link
            if base_path and not url.startswith("/"):
                url = f"{base_path}/{url}"

            # Convert .html to .md
            if url.endswith(".html"):
                url = url[:-5] + ".md"

            return f"[{text}]({url})"

        return link_pattern.sub(replace_link, content)
    else:
        # Work with BeautifulSoup object - modify in place
        for link in content.find_all("a"):
            href = link.get("href")
            if href:
                # Skip external links
                if not href.startswith(("http://", "https://", "#", "mailto:")):
                    # Adjust internal link
                    if base_path and not href.startswith("/"):
                        href = f"{base_path}/{href}"

                    # Convert .html to .md
                    if href.endswith(".html"):
                        href = href[:-5] + ".md"

                    link["href"] = href


def extract_title_from_html(html_content) -> Optional[str]:
    """Extract title from HTML content.

    Args:
        html_content: HTML content as string or BeautifulSoup object

    Returns:
        Title if found, None otherwise
    """
    from bs4 import BeautifulSoup

    if isinstance(html_content, str):
        soup = BeautifulSoup(html_content, "html.parser")
    else:
        # Already a BeautifulSoup object
        soup = html_content

    # Try <title> tag first
    if title_tag := soup.find("title"):
        return title_tag.get_text(strip=True)

    # Try <h1> tag
    if h1_tag := soup.find("h1"):
        return h1_tag.get_text(strip=True)

    # Try meta title
    if meta_title := soup.find("meta", {"name": "title"}):
        if content := meta_title.get("content"):
            return content

    # Try og:title
    if og_title := soup.find("meta", {"property": "og:title"}):
        if content := og_title.get("content"):
            return content

    return None


def create_progress_bar() -> "Progress":
    """Create a rich progress bar.

    Returns:
        Progress instance
    """
    from rich.progress import (
        BarColumn,
        MofNCompleteColumn,
        Progress,
        SpinnerColumn,
        TextColumn,
        TimeElapsedColumn,
        TimeRemainingColumn,
    )

    return Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        MofNCompleteColumn(),
        TimeElapsedColumn(),
        TimeRemainingColumn(),
        console=Console(),
        transient=True,
    )

======= m1f/__init__.py | CHECKSUM_SHA256: f03e03048a6c9ce17562df6a1a2f0d1e57afdc56e8bbb54c258be07d33672cf7 ======
"""
m1f - Make One File

A modern Python tool to combine multiple text files into a single output file.
"""

try:
    from .._version import __version__, __version_info__
except ImportError:
    # Fallback when running as standalone script
    __version__ = "3.1.0"
    __version_info__ = (3, 1, 0)

__author__ = "Franz und Franz (https://franz.agency)"
__project__ = "https://m1f.dev"

# Import classes and functions for test compatibility
from .config import Config
from .logging import LoggerManager
from .security_scanner import SecurityScanner
from .file_processor import FileProcessor


# Backward compatibility functions for tests
def _scan_files_for_sensitive_info(files_to_process):
    """Legacy function for backward compatibility with tests."""
    import asyncio
    from pathlib import Path

    # Create basic config for scanning
    from .config import (
        FilterConfig,
        OutputConfig,
        EncodingConfig,
        SecurityConfig,
        ArchiveConfig,
        LoggingConfig,
        SecurityCheckMode,
        PresetConfig,
    )

    config = Config(
        source_directory=Path("."),
        input_file=None,
        input_include_files=[],
        output=OutputConfig(output_file=Path("test.txt")),
        filter=FilterConfig(),
        encoding=EncodingConfig(),
        security=SecurityConfig(security_check=SecurityCheckMode.WARN),
        archive=ArchiveConfig(),
        logging=LoggingConfig(),
        preset=PresetConfig(),
    )

    # Create logger manager
    logger_manager = LoggerManager(config.logging, Path("test_output.txt"))

    # Create security scanner
    scanner = SecurityScanner(config, logger_manager)

    # Convert input format if needed
    if files_to_process and isinstance(files_to_process[0], tuple):
        processed_files = [
            (Path(file_path), rel_path) for file_path, rel_path in files_to_process
        ]
    else:
        processed_files = files_to_process

    # Run scan
    return asyncio.run(scanner.scan_files(processed_files))


def _detect_symlink_cycles(path):
    """Legacy function for backward compatibility with tests."""
    from pathlib import Path
    from .config import (
        FilterConfig,
        OutputConfig,
        EncodingConfig,
        SecurityConfig,
        ArchiveConfig,
        LoggingConfig,
        PresetConfig,
    )

    # Create basic config
    config = Config(
        source_directory=Path("."),
        input_file=None,
        input_include_files=[],
        output=OutputConfig(output_file=Path("test.txt")),
        filter=FilterConfig(),
        encoding=EncodingConfig(),
        security=SecurityConfig(),
        archive=ArchiveConfig(),
        logging=LoggingConfig(),
        preset=PresetConfig(),
    )
    logger_manager = LoggerManager(config.logging, Path("test_output.txt"))

    # Create file processor
    processor = FileProcessor(config, logger_manager)

    # Call the actual function and adapt the return format
    path_obj = Path(path) if not isinstance(path, Path) else path
    is_cycle = processor._detect_symlink_cycle(path_obj)

    # Return format expected by tests: (is_cycle, visited_set)
    return is_cycle, processor._symlink_visited


# Import main from the parent m1f.py script for backward compatibility
def main():
    """Main entry point that imports and calls the actual main function."""
    import sys
    import os
    from pathlib import Path

    # Get the path to the main m1f.py script
    current_dir = Path(__file__).parent
    main_script = current_dir.parent / "m1f.py"

    if main_script.exists():
        # Import the main script module
        import importlib.util

        spec = importlib.util.spec_from_file_location("m1f_main", str(main_script))
        if spec and spec.loader:
            m1f_main = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(m1f_main)
            return m1f_main.main()

    # Fallback - run the core async function directly
    try:
        import asyncio
        from .cli import create_parser, parse_args
        from .config import Config
        from .core import FileCombiner
        from .logging import setup_logging

        # Parse command line arguments
        parser = create_parser()
        args = parse_args(parser)

        # Create configuration from arguments
        config = Config.from_args(args)

        # Setup logging
        logger_manager = setup_logging(config)

        # Create and run the file combiner
        async def run():
            combiner = FileCombiner(config, logger_manager)
            await combiner.run()
            await logger_manager.cleanup()

        asyncio.run(run())
        return 0

    except Exception as e:
        print(f"Error running m1f: {e}")
        return 1


__all__ = [
    "__version__",
    "__version_info__",
    "__author__",
    "__project__",
    "_scan_files_for_sensitive_info",
    "_detect_symlink_cycles",
    "main",
]

======= m1f/__main__.py | CHECKSUM_SHA256: 5f806b72a975d3721b7ffc7df61dcc5db8598867a2fa5ee43c71c56b51f8da2c ======
# Copyright 2025 Franz und Franz GmbH
# SPDX-License-Identifier: Apache-2.0

"""Entry point for m1f when run as a module."""

import asyncio
import sys
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from tools.m1f import main


if __name__ == "__main__":
    sys.exit(main())

======= m1f/archive_creator.py | CHECKSUM_SHA256: dd4827239f0b5d047f82e5af7bf8001b54a6de94dbd04912335b5b0dfb06d212 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Archive creator module for creating backup archives of processed files.
"""

from __future__ import annotations

import asyncio
import tarfile
import zipfile
from pathlib import Path
from typing import List, Tuple, Optional

from .config import Config, ArchiveType
from .exceptions import ArchiveError
from .logging import LoggerManager


class ArchiveCreator:
    """Handles creation of backup archives."""

    def __init__(self, config: Config, logger_manager: LoggerManager):
        self.config = config
        self.logger = logger_manager.get_logger(__name__)

    async def create_archive(
        self, output_path: Path, files_to_process: List[Tuple[Path, str]]
    ) -> Optional[Path]:
        """Create an archive of all processed files."""
        if not self.config.archive.create_archive:
            return None

        if not files_to_process:
            self.logger.info("No files to archive")
            return None

        # Determine archive path
        base_name = output_path.stem
        archive_suffix = (
            ".zip" if self.config.archive.archive_type == ArchiveType.ZIP else ".tar.gz"
        )
        archive_path = output_path.with_name(f"{base_name}_backup{archive_suffix}")

        self.logger.info(
            f"Creating {self.config.archive.archive_type.value} archive at: {archive_path}"
        )

        try:
            if self.config.archive.archive_type == ArchiveType.ZIP:
                await self._create_zip_archive(archive_path, files_to_process)
            else:
                await self._create_tar_archive(archive_path, files_to_process)

            self.logger.info(
                f"Successfully created archive with {len(files_to_process)} file(s)"
            )

            return archive_path

        except Exception as e:
            raise ArchiveError(f"Failed to create archive: {e}")

    async def _create_zip_archive(
        self, archive_path: Path, files: List[Tuple[Path, str]]
    ) -> None:
        """Create a ZIP archive."""

        def _write_zip():
            with zipfile.ZipFile(archive_path, "w", zipfile.ZIP_DEFLATED) as zf:
                for file_path, rel_path in files:
                    if self.config.logging.verbose:
                        self.logger.debug(f"Adding to zip: {file_path} as {rel_path}")

                    # Skip if file doesn't exist
                    if not file_path.exists():
                        self.logger.warning(f"File not found, skipping: {file_path}")
                        continue

                    # Add file to archive
                    try:
                        zf.write(file_path, arcname=rel_path)
                    except Exception as e:
                        self.logger.error(f"Error adding {file_path} to zip: {e}")
                        if self.config.encoding.abort_on_error:
                            raise

        # Run in thread pool to avoid blocking
        await asyncio.to_thread(_write_zip)

    async def _create_tar_archive(
        self, archive_path: Path, files: List[Tuple[Path, str]]
    ) -> None:
        """Create a TAR.GZ archive."""

        def _write_tar():
            with tarfile.open(archive_path, "w:gz") as tf:
                for file_path, rel_path in files:
                    if self.config.logging.verbose:
                        self.logger.debug(
                            f"Adding to tar.gz: {file_path} as {rel_path}"
                        )

                    # Skip if file doesn't exist
                    if not file_path.exists():
                        self.logger.warning(f"File not found, skipping: {file_path}")
                        continue

                    # Add file to archive
                    try:
                        tf.add(file_path, arcname=rel_path)
                    except Exception as e:
                        self.logger.error(f"Error adding {file_path} to tar.gz: {e}")
                        if self.config.encoding.abort_on_error:
                            raise

        # Run in thread pool to avoid blocking
        await asyncio.to_thread(_write_tar)

======= m1f/auto_bundle.py | CHECKSUM_SHA256: 3c2fc3e9f6309bf9c85fd3c197b688310da01571aa14fb288f489f2516887fb4 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Auto-bundle functionality for m1f.
Handles YAML configuration loading and bundle creation.
"""

from pathlib import Path
from typing import Dict, List, Optional, Any, Union
import logging
import yaml
import os
import subprocess
import sys

from .config import Config, OutputConfig, FilterConfig, SeparatorStyle, LineEnding
from .constants import ANSI_COLORS

logger = logging.getLogger(__name__)


class AutoBundleConfig:
    """Configuration for auto-bundle functionality."""

    def __init__(self, config_path: Path):
        self.config_path = config_path
        self.config_data: Dict[str, Any] = {}
        self.bundles: Dict[str, Dict[str, Any]] = {}
        self.global_config: Dict[str, Any] = {}

    def load(self) -> bool:
        """Load configuration from YAML file."""
        if not self.config_path.exists():
            return False

        try:
            with open(self.config_path, "r", encoding="utf-8") as f:
                self.config_data = yaml.safe_load(f) or {}

            self.bundles = self.config_data.get("bundles", {})
            self.global_config = self.config_data.get("global", {})
            return True

        except Exception as e:
            logger.error(f"Failed to load config from {self.config_path}: {e}")
            return False

    def get_bundle_names(self) -> List[str]:
        """Get list of available bundle names."""
        return list(self.bundles.keys())

    def get_bundle_config(self, bundle_name: str) -> Optional[Dict[str, Any]]:
        """Get configuration for a specific bundle."""
        return self.bundles.get(bundle_name)


class AutoBundler:
    """Handles auto-bundling functionality."""

    def __init__(self, project_root: Path, verbose: bool = False, quiet: bool = False):
        self.project_root = project_root
        self.verbose = verbose
        self.quiet = quiet
        self.config_file = self._find_config_file(project_root)
        self.m1f_dir = project_root / "m1f"

    def _find_config_file(self, start_path: Path) -> Path:
        """Find .m1f.config.yml by searching from current directory up to root."""
        current = start_path.resolve()
        
        while True:
            config_path = current / ".m1f.config.yml"
            if config_path.exists():
                if self.verbose:
                    self.print_info(f"Found config at: {config_path}")
                return config_path
            
            # Check if we've reached the root
            parent = current.parent
            if parent == current:
                # Return the original path's config file location (even if it doesn't exist)
                return start_path / ".m1f.config.yml"
            current = parent

    def check_config_exists(self) -> bool:
        """Check if auto-bundle config exists."""
        return self.config_file.exists()

    def load_config(self) -> Optional[AutoBundleConfig]:
        """Load auto-bundle configuration."""
        config = AutoBundleConfig(self.config_file)
        if config.load():
            return config
        return None

    def print_info(self, msg: str):
        """Print info message."""
        if not self.quiet:
            if self.verbose:
                print(f"{ANSI_COLORS['BLUE']}[INFO]{ANSI_COLORS['RESET']} {msg}")
            else:
                print(msg)

    def print_success(self, msg: str):
        """Print success message."""
        if not self.quiet:
            print(f"{ANSI_COLORS['GREEN']}[SUCCESS]{ANSI_COLORS['RESET']} {msg}")

    def print_error(self, msg: str):
        """Print error message."""
        print(
            f"{ANSI_COLORS['RED']}[ERROR]{ANSI_COLORS['RESET']} {msg}", file=sys.stderr
        )

    def print_warning(self, msg: str):
        """Print warning message."""
        if not self.quiet:
            print(f"{ANSI_COLORS['YELLOW']}[WARNING]{ANSI_COLORS['RESET']} {msg}")

    def setup_directories(self, config: AutoBundleConfig):
        """Create necessary directories based on config."""
        created_dirs = set()

        for bundle_name, bundle_config in config.bundles.items():
            output = bundle_config.get("output", "")
            if output:
                output_path = self.project_root / output
                output_dir = output_path.parent

                if str(output_dir) not in created_dirs:
                    output_dir.mkdir(parents=True, exist_ok=True)
                    created_dirs.add(str(output_dir))
                    if self.verbose:
                        self.print_info(f"Created directory: {output_dir}")

    def build_m1f_command(
        self,
        bundle_name: str,
        bundle_config: Dict[str, Any],
        global_config: Dict[str, Any],
    ) -> List[str]:
        """Build m1f command from bundle configuration."""
        cmd_parts = [sys.executable, "-m", "tools.m1f"]

        # Handle bundle-level include_files
        if "include_files" in bundle_config:
            for file in bundle_config["include_files"]:
                # Add .py extension if missing
                if not os.path.splitext(file)[1]:
                    test_path = self.project_root / file
                    if not test_path.exists():
                        file += ".py"
                cmd_parts.extend(["-s", str(self.project_root / file)])

        # Process sources
        sources = bundle_config.get("sources", [])
        for source in sources:
            path = source.get("path", ".")

            # Handle include_files at source level
            if "include_files" in source:
                for file in source["include_files"]:
                    # Add .py extension if missing
                    if not os.path.splitext(file)[1]:
                        if path != ".":
                            test_path = self.project_root / path / file
                        else:
                            test_path = self.project_root / file
                        if not test_path.exists():
                            file += ".py"

                    # Create full path
                    if path != ".":
                        full_path = os.path.join(path, file)
                    else:
                        full_path = file
                    cmd_parts.extend(["-s", str(self.project_root / full_path)])
            else:
                # Normal path processing
                cmd_parts.extend(["-s", str(self.project_root / path)])

                # Include extensions
                if "include_extensions" in source:
                    cmd_parts.append("--include-extensions")
                    cmd_parts.extend(source["include_extensions"])

            # Excludes from source
            if "excludes" in source:
                cmd_parts.append("--excludes")
                cmd_parts.extend(source["excludes"])

        # Add global excludes if they exist
        global_excludes = global_config.get("global_excludes", [])
        if global_excludes and "--excludes" not in cmd_parts:
            cmd_parts.append("--excludes")
        for exclude in global_excludes:
            cmd_parts.append(exclude)

        # Output file
        output = bundle_config.get("output", "")
        if output:
            cmd_parts.extend(["-o", str(self.project_root / output)])

        # Separator style
        sep_style = bundle_config.get("separator_style", "Standard")
        cmd_parts.extend(["--separator-style", sep_style])

        # Preset
        if "preset" in bundle_config:
            cmd_parts.extend(
                ["--preset", str(self.project_root / bundle_config["preset"])]
            )

        # Preset group
        if "preset_group" in bundle_config:
            cmd_parts.extend(["--preset-group", bundle_config["preset_group"]])

        # Exclude paths file(s)
        if "exclude_paths_file" in bundle_config:
            exclude_files = bundle_config["exclude_paths_file"]
            if isinstance(exclude_files, str):
                exclude_files = [exclude_files]
            if exclude_files:
                cmd_parts.append("--exclude-paths-file")
                for file in exclude_files:
                    cmd_parts.append(str(self.project_root / file))

        # Include paths file(s)
        if "include_paths_file" in bundle_config:
            include_files = bundle_config["include_paths_file"]
            if isinstance(include_files, str):
                include_files = [include_files]
            if include_files:
                cmd_parts.append("--include-paths-file")
                for file in include_files:
                    cmd_parts.append(str(self.project_root / file))

        # Other options
        if bundle_config.get("filename_mtime_hash"):
            cmd_parts.append("--filename-mtime-hash")

        if bundle_config.get("minimal_output", True):
            cmd_parts.append("--minimal-output")

        # Always add --quiet and -f
        cmd_parts.append("--quiet")
        cmd_parts.append("-f")

        return cmd_parts

    def create_bundle(
        self,
        bundle_name: str,
        bundle_config: Dict[str, Any],
        global_config: Dict[str, Any],
    ) -> bool:
        """Create a single bundle."""
        # Check if enabled
        if not bundle_config.get("enabled", True):
            self.print_info(f"Skipping disabled bundle: {bundle_name}")
            return True

        # Check conditional enabling
        enabled_if = bundle_config.get("enabled_if_exists", "")
        if enabled_if and not (self.project_root / enabled_if).exists():
            self.print_info(
                f"Skipping bundle {bundle_name} (condition not met: {enabled_if})"
            )
            return True

        description = bundle_config.get("description", "")
        self.print_info(f"Creating bundle: {bundle_name} - {description}")

        # Build and execute command
        cmd_parts = self.build_m1f_command(bundle_name, bundle_config, global_config)

        if self.verbose:
            self.print_info(f"Executing: {' '.join(cmd_parts)}")

        try:
            result = subprocess.run(cmd_parts, capture_output=True, text=True)
            if result.returncode != 0:
                self.print_error(f"Command failed: {result.stderr}")
                return False
            if self.verbose and result.stdout:
                print(result.stdout)
            self.print_success(f"Created: {bundle_name}")
            return True
        except Exception as e:
            self.print_error(f"Failed to execute command: {e}")
            return False

    def list_bundles(self, config: AutoBundleConfig):
        """List available bundles."""
        if not config.bundles:
            self.print_warning("No bundles defined in configuration")
            return

        # Group bundles by their group
        grouped_bundles = {}
        ungrouped_bundles = {}
        
        for bundle_name, bundle_config in config.bundles.items():
            group = bundle_config.get("group", None)
            if group:
                if group not in grouped_bundles:
                    grouped_bundles[group] = {}
                grouped_bundles[group][bundle_name] = bundle_config
            else:
                ungrouped_bundles[bundle_name] = bundle_config

        print("\nAvailable bundles:")
        print("-" * 60)
        
        # Show grouped bundles first
        for group_name in sorted(grouped_bundles.keys()):
            print(f"\nGroup: {group_name}")
            print("=" * 40)
            for bundle_name, bundle_config in grouped_bundles[group_name].items():
                self._print_bundle_info(bundle_name, bundle_config)
        
        # Show ungrouped bundles
        if ungrouped_bundles:
            if grouped_bundles:
                print("\nUngrouped bundles:")
                print("=" * 40)
            for bundle_name, bundle_config in ungrouped_bundles.items():
                self._print_bundle_info(bundle_name, bundle_config)

        print("-" * 60)
        
        # Show available groups
        if grouped_bundles:
            print("\nAvailable groups:")
            for group in sorted(grouped_bundles.keys()):
                count = len(grouped_bundles[group])
                print(f"  - {group} ({count} bundles)")
    
    def _print_bundle_info(self, bundle_name: str, bundle_config: Dict[str, Any]):
        """Print information about a single bundle."""
        enabled = bundle_config.get("enabled", True)
        description = bundle_config.get("description", "No description")
        output = bundle_config.get("output", "No output specified")

        status = "enabled" if enabled else "disabled"
        print(f"\n  {bundle_name} ({status})")
        print(f"    Description: {description}")
        print(f"    Output: {output}")

        # Show conditional enabling
        if "enabled_if_exists" in bundle_config:
            print(f"    Enabled if exists: {bundle_config['enabled_if_exists']}")

    def run(self, bundle_name: Optional[str] = None, list_bundles: bool = False, bundle_group: Optional[str] = None):
        """Run auto-bundle functionality."""
        # Check if config exists
        if not self.check_config_exists():
            self.print_error("No .m1f.config.yml configuration found!")
            self.print_info(
                "Searched from current directory up to root. No config file was found."
            )
            self.print_info(
                "Create a .m1f.config.yml file in your project root to use auto-bundle functionality."
            )
            self.print_info(
                "See documentation: docs/01_m1f/06_auto_bundle_guide.md"
            )
            return False

        # Load config
        config = self.load_config()
        if not config:
            self.print_error("Failed to load auto-bundle configuration")
            return False

        # List bundles if requested
        if list_bundles:
            self.list_bundles(config)
            return True

        # Setup directories
        self.setup_directories(config)

        # Filter bundles by group if specified
        bundles_to_create = {}
        
        if bundle_group:
            # Filter bundles by group
            for name, bundle_config in config.bundles.items():
                if bundle_config.get("group") == bundle_group:
                    bundles_to_create[name] = bundle_config
                    
            if not bundles_to_create:
                self.print_error(f"No bundles found in group '{bundle_group}'")
                available_groups = set()
                for bundle_config in config.bundles.values():
                    if "group" in bundle_config:
                        available_groups.add(bundle_config["group"])
                if available_groups:
                    self.print_info(f"Available groups: {', '.join(sorted(available_groups))}")
                else:
                    self.print_info("No bundle groups defined in configuration")
                return False
        elif bundle_name:
            # Create specific bundle
            bundle_config = config.get_bundle_config(bundle_name)
            if not bundle_config:
                self.print_error(f"Bundle '{bundle_name}' not found in configuration")
                self.print_info(
                    f"Available bundles: {', '.join(config.get_bundle_names())}"
                )
                return False
            bundles_to_create[bundle_name] = bundle_config
        else:
            # Create all bundles
            bundles_to_create = config.bundles

        # Create the selected bundles
        success = True
        for name, bundle_config in bundles_to_create.items():
            if not self.create_bundle(name, bundle_config, config.global_config):
                success = False
        return success

======= m1f/cli.py | CHECKSUM_SHA256: 338b520fc83de9676f732d9735627fbeea5b9202944357a687db1b0e87e022b3 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Command-line interface for m1f.
"""

import argparse
import sys
from typing import Optional, NoReturn

from . import __version__

# Try to import colorama for colored help
try:
    from colorama import Fore, Style, init

    init(autoreset=True)
    COLORAMA_AVAILABLE = True
except ImportError:
    COLORAMA_AVAILABLE = False


class ColoredHelpFormatter(argparse.RawDescriptionHelpFormatter):
    """Custom help formatter with colors if available."""

    def _format_action_invocation(self, action: argparse.Action) -> str:
        """Format action with colors."""
        parts = super()._format_action_invocation(action)

        if COLORAMA_AVAILABLE:
            # Color the option names
            parts = parts.replace("-", f"{Fore.CYAN}-")
            parts = f"{parts}{Style.RESET_ALL}"

        return parts

    def _format_usage(self, usage: str, actions, groups, prefix: Optional[str]) -> str:
        """Format usage line with colors."""
        result = super()._format_usage(usage, actions, groups, prefix)

        if COLORAMA_AVAILABLE and result:
            # Highlight the program name
            prog_name = self._prog
            colored_prog = f"{Fore.GREEN}{prog_name}{Style.RESET_ALL}"
            result = result.replace(prog_name, colored_prog, 1)

        return result


class CustomArgumentParser(argparse.ArgumentParser):
    """Custom argument parser with better error messages."""

    def error(self, message: str) -> NoReturn:
        """Display error message with colors if available."""
        error_msg = f"ERROR: {message}"

        if COLORAMA_AVAILABLE:
            error_msg = f"{Fore.RED}ERROR: {message}{Style.RESET_ALL}"

        self.print_usage(sys.stderr)
        print(f"\n{error_msg}", file=sys.stderr)
        print(f"\nFor detailed help, use: {self.prog} --help", file=sys.stderr)
        self.exit(2)


def create_parser() -> CustomArgumentParser:
    """Create and configure the argument parser."""

    description = """m1f - Make One File
====================

Combines the content of multiple text files into a single output file with metadata.
Optionally creates a backup archive (zip or tar.gz) of the processed files.

Perfect for:
• Providing context to Large Language Models (LLMs)
• Creating bundled documentation
• Making machine-parseable bundles for later splitting
• Creating backups of processed files"""

    epilog = """Examples:
  %(prog)s --source-directory ./src --output-file combined.txt
  %(prog)s -s /path/to/project -o bundle.md -t --separator-style Markdown
  %(prog)s -i file_list.txt -o output.txt --create-archive --archive-type tar.gz
  %(prog)s -s ./docs -o docs.txt --include-extensions .md .rst .txt
  %(prog)s -s ./project -o all.txt --no-default-excludes --include-dot-paths
  %(prog)s -s ./src -o code.txt --security-check warn --quiet
  %(prog)s -s ./files -o small-files.txt --max-file-size 50KB
  %(prog)s auto-bundle                         # Create all bundles from .m1f.config.yml
  %(prog)s auto-bundle docs                    # Create only the 'docs' bundle
  %(prog)s auto-bundle --list                  # List available bundles"""

    parser = CustomArgumentParser(
        prog="m1f",
        description=description,
        epilog=epilog,
        formatter_class=ColoredHelpFormatter,
        add_help=True,
    )

    # Add version argument
    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {__version__}",
        help="Show program version and exit",
    )

    # Input/Output group
    io_group = parser.add_argument_group("Input/Output Options")

    io_group.add_argument(
        "-s",
        "--source-directory",
        type=str,
        metavar="DIR",
        help="Path to the directory containing files to combine",
    )

    io_group.add_argument(
        "-i",
        "--input-file",
        type=str,
        metavar="FILE",
        help="Path to a text file containing a list of files/directories to process",
    )

    io_group.add_argument(
        "-o",
        "--output-file",
        type=str,
        required=False,  # Made optional to allow preset override
        metavar="FILE",
        help="Path where the combined output file will be created (can be set via preset)",
    )

    io_group.add_argument(
        "--input-include-files",
        type=str,
        nargs="*",
        metavar="FILE",
        help="Files to include at the beginning of the output (first file is treated as intro)",
    )

    # Output formatting group
    format_group = parser.add_argument_group("Output Formatting")

    format_group.add_argument(
        "--separator-style",
        choices=["Standard", "Detailed", "Markdown", "MachineReadable", "None"],
        default="Detailed",
        help="Format of the separator between files (default: Detailed)",
    )

    format_group.add_argument(
        "--line-ending",
        choices=["lf", "crlf"],
        default="lf",
        help="Line ending style for generated content (default: lf)",
    )

    format_group.add_argument(
        "-t",
        "--add-timestamp",
        action="store_true",
        help="Add timestamp to output filename",
    )

    format_group.add_argument(
        "--filename-mtime-hash",
        action="store_true",
        help="Add hash of file modification times to output filename",
    )

    # File filtering group
    filter_group = parser.add_argument_group("File Filtering")

    filter_group.add_argument(
        "--excludes",
        type=str,
        nargs="*",
        default=[],
        metavar="PATTERN",
        help="Paths, directories, or patterns to exclude",
    )

    filter_group.add_argument(
        "--exclude-paths-file",
        type=str,
        nargs="+",
        metavar="FILE",
        help="File(s) containing paths to exclude (supports gitignore format, multiple files merged)",
    )

    filter_group.add_argument(
        "--include-paths-file",
        type=str,
        nargs="+",
        metavar="FILE",
        help="File(s) containing paths to include (supports gitignore format, multiple files merged)",
    )

    filter_group.add_argument(
        "--include-extensions",
        type=str,
        nargs="*",
        metavar="EXT",
        help="Only include files with these extensions",
    )

    filter_group.add_argument(
        "--exclude-extensions",
        type=str,
        nargs="*",
        metavar="EXT",
        help="Exclude files with these extensions",
    )

    filter_group.add_argument(
        "--include-dot-paths",
        action="store_true",
        help="Include files and directories starting with a dot",
    )

    filter_group.add_argument(
        "--include-binary-files",
        action="store_true",
        help="Attempt to include binary files (use with caution)",
    )

    filter_group.add_argument(
        "--include-symlinks",
        action="store_true",
        help="Follow symbolic links (careful of cycles!)",
    )

    filter_group.add_argument(
        "--max-file-size",
        type=str,
        metavar="SIZE",
        help="Skip files larger than specified size (e.g. 10KB, 1MB, 5.5GB)",
    )

    filter_group.add_argument(
        "--no-default-excludes",
        action="store_true",
        help="Disable default exclusions (node_modules, .git, etc.)",
    )

    filter_group.add_argument(
        "--remove-scraped-metadata",
        action="store_true",
        help="Remove scraped metadata (URL, timestamp) from HTML2MD files during processing",
    )

    # Encoding group
    encoding_group = parser.add_argument_group("Character Encoding")

    encoding_group.add_argument(
        "--convert-to-charset",
        type=str,
        choices=[
            "utf-8",
            "utf-16",
            "utf-16-le",
            "utf-16-be",
            "ascii",
            "latin-1",
            "cp1252",
        ],
        help="Convert all files to specified encoding",
    )

    encoding_group.add_argument(
        "--abort-on-encoding-error",
        action="store_true",
        help="Abort if encoding conversion fails",
    )

    # Security group
    security_group = parser.add_argument_group("Security Options")

    security_group.add_argument(
        "--security-check",
        choices=["abort", "skip", "warn"],
        help="Check for sensitive information in files",
    )

    # Archive group
    archive_group = parser.add_argument_group("Archive Options")

    archive_group.add_argument(
        "--create-archive",
        action="store_true",
        help="Create backup archive of processed files",
    )

    archive_group.add_argument(
        "--archive-type",
        choices=["zip", "tar.gz"],
        default="zip",
        help="Type of archive to create (default: zip)",
    )

    # Output control group
    control_group = parser.add_argument_group("Output Control")

    control_group.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="Force overwrite of existing output file",
    )

    control_group.add_argument(
        "--minimal-output",
        action="store_true",
        help="Only create the combined file (no auxiliary files)",
    )

    control_group.add_argument(
        "--skip-output-file",
        action="store_true",
        help="Skip creating the main output file",
    )

    control_group.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose output"
    )

    control_group.add_argument(
        "-q", "--quiet", action="store_true", help="Suppress all console output"
    )

    # Preset configuration group
    preset_group = parser.add_argument_group("Preset Configuration")

    preset_group.add_argument(
        "--preset",
        type=str,
        nargs="+",
        dest="preset_files",
        metavar="FILE",
        help="Preset configuration file(s) for file-specific processing",
    )

    preset_group.add_argument(
        "--preset-group",
        type=str,
        metavar="GROUP",
        help="Specific preset group to use from the configuration",
    )

    preset_group.add_argument(
        "--disable-presets",
        action="store_true",
        help="Disable all preset processing",
    )

    return parser


def parse_args(
    parser: argparse.ArgumentParser, args: Optional[list[str]] = None
) -> argparse.Namespace:
    """Parse command-line arguments."""
    parsed_args = parser.parse_args(args)

    # Skip validation if presets are being used - they may provide required values
    if not parsed_args.preset_files or parsed_args.disable_presets:
        # Validate that at least one input source is provided
        if not parsed_args.source_directory and not parsed_args.input_file:
            parser.error(
                "At least one of -s/--source-directory or -i/--input-file is required"
            )

    # Validate conflicting options
    if parsed_args.quiet and parsed_args.verbose:
        parser.error("Cannot use --quiet and --verbose together")

    return parsed_args

======= m1f/config.py | CHECKSUM_SHA256: 6ea72c4cb3e3fa1ef016b8f9cb9f5c46d5af6e473da42c6cded0cc6a4b95160b ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Configuration classes for m1f using dataclasses.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum, auto
from pathlib import Path
from typing import Optional, Set, List, Union
import argparse

from .utils import parse_file_size


class SeparatorStyle(Enum):
    """Enumeration for separator styles."""

    STANDARD = "Standard"
    DETAILED = "Detailed"
    MARKDOWN = "Markdown"
    MACHINE_READABLE = "MachineReadable"
    NONE = "None"


class LineEnding(Enum):
    """Enumeration for line endings."""

    LF = "\n"
    CRLF = "\r\n"

    @classmethod
    def from_str(cls, value: str) -> LineEnding:
        """Create from string value."""
        if value.lower() == "lf":
            return cls.LF
        elif value.lower() == "crlf":
            return cls.CRLF
        else:
            raise ValueError(f"Invalid line ending: {value}")


class ArchiveType(Enum):
    """Enumeration for archive types."""

    ZIP = "zip"
    TAR_GZ = "tar.gz"


class SecurityCheckMode(Enum):
    """Security check modes."""

    ABORT = "abort"
    SKIP = "skip"
    WARN = "warn"


@dataclass(frozen=True)
class EncodingConfig:
    """Configuration for encoding settings."""

    target_charset: Optional[str] = None
    abort_on_error: bool = False


@dataclass(frozen=True)
class OutputConfig:
    """Configuration for output settings."""

    output_file: Path
    add_timestamp: bool = False
    filename_mtime_hash: bool = False
    force_overwrite: bool = False
    minimal_output: bool = False
    skip_output_file: bool = False
    separator_style: SeparatorStyle = SeparatorStyle.DETAILED
    line_ending: LineEnding = LineEnding.LF


@dataclass(frozen=True)
class FilterConfig:
    """Configuration for file filtering."""

    exclude_paths: Set[str] = field(default_factory=set)
    exclude_patterns: List[str] = field(default_factory=list)
    exclude_paths_file: Optional[Union[str, List[str]]] = None
    include_paths_file: Optional[Union[str, List[str]]] = None
    include_extensions: Set[str] = field(default_factory=set)
    exclude_extensions: Set[str] = field(default_factory=set)
    include_dot_paths: bool = False
    include_binary_files: bool = False
    include_symlinks: bool = False
    no_default_excludes: bool = False
    max_file_size: Optional[int] = None  # Size in bytes
    remove_scraped_metadata: bool = False


@dataclass(frozen=True)
class SecurityConfig:
    """Configuration for security settings."""

    security_check: Optional[SecurityCheckMode] = None


@dataclass(frozen=True)
class ArchiveConfig:
    """Configuration for archive settings."""

    create_archive: bool = False
    archive_type: ArchiveType = ArchiveType.ZIP


@dataclass(frozen=True)
class LoggingConfig:
    """Configuration for logging settings."""

    verbose: bool = False
    quiet: bool = False


@dataclass(frozen=True)
class PresetConfig:
    """Configuration for preset settings."""

    preset_files: List[Path] = field(default_factory=list)
    preset_group: Optional[str] = None
    disable_presets: bool = False


@dataclass(frozen=True)
class Config:
    """Main configuration class that combines all settings."""

    source_directory: Optional[Path]
    input_file: Optional[Path]
    input_include_files: List[Path]
    output: OutputConfig
    filter: FilterConfig
    encoding: EncodingConfig
    security: SecurityConfig
    archive: ArchiveConfig
    logging: LoggingConfig
    preset: PresetConfig

    @classmethod
    def from_args(cls, args: argparse.Namespace) -> Config:
        """Create configuration from parsed arguments."""
        # First create the basic config from CLI args
        config = cls._create_from_cli_args(args)
        
        # Then apply preset overrides if presets are enabled
        if not config.preset.disable_presets and config.preset.preset_files:
            config = cls._apply_preset_overrides(config, args)
        
        # Validate that we have required inputs after preset application
        if not config.source_directory and not config.input_file:
            raise ValueError(
                "At least one of source_directory or input_file must be provided "
                "(either via CLI arguments or preset configuration)"
            )
        
        # Validate output_file - it should not be the default dummy value
        if config.output.output_file == Path("output.txt"):
            raise ValueError(
                "output_file must be provided (either via -o CLI argument or preset configuration)"
            )
        
        return config
    
    @classmethod
    def _create_from_cli_args(cls, args: argparse.Namespace) -> Config:
        """Create initial configuration from CLI arguments."""
        # Process source directory
        source_dir = (
            Path(args.source_directory).resolve() if args.source_directory else None
        )

        # Process input file
        input_file = Path(args.input_file).resolve() if args.input_file else None

        # Process include files
        include_files = []
        if hasattr(args, "input_include_files") and args.input_include_files:
            include_files = [Path(f).resolve() for f in args.input_include_files]

        # Create output configuration
        output_file_path = Path(args.output_file).resolve() if args.output_file else None
        output_config = OutputConfig(
            output_file=output_file_path or Path("output.txt"),  # Default if not provided
            add_timestamp=args.add_timestamp,
            filename_mtime_hash=getattr(args, "filename_mtime_hash", False),
            force_overwrite=args.force,
            minimal_output=getattr(args, "minimal_output", False),
            skip_output_file=getattr(args, "skip_output_file", False),
            separator_style=SeparatorStyle(args.separator_style),
            line_ending=LineEnding.from_str(args.line_ending),
        )

        # Parse max file size if provided
        max_file_size_bytes = None
        if hasattr(args, "max_file_size") and args.max_file_size:
            try:
                max_file_size_bytes = parse_file_size(args.max_file_size)
            except ValueError as e:
                raise ValueError(f"Invalid --max-file-size value: {e}")

        # Create filter configuration
        filter_config = FilterConfig(
            exclude_paths=set(getattr(args, "exclude_paths", [])),
            exclude_patterns=getattr(args, "excludes", []),
            exclude_paths_file=getattr(args, "exclude_paths_file", None),
            include_paths_file=getattr(args, "include_paths_file", None),
            include_extensions=set(
                normalize_extensions(getattr(args, "include_extensions", []))
            ),
            exclude_extensions=set(
                normalize_extensions(getattr(args, "exclude_extensions", []))
            ),
            include_dot_paths=getattr(args, "include_dot_paths", False),
            include_binary_files=getattr(args, "include_binary_files", False),
            include_symlinks=getattr(args, "include_symlinks", False),
            no_default_excludes=getattr(args, "no_default_excludes", False),
            max_file_size=max_file_size_bytes,
            remove_scraped_metadata=getattr(args, "remove_scraped_metadata", False),
        )

        # Create encoding configuration
        encoding_config = EncodingConfig(
            target_charset=getattr(args, "convert_to_charset", None),
            abort_on_error=getattr(args, "abort_on_encoding_error", False),
        )

        # Create security configuration
        security_mode = None
        if hasattr(args, "security_check") and args.security_check:
            security_mode = SecurityCheckMode(args.security_check)

        security_config = SecurityConfig(security_check=security_mode)

        # Create archive configuration
        archive_config = ArchiveConfig(
            create_archive=getattr(args, "create_archive", False),
            archive_type=ArchiveType(getattr(args, "archive_type", "zip")),
        )

        # Create logging configuration
        logging_config = LoggingConfig(
            verbose=args.verbose, quiet=getattr(args, "quiet", False)
        )

        # Create preset configuration
        preset_files = []
        if hasattr(args, "preset_files") and args.preset_files:
            preset_files = [Path(f).resolve() for f in args.preset_files]

        preset_config = PresetConfig(
            preset_files=preset_files,
            preset_group=getattr(args, "preset_group", None),
            disable_presets=getattr(args, "disable_presets", False),
        )

        return cls(
            source_directory=source_dir,
            input_file=input_file,
            input_include_files=include_files,
            output=output_config,
            filter=filter_config,
            encoding=encoding_config,
            security=security_config,
            archive=archive_config,
            logging=logging_config,
            preset=preset_config,
        )
    
    @classmethod
    def _apply_preset_overrides(cls, config: Config, args: argparse.Namespace) -> Config:
        """Apply preset overrides to configuration."""
        from .presets import load_presets
        
        # Load presets
        preset_manager = load_presets(config.preset.preset_files)
        global_settings = preset_manager.get_global_settings()
        
        if not global_settings:
            return config
        
        # Apply overrides - CLI arguments take precedence over presets
        
        # Input/Output overrides
        source_dir = config.source_directory
        input_file = config.input_file
        output_file = config.output.output_file
        input_include_files = config.input_include_files
        
        # Only override if not provided via CLI
        if not args.source_directory and global_settings.source_directory:
            source_dir = Path(global_settings.source_directory).resolve()
        
        if not args.input_file and global_settings.input_file:
            input_file = Path(global_settings.input_file).resolve()
        
        # Only override output_file if not provided via CLI
        if not args.output_file and global_settings.output_file:
            output_file = Path(global_settings.output_file).resolve()
        
        if not args.input_include_files and global_settings.input_include_files:
            if isinstance(global_settings.input_include_files, str):
                input_include_files = [Path(global_settings.input_include_files).resolve()]
            else:
                input_include_files = [Path(f).resolve() for f in global_settings.input_include_files]
        
        # Create new OutputConfig with overrides
        output_config = OutputConfig(
            output_file=output_file,
            add_timestamp=args.add_timestamp if args.add_timestamp else (global_settings.add_timestamp or False),
            filename_mtime_hash=getattr(args, "filename_mtime_hash", False) or (global_settings.filename_mtime_hash or False),
            force_overwrite=args.force if args.force else (global_settings.force or False),
            minimal_output=getattr(args, "minimal_output", False) or (global_settings.minimal_output or False),
            skip_output_file=getattr(args, "skip_output_file", False) or (global_settings.skip_output_file or False),
            separator_style=SeparatorStyle(args.separator_style) if args.separator_style != "Detailed" else (
                SeparatorStyle(global_settings.separator_style) if global_settings.separator_style else SeparatorStyle.DETAILED
            ),
            line_ending=LineEnding.from_str(args.line_ending) if args.line_ending != "lf" else (
                LineEnding.from_str(global_settings.line_ending) if global_settings.line_ending else LineEnding.LF
            ),
        )
        
        # Create new ArchiveConfig with overrides
        archive_config = ArchiveConfig(
            create_archive=getattr(args, "create_archive", False) or (global_settings.create_archive or False),
            archive_type=ArchiveType(getattr(args, "archive_type", "zip")) if getattr(args, "archive_type", "zip") != "zip" else (
                ArchiveType(global_settings.archive_type) if global_settings.archive_type else ArchiveType.ZIP
            ),
        )
        
        # Create new LoggingConfig with overrides
        logging_config = LoggingConfig(
            verbose=args.verbose if args.verbose else (global_settings.verbose or False),
            quiet=getattr(args, "quiet", False) or (global_settings.quiet or False),
        )
        
        # Return new config with overrides applied
        return cls(
            source_directory=source_dir,
            input_file=input_file,
            input_include_files=input_include_files,
            output=output_config,
            filter=config.filter,  # Filter settings are handled separately in FileProcessor
            encoding=config.encoding,  # Encoding settings are handled separately
            security=config.security,  # Security settings are handled separately
            archive=archive_config,
            logging=logging_config,
            preset=config.preset,
        )


def normalize_extensions(extensions: List[str]) -> List[str]:
    """Normalize file extensions to ensure they start with a dot."""
    if not extensions:
        return []

    normalized = []
    for ext in extensions:
        if ext.startswith("."):
            normalized.append(ext.lower())
        else:
            normalized.append(f".{ext.lower()}")

    return normalized

======= m1f/config_loader.py | CHECKSUM_SHA256: c1247d6c59d8f2f8f67001c2cce69240f0897f6361b4ea945252b8ab94bb5fd5 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Configuration loader for m1f presets.
Handles loading presets from user home directory and project directories.
"""

from pathlib import Path
from typing import List, Optional
import os
import logging

logger = logging.getLogger(__name__)


class PresetConfigLoader:
    """Loads preset configurations from various locations."""

    @staticmethod
    def get_user_preset_dir() -> Path:
        """Get the user's m1f preset directory."""
        # Support XDG_CONFIG_HOME on Linux/Unix
        if os.name != "nt" and "XDG_CONFIG_HOME" in os.environ:
            config_home = Path(os.environ["XDG_CONFIG_HOME"])
        else:
            config_home = Path.home()

        return config_home / ".m1f"

    @staticmethod
    def get_global_preset_file() -> Path:
        """Get the global preset file path."""
        return PresetConfigLoader.get_user_preset_dir() / "global-presets.yml"

    @staticmethod
    def get_user_presets_dir() -> Path:
        """Get the directory for user preset files."""
        return PresetConfigLoader.get_user_preset_dir() / "presets"

    @classmethod
    def load_all_presets(
        cls,
        project_presets: Optional[List[Path]] = None,
        include_global: bool = True,
        include_user: bool = True,
    ) -> List[Path]:
        """
        Load all preset files in order of precedence.

        Order (highest to lowest priority):
        1. Project-specific presets (from command line)
        2. User presets (~/.m1f/presets/)
        3. Global presets (~/.m1f/global-presets.yml)

        Args:
            project_presets: List of project-specific preset files
            include_global: Whether to include global presets
            include_user: Whether to include user presets

        Returns:
            List of preset file paths to load
        """
        preset_files = []

        # 1. Global presets (lowest priority)
        if include_global:
            global_preset = cls.get_global_preset_file()
            if global_preset.exists():
                preset_files.append(global_preset)
                logger.debug(f"Found global preset file: {global_preset}")

        # 2. User presets
        if include_user:
            user_dir = cls.get_user_presets_dir()
            if user_dir.exists() and user_dir.is_dir():
                # Load all .yml and .yaml files
                for pattern in ["*.yml", "*.yaml"]:
                    for preset_file in sorted(user_dir.glob(pattern)):
                        preset_files.append(preset_file)
                        logger.debug(f"Found user preset file: {preset_file}")

        # 3. Project presets (highest priority)
        if project_presets:
            for preset_file in project_presets:
                if preset_file.exists():
                    preset_files.append(preset_file)
                    logger.debug(f"Found project preset file: {preset_file}")
                else:
                    logger.warning(f"Project preset file not found: {preset_file}")

        return preset_files

    @classmethod
    def init_user_config(cls) -> None:
        """Initialize user configuration directory with example files."""
        user_dir = cls.get_user_preset_dir()
        presets_dir = cls.get_user_presets_dir()

        # Create directories
        user_dir.mkdir(exist_ok=True)
        presets_dir.mkdir(exist_ok=True)

        # Create example global preset if it doesn't exist
        global_preset = cls.get_global_preset_file()
        if not global_preset.exists():
            example_content = """# Global m1f preset configuration
# These settings apply to all m1f operations unless overridden

# Global defaults for all projects
global_defaults:
  description: "Global defaults for all file types"
  priority: 1  # Lowest priority
  
  global_settings:
    # Default encoding and formatting
    encoding: "utf-8"
    separator_style: "Detailed"
    line_ending: "lf"
    
    # Global exclude patterns
    exclude_patterns:
      - "*.pyc"
      - "__pycache__"
      - ".git"
      - ".svn"
      - "node_modules"
    
    # File filtering options
    include_dot_paths: false      # Include hidden files by default
    include_binary_files: false   # Skip binary files
    max_file_size: "50MB"        # Skip very large files
    
    # Processing options
    remove_scraped_metadata: false  # Keep metadata by default
    abort_on_encoding_error: false  # Be resilient to encoding issues
    
    # Extension-specific defaults
    extensions:
      # HTML files - strip common tags by default
      .html:
        actions:
          - strip_tags
          - compress_whitespace
        strip_tags:
          - "script"
          - "style"
          - "meta"
          - "link"
      
      # Markdown - clean up formatting
      .md:
        actions:
          - remove_empty_lines
      
      # CSS files - minify
      .css:
        actions:
          - minify
          - strip_comments
      
      # JavaScript - remove comments
      .js:
        actions:
          - strip_comments
          - compress_whitespace
      
      # JSON - compress by default
      .json:
        actions:
          - compress_whitespace
      
      # Log files - truncate
      .log:
        actions:
          - custom
        custom_processor: "truncate"
        processor_args:
          max_chars: 5000

# Personal project defaults
personal_projects:
  description: "Settings for personal projects"
  priority: 5
  enabled: false  # Enable this in your projects
  
  global_settings:
    # Override for personal projects
    separator_style: "Markdown"
    
    # Additional excludes for personal projects
    exclude_patterns:
      - "*.bak"
      - "*.tmp"
      - "*.swp"
  
  presets:
    # Keep test files minimal
    tests:
      patterns:
        - "**/test_*.py"
        - "**/*_test.py"
      max_lines: 100
    
    # Documentation files
    docs:
      extensions: [".md", ".rst", ".txt"]
      separator_style: "Markdown"
      actions:
        - remove_empty_lines
"""
            global_preset.write_text(example_content)
            logger.info(f"Created example global preset: {global_preset}")

        # Create README
        readme = user_dir / "README.md"
        if not readme.exists():
            readme_content = """# m1f User Configuration

This directory contains your personal m1f preset configurations.

## Structure

- `global-presets.yml` - Global defaults for all m1f operations
- `presets/` - Directory for additional preset files

## Usage

1. Global presets are automatically loaded for all m1f operations
2. Add custom presets to the `presets/` directory
3. Override global settings in your project-specific presets

## Preset Priority

1. Project presets (highest) - specified with --preset
2. User presets - files in ~/.m1f/presets/
3. Global presets (lowest) - ~/.m1f/global-presets.yml

## Example

To disable global HTML stripping for a specific project:

```yaml
my_project:
  priority: 100  # Higher than global
  
  globals:
    extensions:
      .html:
        actions: []  # No processing
```
"""
            readme.write_text(readme_content)
            logger.info(f"Created README: {readme}")

======= m1f/constants.py | CHECKSUM_SHA256: b8ccf0300f7ea6dda5ab7d292bed94a224e0edc05f0eacf06c547df5c83a8a10 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Constants used throughout the m1f application.
"""

from typing import Set, List

# Default directories to exclude
DEFAULT_EXCLUDED_DIRS: Set[str] = {
    "vendor",
    "node_modules",
    "build",
    "dist",
    "cache",
    ".git",
    ".svn",
    ".hg",
    "__pycache__",
    ".pytest_cache",
    ".mypy_cache",
    ".tox",
    ".coverage",
    ".eggs",
    "htmlcov",
    ".idea",
    ".vscode",
}

# Default files to exclude
DEFAULT_EXCLUDED_FILES: Set[str] = {
    "LICENSE",
    "package-lock.json",
    "composer.lock",
    "poetry.lock",
    "Pipfile.lock",
    "yarn.lock",
}

# Maximum symlink depth to prevent infinite loops
MAX_SYMLINK_DEPTH: int = 40

# Buffer size for file reading
READ_BUFFER_SIZE: int = 8192

# Boundary marker prefix for machine-readable format
MACHINE_READABLE_BOUNDARY_PREFIX: str = "PYMK1F"

# Token encoding name for tiktoken
TOKEN_ENCODING_NAME: str = "cl100k_base"

# ANSI color codes
ANSI_COLORS = {
    "HEADER": "\033[95m",
    "BLUE": "\033[94m",
    "GREEN": "\033[92m",
    "YELLOW": "\033[93m",
    "RED": "\033[91m",
    "RESET": "\033[0m",
    "BOLD": "\033[1m",
}

======= m1f/core.py | CHECKSUM_SHA256: 388307802e8ea5a081cde8d0e92561b594639284b20787a8602b9cc05c14dc68 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Core functionality for m1f - the main FileCombiner class.
"""

from __future__ import annotations

import asyncio
import hashlib
import time
from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple, Optional, Set
from datetime import datetime

from .config import Config, SeparatorStyle
from .exceptions import (
    FileNotFoundError,
    PermissionError,
    ValidationError,
    SecurityError,
)
from .logging import LoggerManager, get_logger
from .file_processor import FileProcessor
from .output_writer import OutputWriter
from .archive_creator import ArchiveCreator
from .security_scanner import SecurityScanner
from .utils import (
    format_duration,
    sort_files_by_depth_and_name,
    sort_directories_by_depth_and_name,
)


@dataclass
class ProcessingResult:
    """Result of the file processing operation."""

    files_processed: int
    total_files: int
    execution_time: str
    output_file: Optional[Path] = None
    archive_file: Optional[Path] = None
    token_count: Optional[int] = None
    flagged_files: List[str] = None


class FileCombiner:
    """Main class that orchestrates the file combination process."""

    def __init__(self, config: Config, logger_manager: LoggerManager):
        self.config = config
        self.logger_manager = logger_manager
        self.logger = logger_manager.get_logger(__name__)

        # Initialize components
        self.file_processor = FileProcessor(config, logger_manager)
        self.output_writer = OutputWriter(config, logger_manager)
        self.archive_creator = ArchiveCreator(config, logger_manager)
        self.security_scanner = SecurityScanner(config, logger_manager)

        # Share preset manager between components
        if self.file_processor.preset_manager:
            self.security_scanner.preset_manager = self.file_processor.preset_manager

    async def run(self) -> ProcessingResult:
        """Run the file combination process."""
        start_time = time.time()

        try:
            # Validate configuration
            self._validate_config()

            # Prepare output file path
            output_path = await self._prepare_output_path()

            # Update logger with output path
            self.logger_manager.set_output_file(output_path)

            # Log initial information
            self._log_start_info()

            # Gather files to process
            files_to_process = await self.file_processor.gather_files()

            if not files_to_process:
                self.logger.warning("No files found matching the criteria")
                # Create empty output file with note
                if not self.config.output.skip_output_file:
                    await self._create_empty_output(output_path)

                return ProcessingResult(
                    files_processed=0,
                    total_files=0,
                    execution_time=format_duration(time.time() - start_time),
                    output_file=output_path,
                )

            self.logger.info(f"Found {len(files_to_process)} files to process")

            # Sort files by depth and name (README.md first)
            files_to_process = sort_files_by_depth_and_name(files_to_process)
            self.logger.debug("Files sorted by depth and name")

            # Security check if enabled
            flagged_files = []
            if self.config.security.security_check:
                flagged_files = await self.security_scanner.scan_files(files_to_process)
                files_to_process = self._handle_security_results(
                    files_to_process, flagged_files
                )

            # Generate content hash if requested
            if self.config.output.filename_mtime_hash:
                output_path = await self._add_content_hash_to_filename(
                    output_path, files_to_process
                )
                # Update logger with new path
                self.logger_manager.set_output_file(output_path)

            # Write auxiliary files
            await self._write_auxiliary_files(output_path, files_to_process)

            # Write main output file
            files_processed = 0
            if not self.config.output.skip_output_file:
                files_processed = await self.output_writer.write_combined_file(
                    output_path, files_to_process
                )
                self.logger.info(
                    f"Successfully combined {files_processed} files into '{output_path}'"
                )

                # Count tokens if available
                token_count = await self._count_tokens(output_path)
                if token_count:
                    self.logger.info(
                        f"Output file contains approximately {token_count} tokens"
                    )
            else:
                files_processed = len(files_to_process)
                self.logger.info(f"Found {files_processed} files (output file skipped)")

            # Create archive if requested
            archive_path = None
            if self.config.archive.create_archive and files_processed > 0:
                archive_path = await self.archive_creator.create_archive(
                    output_path, files_to_process
                )

            # Final security warning if needed
            if (
                self.config.security.security_check
                and self.config.security.security_check.value == "warn"
                and flagged_files
            ):
                self._log_security_warning(flagged_files)

            # Calculate execution time
            execution_time = format_duration(time.time() - start_time)

            return ProcessingResult(
                files_processed=files_processed,
                total_files=len(files_to_process),
                execution_time=execution_time,
                output_file=(
                    output_path if not self.config.output.skip_output_file else None
                ),
                archive_file=archive_path,
                token_count=(
                    token_count if not self.config.output.skip_output_file else None
                ),
                flagged_files=flagged_files,
            )

        except Exception as e:
            execution_time = format_duration(time.time() - start_time)
            self.logger.error(f"Processing failed after {execution_time}: {e}")
            raise

    def _validate_config(self) -> None:
        """Validate the configuration."""
        if not self.config.source_directory and not self.config.input_file:
            raise ValidationError("No source directory or input file specified")

        if self.config.source_directory and not self.config.source_directory.exists():
            raise FileNotFoundError(
                f"Source directory not found: {self.config.source_directory}"
            )

        if self.config.input_file and not self.config.input_file.exists():
            raise FileNotFoundError(f"Input file not found: {self.config.input_file}")

    async def _prepare_output_path(self) -> Path:
        """Prepare the output file path."""
        output_path = self.config.output.output_file

        # Add timestamp if requested
        if self.config.output.add_timestamp:
            timestamp = datetime.now().strftime("_%Y%m%d_%H%M%S")
            output_path = output_path.with_name(
                f"{output_path.stem}{timestamp}{output_path.suffix}"
            )
            self.logger.debug(f"Output filename with timestamp: {output_path.name}")

        # Handle existing file
        if output_path.exists() and not self.config.output.skip_output_file:
            if self.config.output.force_overwrite:
                self.logger.warning(f"Overwriting existing file: {output_path}")
                try:
                    output_path.unlink()
                except Exception as e:
                    raise PermissionError(f"Cannot remove existing file: {e}")
            else:
                # If quiet mode is enabled, fail immediately
                if self.config.logging.quiet:
                    raise ValidationError(f"Output file exists: {output_path}")

                # Otherwise, ask the user
                # Check if we're in a test environment or input is mocked
                import sys

                if hasattr(sys, "_called_from_test") or (
                    hasattr(__builtins__, "input")
                    and hasattr(getattr(__builtins__, "input", None), "__name__")
                    and "mock"
                    in str(
                        getattr(__builtins__, "input", lambda: None).__name__
                    ).lower()
                ):
                    # In test environment, always proceed as if 'y' was entered
                    response = "y"
                else:
                    # Run input in thread pool to avoid blocking async event loop
                    try:
                        response = await asyncio.to_thread(
                            input,
                            f"Output file '{output_path}' exists. Overwrite? (y/N): ",
                        )
                    except (KeyboardInterrupt, EOFError):
                        # Handle Ctrl+C and EOF gracefully
                        raise ValidationError("Operation cancelled by user")

                if response.lower() != "y":
                    raise ValidationError("Operation cancelled by user")

        # Ensure parent directory exists
        try:
            output_path.parent.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            raise PermissionError(f"Cannot create output directory: {e}")

        return output_path

    def _log_start_info(self) -> None:
        """Log initial information about the processing."""
        if self.config.source_directory:
            self.logger.info(f"Source directory: {self.config.source_directory}")

        if self.config.input_file:
            self.logger.info(f"Input file: {self.config.input_file}")

        self.logger.info(f"Separator style: {self.config.output.separator_style.value}")

        if self.config.encoding.target_charset:
            self.logger.info(f"Target encoding: {self.config.encoding.target_charset}")

        if self.config.filter.no_default_excludes:
            self.logger.info("Default exclusions disabled")

        if self.config.filter.include_symlinks:
            self.logger.info("Following symbolic links")

    def _handle_security_results(
        self, files: List[Tuple[Path, str]], flagged: List[dict]
    ) -> List[Tuple[Path, str]]:
        """Handle security scan results based on configuration."""
        if not flagged:
            return files

        mode = self.config.security.security_check

        if mode and mode.value == "abort":
            message = "Security check failed. Sensitive information detected:\n"
            for finding in flagged:
                message += f"  - File: {finding['path']}, Type: {finding['type']}, Line: {finding['line']}\n"
            raise SecurityError(message)

        elif mode and mode.value == "skip":
            self.logger.warning(f"Skipping {len(flagged)} files due to security check")

            # Get unique paths to skip
            paths_to_skip = {finding["path"] for finding in flagged}

            # Filter out flagged files
            filtered = [(path, rel) for path, rel in files if rel not in paths_to_skip]

            return filtered

        # mode == "warn" - just return files, warning will be shown at the end
        return files

    async def _add_content_hash_to_filename(
        self, output_path: Path, files: List[Tuple[Path, str]]
    ) -> Path:
        """Add content hash to the output filename."""
        # Generate hash from file names and modification times
        hash_input = []

        for file_path, rel_path in files:
            hash_input.append(str(rel_path))
            try:
                import os

                mtime = os.path.getmtime(file_path)
                hash_input.append(str(mtime))
            except Exception:
                hash_input.append(f"ERROR_{rel_path}")

        # Sort for consistency
        hash_input.sort()

        # Create hash
        combined = ";".join(hash_input)
        hash_obj = hashlib.sha256(combined.encode("utf-8"))
        content_hash = hash_obj.hexdigest()[:12]

        # Create new filename
        # If timestamp was already added, we need to extract it and reorder
        if self.config.output.add_timestamp and "_" in output_path.stem:
            # Check if stem ends with timestamp pattern _YYYYMMDD_HHMMSS
            parts = output_path.stem.rsplit("_", 2)
            if len(parts) == 3 and len(parts[1]) == 8 and len(parts[2]) == 6:
                # Reorder to: base_hash_timestamp
                base_name = parts[0]
                timestamp = f"_{parts[1]}_{parts[2]}"
                new_stem = f"{base_name}_{content_hash}{timestamp}"
            else:
                # Fallback if pattern doesn't match
                new_stem = f"{output_path.stem}_{content_hash}"
        else:
            new_stem = f"{output_path.stem}_{content_hash}"

        new_path = output_path.with_name(f"{new_stem}{output_path.suffix}")

        self.logger.info(f"Added content hash to filename: {new_path.name}")

        return new_path

    async def _write_auxiliary_files(
        self, output_path: Path, files: List[Tuple[Path, str]]
    ) -> None:
        """Write auxiliary files (file list and directory list)."""
        if self.config.output.minimal_output:
            return

        # Write file list
        file_list_path = output_path.with_name(f"{output_path.stem}_filelist.txt")
        if file_list_path != output_path:  # Avoid recursion
            await self._write_path_list(file_list_path, files, "files")

        # Write directory list
        dir_list_path = output_path.with_name(f"{output_path.stem}_dirlist.txt")
        if dir_list_path != output_path:  # Avoid recursion
            await self._write_path_list(dir_list_path, files, "directories")

    async def _write_path_list(
        self, path: Path, files: List[Tuple[Path, str]], list_type: str
    ) -> None:
        """Write a list of paths to a file."""
        try:
            if list_type == "files":
                # Preserve the order from the already-sorted files list
                paths = [rel_path for _, rel_path in files]
                # Remove duplicates while preserving order
                seen = set()
                unique_paths = []
                for p in paths:
                    if p not in seen:
                        seen.add(p)
                        unique_paths.append(p)
                sorted_paths = unique_paths
            else:  # directories
                unique_dirs = set()
                for _, rel_path in files:
                    path_obj = Path(rel_path)
                    current = path_obj.parent

                    while str(current) != "." and current != current.parent:
                        unique_dirs.add(str(current))
                        current = current.parent

                # Sort directories by depth and name
                sorted_paths = sort_directories_by_depth_and_name(list(unique_dirs))

            # Write to file
            def write_file():
                with open(path, "w", encoding="utf-8") as f:
                    for p in sorted_paths:
                        f.write(f"{p}\n")

            await asyncio.to_thread(write_file)

            self.logger.info(f"Wrote {len(sorted_paths)} {list_type} to {path}")

        except Exception as e:
            self.logger.error(f"Error writing {list_type} list: {e}")

    async def _create_empty_output(self, output_path: Path) -> None:
        """Create an empty output file with a note."""
        try:
            source = self.config.source_directory or "input file"
            content = f"# No files processed from {source}\n"

            def write_empty():
                with open(output_path, "w", encoding="utf-8") as f:
                    f.write(content)

            await asyncio.to_thread(write_empty)

            self.logger.info(f"Created empty output file: {output_path}")

        except Exception as e:
            raise PermissionError(f"Cannot create output file: {e}")

    async def _count_tokens(self, output_path: Path) -> Optional[int]:
        """Count tokens in the output file."""
        if self.config.output.minimal_output:
            return None

        try:
            import tiktoken

            # Read file content
            def read_file():
                with open(output_path, "r", encoding="utf-8") as f:
                    return f.read()

            content = await asyncio.to_thread(read_file)

            # Count tokens
            encoding = tiktoken.get_encoding("cl100k_base")
            tokens = encoding.encode(content)

            return len(tokens)

        except ImportError:
            self.logger.debug("tiktoken not available for token counting")
            return None
        except Exception as e:
            self.logger.warning(f"Could not count tokens: {e}")
            return None

    def _log_security_warning(self, flagged_files: List[dict]) -> None:
        """Log security warning for flagged files."""
        message = "SECURITY WARNING: Sensitive information detected in the following locations:\n"

        for finding in flagged_files:
            message += f"  - File: {finding['path']}, Line: {finding['line']}, Type: {finding['type']}\n"

        self.logger.warning(message)

======= m1f/encoding_handler.py | CHECKSUM_SHA256: 6a79a5469a0ba466322214ef25bcea6a9e7d5d31af5719b1286b6abb855e552f ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Encoding handler module for character encoding detection and conversion.
"""

from __future__ import annotations

import asyncio
from pathlib import Path
from typing import Tuple, Optional
from dataclasses import dataclass

from .config import Config
from .exceptions import EncodingError
from .logging import LoggerManager

# Try to import chardet for encoding detection
try:
    import chardet

    CHARDET_AVAILABLE = True
except ImportError:
    CHARDET_AVAILABLE = False


@dataclass
class EncodingInfo:
    """Information about file encoding."""

    original_encoding: str
    target_encoding: Optional[str] = None
    had_errors: bool = False


class EncodingHandler:
    """Handles character encoding detection and conversion."""

    def __init__(self, config: Config, logger_manager: LoggerManager):
        self.config = config
        self.logger = logger_manager.get_logger(__name__)

        if self.config.encoding.target_charset and not CHARDET_AVAILABLE:
            self.logger.warning(
                "chardet library not available. Encoding detection will be limited."
            )

    async def read_file(self, file_path: Path) -> Tuple[str, EncodingInfo]:
        """Read a file with encoding detection and optional conversion."""
        # Detect encoding
        detected_encoding = await self._detect_encoding(file_path)

        # Determine target encoding
        target_encoding = self.config.encoding.target_charset or detected_encoding

        # Read and convert file
        content, had_errors = await self._read_and_convert(
            file_path, detected_encoding, target_encoding
        )

        # Create encoding info
        encoding_info = EncodingInfo(
            original_encoding=detected_encoding,
            target_encoding=(
                target_encoding if target_encoding != detected_encoding else None
            ),
            had_errors=had_errors,
        )

        return content, encoding_info

    async def _detect_encoding(self, file_path: Path) -> str:
        """Detect the encoding of a file."""
        if not CHARDET_AVAILABLE:
            return "utf-8"

        try:
            # Read file in binary mode
            with open(file_path, "rb") as f:
                raw_data = f.read(65536)  # Read up to 64KB

            if not raw_data:
                return "utf-8"

            # Check for BOM (Byte Order Mark)
            if raw_data.startswith(b"\xff\xfe"):
                return "utf-16-le"
            elif raw_data.startswith(b"\xfe\xff"):
                return "utf-16-be"
            elif raw_data.startswith(b"\xef\xbb\xbf"):
                return "utf-8-sig"

            # Special handling for files with encoding hints in name
            file_name_lower = file_path.name.lower()
            if "latin1" in file_name_lower or "latin-1" in file_name_lower:
                return "latin-1"
            elif "utf16" in file_name_lower or "utf-16" in file_name_lower:
                # Check for UTF-16 pattern
                if self._looks_like_utf16(raw_data):
                    return "utf-16-le"

            # Use chardet for detection
            result = chardet.detect(raw_data)

            # If chardet returns None or empty encoding, default to utf-8
            if not result or not result.get("encoding"):
                return "utf-8"

            if result["confidence"] < 0.7:
                self.logger.debug(
                    f"Low confidence encoding detection for {file_path}: "
                    f"{result['encoding']} ({result['confidence']:.2f})"
                )
                return "utf-8"

            encoding = result["encoding"]

            # Map some common encoding names
            encoding_map = {
                "iso-8859-8": "windows-1255",  # Hebrew
                "ascii": "utf-8",  # Treat ASCII as UTF-8
                "windows-1252": "utf-8",  # Prefer UTF-8 over Windows-1252 for better emoji support
            }

            # Check if file extension suggests markdown or text files that should be UTF-8
            if file_path.suffix.lower() in ['.md', '.markdown', '.txt', '.rst']:
                # For these files, if chardet detected windows-1252 with less than 0.95 confidence,
                # prefer UTF-8 since these files often contain UTF-8 emojis/special chars
                if encoding.lower() == "windows-1252" and result["confidence"] < 0.95:
                    return "utf-8"

            return encoding_map.get(encoding.lower(), encoding.lower())

        except Exception as e:
            self.logger.warning(f"Error detecting encoding for {file_path}: {e}")
            return "utf-8"

    def _looks_like_utf16(self, data: bytes) -> bool:
        """Check if data looks like UTF-16 encoded text."""
        # Check if every other byte is zero (common in UTF-16-LE for ASCII text)
        if len(data) < 100:
            return False

        zero_count = 0
        for i in range(1, min(100, len(data)), 2):
            if data[i] == 0:
                zero_count += 1

        return zero_count > 40  # More than 40% of checked bytes are zero

    async def _read_and_convert(
        self, file_path: Path, source_encoding: str, target_encoding: str
    ) -> Tuple[str, bool]:
        """Read a file and convert to target encoding."""
        had_errors = False

        try:
            # Read file with source encoding
            with open(file_path, "r", encoding=source_encoding) as f:
                content = f.read()

            # If no conversion needed, return as is
            if source_encoding.lower() == target_encoding.lower():
                return content, False

            # Try to encode to target encoding
            try:
                # Encode and decode to ensure it's valid in target encoding
                encoded = content.encode(target_encoding, errors="strict")
                decoded = encoded.decode(target_encoding)

                if self.config.logging.verbose:
                    self.logger.debug(
                        f"Converted {file_path} from {source_encoding} to {target_encoding}"
                    )

                return decoded, False

            except UnicodeEncodeError as e:
                if self.config.encoding.abort_on_error:
                    raise EncodingError(
                        f"Cannot convert {file_path} from {source_encoding} "
                        f"to {target_encoding}: {e}"
                    )

                # Fall back to replacement
                encoded = content.encode(target_encoding, errors="replace")
                decoded = encoded.decode(target_encoding)

                self.logger.warning(
                    f"Character conversion errors in {file_path} "
                    f"(from {source_encoding} to {target_encoding})"
                )

                return decoded, True

        except UnicodeDecodeError as e:
            if self.config.encoding.abort_on_error:
                raise EncodingError(
                    f"Cannot decode {file_path} with encoding {source_encoding}: {e}"
                )

            # Try reading with error replacement
            try:
                with open(
                    file_path, "r", encoding=source_encoding, errors="replace"
                ) as f:
                    content = f.read()

                self.logger.warning(
                    f"Decoding errors in {file_path} with {source_encoding}"
                )

                return content, True

            except Exception as e2:
                # Last resort: read as binary and decode with replacement
                with open(file_path, "rb") as f:
                    binary_data = f.read()

                content = binary_data.decode("utf-8", errors="replace")

                self.logger.error(
                    f"Failed to decode {file_path} properly, using UTF-8 fallback"
                )

                return content, True

        except Exception as e:
            # Handle other errors
            if self.config.encoding.abort_on_error:
                raise EncodingError(f"Error reading {file_path}: {e}")

            # Return error message as content
            error_content = f"[ERROR: Unable to read file. Reason: {e}]"
            return error_content, True

======= m1f/exceptions.py | CHECKSUM_SHA256: 3c7252f9187b44c46f9c31281535add0760ee08ab7f4271f0abe51fd6de57fb7 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Custom exception classes for m1f.
"""

from typing import Optional


class M1FError(Exception):
    """Base exception for all m1f errors."""

    exit_code: int = 1

    def __init__(self, message: str, exit_code: Optional[int] = None):
        super().__init__(message)
        if exit_code is not None:
            self.exit_code = exit_code


class FileNotFoundError(M1FError):
    """Raised when a required file is not found."""

    exit_code = 2


class PermissionError(M1FError):
    """Raised when there's a permission issue."""

    exit_code = 3


class EncodingError(M1FError):
    """Raised when there's an encoding/decoding issue."""

    exit_code = 4


class ConfigurationError(M1FError):
    """Raised when there's a configuration issue."""

    exit_code = 5


class ValidationError(M1FError):
    """Raised when validation fails."""

    exit_code = 6


class SecurityError(M1FError):
    """Raised when sensitive information is detected."""

    exit_code = 7


class ArchiveError(M1FError):
    """Raised when archive creation fails."""

    exit_code = 8

======= m1f/file_processor.py | CHECKSUM_SHA256: 5114c44843a4ed323222bd0cc56c515fcac837eb46bd254f118e6fadeb43424a ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
File processor module for gathering and filtering files.
"""

from __future__ import annotations

import asyncio
import glob
import os
from pathlib import Path
from typing import List, Tuple, Set, Optional

import pathspec

from .config import Config, FilterConfig
from .constants import DEFAULT_EXCLUDED_DIRS, DEFAULT_EXCLUDED_FILES, MAX_SYMLINK_DEPTH
from .exceptions import FileNotFoundError, ValidationError
from .logging import LoggerManager
from .utils import is_binary_file, is_hidden_path, get_relative_path, format_file_size


class FileProcessor:
    """Handles file discovery and filtering."""

    def __init__(self, config: Config, logger_manager: LoggerManager):
        self.config = config
        self.logger = logger_manager.get_logger(__name__)
        self._symlink_visited: Set[str] = set()
        self._processed_files: Set[str] = set()

        # Initialize preset manager for global settings
        self.preset_manager = None
        self.global_settings = None
        if not config.preset.disable_presets and config.preset.preset_files:
            try:
                from .presets import load_presets

                self.preset_manager = load_presets(config.preset.preset_files)
                self.global_settings = self.preset_manager.get_global_settings()
                self.logger.debug("Loaded global preset settings")
            except Exception as e:
                self.logger.warning(f"Failed to load preset settings: {e}")

        # Build exclusion sets
        self._build_exclusion_sets()

        # Apply global filter settings if available
        self._apply_global_filter_settings()

    def _build_exclusion_sets(self) -> None:
        """Build the exclusion sets from configuration."""
        # Directory exclusions
        self.excluded_dirs = set()
        if not self.config.filter.no_default_excludes:
            self.excluded_dirs = {d.lower() for d in DEFAULT_EXCLUDED_DIRS}

        # Collect all exclude patterns from config and global settings
        all_exclude_patterns = list(self.config.filter.exclude_patterns)
        if self.global_settings and self.global_settings.exclude_patterns:
            all_exclude_patterns.extend(self.global_settings.exclude_patterns)

        # Process exclude patterns - determine if they are directories or files
        for pattern in all_exclude_patterns:
            if "/" not in pattern and "*" not in pattern and "?" not in pattern:
                # Simple name without wildcards or paths
                if self.config.source_directory:
                    potential_path = self.config.source_directory / pattern
                    if potential_path.exists():
                        if potential_path.is_dir():
                            self.excluded_dirs.add(pattern.lower())
                        # If it's a file, it will be handled by gitignore spec
                    else:
                        # If not found, assume it's a directory pattern for safety
                        self.excluded_dirs.add(pattern.lower())
                else:
                    # No source directory specified, add to dirs for backward compatibility
                    self.excluded_dirs.add(pattern.lower())

        # File exclusions
        self.excluded_files = set()
        if not self.config.filter.no_default_excludes:
            self.excluded_files = DEFAULT_EXCLUDED_FILES.copy()

        # Load exclusions from file
        self.exact_excludes = set()
        self.gitignore_spec = None

        if self.config.filter.exclude_paths_file:
            self._load_exclude_patterns()

        # Load inclusions from file
        self.exact_includes = set()
        self.include_gitignore_spec = None

        if self.config.filter.include_paths_file:
            self._load_include_patterns()

        # Build gitignore spec from command-line patterns
        self._build_gitignore_spec()

    def _load_exclude_patterns(self) -> None:
        """Load exclusion patterns from file(s)."""
        exclude_files_param = self.config.filter.exclude_paths_file
        if not exclude_files_param:
            return

        # Convert to list if it's a single string/Path
        if isinstance(exclude_files_param, (str, Path)):
            exclude_files = [exclude_files_param]
        else:
            exclude_files = exclude_files_param

        all_gitignore_lines = []

        for exclude_file_str in exclude_files:
            exclude_file = Path(exclude_file_str)

            if not exclude_file.exists():
                self.logger.info(f"Exclude file not found (skipping): {exclude_file}")
                continue

            try:
                with open(exclude_file, "r", encoding="utf-8") as f:
                    lines = [
                        line.strip()
                        for line in f
                        if line.strip() and not line.strip().startswith("#")
                    ]

                # Detect if it's gitignore format
                is_gitignore = exclude_file.name == ".gitignore" or any(
                    any(ch in line for ch in ["*", "?", "!"]) or line.endswith("/")
                    for line in lines
                )

                if is_gitignore:
                    self.logger.info(f"Processing {exclude_file} as gitignore format")
                    all_gitignore_lines.extend(lines)
                else:
                    self.logger.info(f"Processing {exclude_file} as exact path list")
                    for line in lines:
                        path = Path(line)
                        if not path.is_absolute() and self.config.source_directory:
                            path = self.config.source_directory / path
                        self.exact_excludes.add(str(path.resolve()))

            except Exception as e:
                self.logger.warning(f"Error reading exclude file {exclude_file}: {e}")

        # Build combined gitignore spec from all collected lines
        if all_gitignore_lines:
            self.gitignore_spec = pathspec.PathSpec.from_lines(
                "gitwildmatch", all_gitignore_lines
            )

    def _load_include_patterns(self) -> None:
        """Load inclusion patterns from file(s)."""
        include_files_param = self.config.filter.include_paths_file
        if not include_files_param:
            return

        # Convert to list if it's a single string/Path
        if isinstance(include_files_param, (str, Path)):
            include_files = [include_files_param]
        else:
            include_files = include_files_param

        all_gitignore_lines = []

        for include_file_str in include_files:
            include_file = Path(include_file_str)

            if not include_file.exists():
                self.logger.info(f"Include file not found (skipping): {include_file}")
                continue

            try:
                with open(include_file, "r", encoding="utf-8") as f:
                    lines = [
                        line.strip()
                        for line in f
                        if line.strip() and not line.strip().startswith("#")
                    ]

                # Detect if it's gitignore format
                is_gitignore = any(
                    any(ch in line for ch in ["*", "?", "!"]) or line.endswith("/")
                    for line in lines
                )

                if is_gitignore:
                    self.logger.info(f"Processing {include_file} as gitignore format")
                    all_gitignore_lines.extend(lines)
                else:
                    self.logger.info(f"Processing {include_file} as exact path list")
                    for line in lines:
                        path = Path(line)
                        if not path.is_absolute() and self.config.source_directory:
                            path = self.config.source_directory / path
                        self.exact_includes.add(str(path.resolve()))

            except Exception as e:
                self.logger.warning(f"Error reading include file {include_file}: {e}")

        # Build combined gitignore spec from all collected lines
        if all_gitignore_lines:
            self.include_gitignore_spec = pathspec.PathSpec.from_lines(
                "gitwildmatch", all_gitignore_lines
            )

    def _build_gitignore_spec(self) -> None:
        """Build gitignore spec from command-line patterns."""
        patterns = []

        # ALL patterns should be processed, not just those with wildcards
        # This allows excluding specific files like "CLAUDE.md" without wildcards
        for pattern in self.config.filter.exclude_patterns:
            patterns.append(pattern)

        # Add global preset exclude patterns
        if self.global_settings and self.global_settings.exclude_patterns:
            for pattern in self.global_settings.exclude_patterns:
                patterns.append(pattern)

        if patterns:
            try:
                spec = pathspec.PathSpec.from_lines("gitwildmatch", patterns)
                if self.gitignore_spec:
                    # Combine with existing spec
                    all_patterns = list(self.gitignore_spec.patterns) + list(
                        spec.patterns
                    )
                    self.gitignore_spec = pathspec.PathSpec(all_patterns)
                else:
                    self.gitignore_spec = spec
            except Exception as e:
                self.logger.error(f"Error building gitignore spec: {e}")

    async def gather_files(self) -> List[Tuple[Path, str]]:
        """Gather all files to process based on configuration."""
        files_to_process = []

        if self.config.input_file:
            # Process from input file
            input_paths = await self._process_input_file()
            files_to_process = await self._gather_from_paths(input_paths)
        elif self.config.source_directory:
            # Process from source directory
            files_to_process = await self._gather_from_directory(
                self.config.source_directory
            )
        else:
            raise ValidationError("No source directory or input file specified")

        # Sort by relative path
        files_to_process.sort(key=lambda x: x[1].lower())

        return files_to_process

    async def _process_input_file(self) -> List[Path]:
        """Process input file and return list of paths."""
        input_file = self.config.input_file
        paths = []

        base_dir = self.config.source_directory or input_file.parent

        try:
            with open(input_file, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("#"):
                        continue

                    # Handle glob patterns
                    if any(ch in line for ch in ["*", "?", "["]):
                        pattern_path = Path(line)
                        if not pattern_path.is_absolute():
                            pattern_path = base_dir / pattern_path

                        matches = glob.glob(str(pattern_path), recursive=True)
                        paths.extend(Path(m).resolve() for m in matches)
                    else:
                        path = Path(line)
                        if not path.is_absolute():
                            path = base_dir / path
                        paths.append(path.resolve())

            # Deduplicate paths
            paths = self._deduplicate_paths(paths)

            self.logger.info(f"Found {len(paths)} paths from input file")
            return paths

        except Exception as e:
            raise FileNotFoundError(f"Error processing input file: {e}")

    def _deduplicate_paths(self, paths: List[Path]) -> List[Path]:
        """Remove paths that are children of other paths in the list."""
        if not paths:
            return []

        # Sort by path depth
        paths.sort(key=lambda p: len(p.parts))

        # Keep only paths that aren't children of others
        keep_paths = set(paths)

        for i, path in enumerate(paths):
            if path not in keep_paths:
                continue

            for other_path in paths[i + 1 :]:
                try:
                    if other_path.is_relative_to(path):
                        keep_paths.discard(other_path)
                except (ValueError, RuntimeError):
                    continue

        return sorted(keep_paths)

    async def _gather_from_paths(self, paths: List[Path]) -> List[Tuple[Path, str]]:
        """Gather files from a list of paths."""
        files = []

        for path in paths:
            if not path.exists():
                self.logger.warning(f"Path not found: {path}")
                continue

            if path.is_file():
                if await self._should_include_file(path, explicitly_included=True):
                    rel_path = get_relative_path(
                        path, self.config.source_directory or path.parent
                    )
                    files.append((path, rel_path))
            elif path.is_dir():
                dir_files = await self._gather_from_directory(
                    path, explicitly_included=True
                )
                files.extend(dir_files)

        return files

    async def _gather_from_directory(
        self, directory: Path, explicitly_included: bool = False
    ) -> List[Tuple[Path, str]]:
        """Recursively gather files from a directory."""
        files = []

        # Use os.walk for efficiency
        for root, dirs, filenames in os.walk(
            directory, followlinks=self.config.filter.include_symlinks
        ):
            root_path = Path(root)

            # Filter directories
            dirs[:] = await self._filter_directories(root_path, dirs)

            # Process files
            for filename in filenames:
                file_path = root_path / filename

                if await self._should_include_file(file_path, explicitly_included):
                    rel_path = get_relative_path(
                        file_path, self.config.source_directory or directory
                    )

                    # Check for duplicates
                    # When include_symlinks is True, use the actual path (not resolved) for deduplication
                    # This allows both the original file and symlinks pointing to it to be included
                    if self.config.filter.include_symlinks and file_path.is_symlink():
                        dedup_key = str(file_path)
                    else:
                        dedup_key = str(file_path.resolve())
                    
                    if dedup_key not in self._processed_files:
                        files.append((file_path, rel_path))
                        self._processed_files.add(dedup_key)
                    else:
                        self.logger.debug(f"Skipping duplicate: {file_path} (key: {dedup_key})")
                else:
                    self.logger.debug(f"File excluded by filter: {file_path}")

        return files

    async def _filter_directories(self, root: Path, dirs: List[str]) -> List[str]:
        """Filter directories based on exclusion rules."""
        filtered = []

        for dirname in dirs:
            dir_path = root / dirname

            # Check if directory is excluded
            if dirname.lower() in self.excluded_dirs:
                continue

            # Check dot directories
            if not self.config.filter.include_dot_paths and dirname.startswith("."):
                continue

            # Check symlinks
            if dir_path.is_symlink():
                if not self.config.filter.include_symlinks:
                    continue

                # Check for cycles
                if self._detect_symlink_cycle(dir_path):
                    self.logger.warning(f"Skipping symlink cycle: {dir_path}")
                    continue

            filtered.append(dirname)

        return filtered

    async def _should_include_file(
        self, file_path: Path, explicitly_included: bool = False
    ) -> bool:
        """Check if a file should be included based on filters."""
        # Check if file exists
        if not file_path.exists():
            return False

        # If explicitly included (from -i file), skip most filters but still check binary
        if explicitly_included:
            # Still check binary files even for explicitly included files
            include_binary = self.config.filter.include_binary_files
            if (
                hasattr(self, "_global_include_binary_files")
                and self._global_include_binary_files is not None
            ):
                include_binary = include_binary or self._global_include_binary_files
            
            if not include_binary and is_binary_file(file_path):
                return False
            
            return True

        # Get file-specific settings from presets
        file_settings = {}
        if self.preset_manager:
            file_settings = (
                self.preset_manager.get_file_specific_settings(file_path) or {}
            )

        # Check if we have include patterns - if yes, file must match one
        if self.exact_includes or self.include_gitignore_spec:
            include_matched = False

            # Check exact includes
            if str(file_path.resolve()) in self.exact_includes:
                include_matched = True

            # Check include gitignore patterns
            if not include_matched and self.include_gitignore_spec:
                rel_path = get_relative_path(
                    file_path, self.config.source_directory or file_path.parent
                )
                if self.include_gitignore_spec.match_file(rel_path):
                    include_matched = True

            # If we have include patterns but file doesn't match any, exclude it
            if not include_matched:
                return False

        # Check exact excludes
        if str(file_path.resolve()) in self.exact_excludes:
            return False

        # Check filename excludes
        if file_path.name in self.excluded_files:
            return False

        # Check gitignore patterns
        if self.gitignore_spec:
            rel_path = get_relative_path(
                file_path, self.config.source_directory or file_path.parent
            )
            if self.gitignore_spec.match_file(rel_path):
                return False

        # Check dot files
        include_dots = self.config.filter.include_dot_paths
        if (
            hasattr(self, "_global_include_dot_paths")
            and self._global_include_dot_paths is not None
        ):
            include_dots = include_dots or self._global_include_dot_paths
        # File-specific override
        if "include_dot_paths" in file_settings:
            include_dots = file_settings["include_dot_paths"]

        if not explicitly_included and not include_dots:
            if is_hidden_path(file_path):
                return False

        # Check binary files
        include_binary = self.config.filter.include_binary_files
        if (
            hasattr(self, "_global_include_binary_files")
            and self._global_include_binary_files is not None
        ):
            include_binary = include_binary or self._global_include_binary_files
        # File-specific override
        if "include_binary_files" in file_settings:
            include_binary = file_settings["include_binary_files"]

        if not include_binary:
            if is_binary_file(file_path):
                return False

        # Check extensions
        # Combine config and global preset include extensions
        include_exts = set(self.config.filter.include_extensions)
        if self.global_settings and self.global_settings.include_extensions:
            include_exts.update(
                ext.lower() if ext.startswith(".") else f".{ext.lower()}"
                for ext in self.global_settings.include_extensions
            )

        if include_exts:
            if file_path.suffix.lower() not in include_exts:
                return False

        # Combine config and global preset exclude extensions
        exclude_exts = set(self.config.filter.exclude_extensions)
        if self.global_settings and self.global_settings.exclude_extensions:
            exclude_exts.update(
                ext.lower() if ext.startswith(".") else f".{ext.lower()}"
                for ext in self.global_settings.exclude_extensions
            )

        if exclude_exts:
            if file_path.suffix.lower() in exclude_exts:
                return False

        # Check symlinks
        if file_path.is_symlink():
            include_symlinks = self.config.filter.include_symlinks
            if (
                hasattr(self, "_global_include_symlinks")
                and self._global_include_symlinks is not None
            ):
                include_symlinks = include_symlinks or self._global_include_symlinks

            if not include_symlinks:
                self.logger.debug(f"Excluding symlink {file_path} (include_symlinks=False)")
                return False

            # For file symlinks, we only need to check for cycles if it's a directory symlink
            # File symlinks don't create cycles in the same way directory symlinks do
            if file_path.is_dir() and self._detect_symlink_cycle(file_path):
                self.logger.debug(f"Excluding symlink {file_path} (cycle detected)")
                return False
            
            self.logger.debug(f"Including symlink {file_path} (include_symlinks=True)")

        # Check file size limit
        max_size = self.config.filter.max_file_size
        if (
            hasattr(self, "_global_max_file_size")
            and self._global_max_file_size is not None
        ):
            # Use the smaller of the two limits if both are set
            if max_size is not None:
                max_size = min(max_size, self._global_max_file_size)
            else:
                max_size = self._global_max_file_size

        # File-specific override
        if "max_file_size" in file_settings:
            from .utils import parse_file_size

            try:
                file_max_size = parse_file_size(file_settings["max_file_size"])
                # If file-specific limit is set, use it (not the minimum)
                max_size = file_max_size
            except ValueError as e:
                self.logger.warning(
                    f"Invalid file-specific max_file_size for {file_path}: {e}"
                )

        if max_size is not None:
            try:
                file_size = file_path.stat().st_size
                if file_size > max_size:
                    self.logger.info(
                        f"Skipping {file_path.name} due to size limit: "
                        f"{format_file_size(file_size)} > {format_file_size(max_size)}"
                    )
                    return False
            except OSError as e:
                self.logger.warning(f"Could not check size of {file_path}: {e}")
                return False

        return True

    def _detect_symlink_cycle(self, path: Path) -> bool:
        """Detect if following a symlink would create a cycle."""
        try:
            current = path
            depth = 0
            visited = self._symlink_visited.copy()

            while current.is_symlink() and depth < MAX_SYMLINK_DEPTH:
                target = current.readlink()
                if not target.is_absolute():
                    target = current.parent / target
                target = target.resolve(strict=False)

                target_str = str(target)
                if target_str in visited:
                    return True

                # Check if target is ancestor
                try:
                    if current.parent.resolve(strict=False).is_relative_to(target):
                        return True
                except (ValueError, AttributeError):
                    # Not an ancestor or method not available
                    pass

                if target.is_symlink():
                    visited.add(target_str)

                current = target
                depth += 1

            if depth >= MAX_SYMLINK_DEPTH:
                return True

            # Update global visited set
            self._symlink_visited.update(visited)
            return False

        except (OSError, RuntimeError):
            return True

    def _apply_global_filter_settings(self) -> None:
        """Apply global filter settings from presets."""
        if not self.global_settings:
            return

        # Apply global filter settings to config-like attributes
        if self.global_settings.include_dot_paths is not None:
            self._global_include_dot_paths = self.global_settings.include_dot_paths
        else:
            self._global_include_dot_paths = None

        if self.global_settings.include_binary_files is not None:
            self._global_include_binary_files = (
                self.global_settings.include_binary_files
            )
        else:
            self._global_include_binary_files = None

        if self.global_settings.include_symlinks is not None:
            self._global_include_symlinks = self.global_settings.include_symlinks
        else:
            self._global_include_symlinks = None

        if self.global_settings.no_default_excludes is not None:
            self._global_no_default_excludes = self.global_settings.no_default_excludes
            # Rebuild exclusion sets if needed
            if (
                self._global_no_default_excludes
                and not self.config.filter.no_default_excludes
            ):
                self.excluded_dirs.clear()
                self.excluded_files.clear()

        if self.global_settings.max_file_size:
            from .utils import parse_file_size

            try:
                self._global_max_file_size = parse_file_size(
                    self.global_settings.max_file_size
                )
            except ValueError as e:
                self.logger.warning(f"Invalid global max_file_size: {e}")
                self._global_max_file_size = None
        else:
            self._global_max_file_size = None

    def _load_exclude_patterns_from_file(self, exclude_file: Path) -> None:
        """Load exclusion patterns from a file (helper method)."""
        try:
            with open(exclude_file, "r", encoding="utf-8") as f:
                lines = [
                    line.strip()
                    for line in f
                    if line.strip() and not line.strip().startswith("#")
                ]

            # Add to gitignore spec if patterns found
            patterns = [
                line
                for line in lines
                if any(ch in line for ch in ["*", "?", "!"]) or line.endswith("/")
            ]
            if patterns:
                spec = pathspec.PathSpec.from_lines("gitwildmatch", patterns)
                if self.gitignore_spec:
                    # Combine with existing spec
                    all_patterns = list(self.gitignore_spec.patterns) + list(
                        spec.patterns
                    )
                    self.gitignore_spec = pathspec.PathSpec(all_patterns)
                else:
                    self.gitignore_spec = spec

        except Exception as e:
            self.logger.error(
                f"Error loading exclude patterns from {exclude_file}: {e}"
            )

======= m1f/logging.py | CHECKSUM_SHA256: 4f0ea3738c29fd412ea7baa6cfdbf6a59588d5d32388f592797c7e8848b46b23 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Logging configuration for m1f.
"""

from __future__ import annotations

import logging
import sys
from pathlib import Path
from typing import Optional, Dict, Any
from dataclasses import dataclass
from contextlib import asynccontextmanager

from .config import Config, LoggingConfig


@dataclass
class LoggerManager:
    """Manages loggers and handlers for the application."""

    config: LoggingConfig
    output_file_path: Optional[Path] = None
    _loggers: Dict[str, logging.Logger] = None
    _handlers: list[logging.Handler] = None

    def __post_init__(self):
        self._loggers = {}
        self._handlers = []
        self._setup()

    def _setup(self) -> None:
        """Set up the logging configuration."""
        # Determine logging level
        if self.config.quiet:
            level = logging.CRITICAL + 1  # Suppress all output
        elif self.config.verbose:
            level = logging.DEBUG
        else:
            level = logging.INFO

        # Configure root logger
        root_logger = logging.getLogger()
        root_logger.setLevel(level)

        # Remove any existing handlers
        for handler in root_logger.handlers[:]:
            root_logger.removeHandler(handler)

        # Create console handler if not quiet
        if not self.config.quiet:
            console_handler = self._create_console_handler(level)
            root_logger.addHandler(console_handler)
            self._handlers.append(console_handler)

        # Create file handler if output path is provided
        if self.output_file_path and not self.config.quiet:
            file_handler = self._create_file_handler(self.output_file_path, level)
            if file_handler:
                root_logger.addHandler(file_handler)
                self._handlers.append(file_handler)

    def _create_console_handler(self, level: int) -> logging.StreamHandler:
        """Create a console handler with colored output if available."""
        handler = logging.StreamHandler(sys.stdout)
        handler.setLevel(level)

        # Try to use colorama for colored output
        try:
            from colorama import Fore, Style, init

            init(autoreset=True)

            class ColoredFormatter(logging.Formatter):
                """Custom formatter with colors."""

                COLORS = {
                    "DEBUG": Fore.CYAN,
                    "INFO": Fore.GREEN,
                    "WARNING": Fore.YELLOW,
                    "ERROR": Fore.RED,
                    "CRITICAL": Fore.RED + Style.BRIGHT,
                }

                def format(self, record: logging.LogRecord) -> str:
                    color = self.COLORS.get(record.levelname, "")
                    reset = Style.RESET_ALL if color else ""
                    record.levelname = f"{color}{record.levelname}{reset}"
                    return super().format(record)

            formatter = ColoredFormatter("%(levelname)-8s: %(message)s")
        except ImportError:
            # Fallback to simple formatter
            formatter = logging.Formatter("%(levelname)-8s: %(message)s")

        handler.setFormatter(formatter)
        return handler

    def _create_file_handler(
        self, output_path: Path, level: int
    ) -> Optional[logging.FileHandler]:
        """Create a file handler for logging to disk."""
        log_file_path = output_path.with_suffix(".log")

        # Ensure log file doesn't overwrite output file
        if log_file_path == output_path:
            return None

        try:
            # Ensure parent directory exists
            log_file_path.parent.mkdir(parents=True, exist_ok=True)

            handler = logging.FileHandler(
                log_file_path, mode="w", encoding="utf-8", delay=False
            )
            handler.setLevel(level)

            formatter = logging.Formatter(
                "%(asctime)s - %(name)s - %(levelname)-8s: %(message)s"
            )
            handler.setFormatter(formatter)

            return handler

        except Exception as e:
            # Log to console if file handler creation fails
            print(f"Warning: Could not create log file at {log_file_path}: {e}")
            return None

    def get_logger(self, name: str) -> logging.Logger:
        """Get or create a logger with the given name."""
        if name not in self._loggers:
            logger = logging.getLogger(name)
            self._loggers[name] = logger
        return self._loggers[name]

    def set_output_file(self, output_path: Path) -> None:
        """Set the output file path and create file handler if needed."""
        self.output_file_path = output_path

        # Add file handler if not already present
        if not self.config.quiet and not any(
            isinstance(h, logging.FileHandler) for h in self._handlers
        ):
            file_handler = self._create_file_handler(output_path, logging.DEBUG)
            if file_handler:
                logging.getLogger().addHandler(file_handler)
                self._handlers.append(file_handler)

    async def cleanup(self) -> None:
        """Clean up all handlers and loggers."""
        # Remove and close all handlers
        root_logger = logging.getLogger()

        for handler in self._handlers:
            root_logger.removeHandler(handler)
            if hasattr(handler, "close"):
                handler.close()

        self._handlers.clear()
        self._loggers.clear()

        # Shutdown logging
        logging.shutdown()


# Module-level logger manager instance
_logger_manager: Optional[LoggerManager] = None


def setup_logging(config: Config) -> LoggerManager:
    """Set up logging for the application."""
    global _logger_manager

    if _logger_manager is not None:
        # Clean up existing manager
        import asyncio

        asyncio.create_task(_logger_manager.cleanup())

    _logger_manager = LoggerManager(config.logging)
    return _logger_manager


def get_logger(name: str) -> logging.Logger:
    """Get a logger with the given name."""
    if _logger_manager is None:
        # Fallback to basic logger if not initialized
        return logging.getLogger(name)

    return _logger_manager.get_logger(name)


@asynccontextmanager
async def logging_context(config: Config, output_path: Optional[Path] = None):
    """Context manager for logging setup and cleanup."""
    manager = setup_logging(config)

    if output_path:
        manager.set_output_file(output_path)

    try:
        yield manager
    finally:
        await manager.cleanup()

======= m1f/output_writer.py | CHECKSUM_SHA256: a8e500fe1cd9bc72012f9f33f41379dc017c692611f414e9215aaaef49f49aaa ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Output writer module for writing combined files with separators.
"""

from __future__ import annotations

import asyncio
import hashlib
from pathlib import Path
from typing import List, Tuple, Set, Optional
import re

from .config import Config, SeparatorStyle
from .constants import READ_BUFFER_SIZE
from .encoding_handler import EncodingHandler
from .exceptions import PermissionError, EncodingError
from .logging import LoggerManager
from .separator_generator import SeparatorGenerator
from .utils import calculate_checksum
from .presets import PresetManager


class OutputWriter:
    """Handles writing the combined output file."""

    def __init__(self, config: Config, logger_manager: LoggerManager):
        self.config = config
        self.logger = logger_manager.get_logger(__name__)

        # Initialize preset manager first to get global settings
        self.preset_manager = None
        self.global_settings = None
        if not config.preset.disable_presets and config.preset.preset_files:
            try:
                from .presets import load_presets

                self.preset_manager = load_presets(config.preset.preset_files)
                self.global_settings = self.preset_manager.get_global_settings()
                self.logger.debug(
                    f"Loaded {len(self.preset_manager.groups)} preset groups"
                )
            except Exception as e:
                self.logger.warning(f"Failed to load presets: {e}")

        # Apply global settings to config if available
        config = self._apply_global_settings(config)

        self.encoding_handler = EncodingHandler(config, logger_manager)
        self.separator_generator = SeparatorGenerator(config, logger_manager)
        self._processed_checksums: Set[str] = set()
        self._content_dedupe: bool = True  # Enable content deduplication by default

    def _apply_global_settings(self, config: Config) -> Config:
        """Apply global preset settings to config if not already set."""
        if not self.global_settings:
            return config

        from dataclasses import replace
        from .config import (
            SeparatorStyle,
            LineEnding,
            EncodingConfig,
            OutputConfig,
            FilterConfig,
            SecurityConfig,
            SecurityCheckMode,
        )

        # Create updated components
        encoding_config = config.encoding
        output_config = config.output
        filter_config = config.filter
        security_config = config.security

        # Apply encoding settings
        if not config.encoding.target_charset and self.global_settings.encoding:
            encoding_config = replace(
                config.encoding, target_charset=self.global_settings.encoding
            )
            self.logger.debug(
                f"Applied global encoding: {self.global_settings.encoding}"
            )

        if self.global_settings.abort_on_encoding_error is not None:
            encoding_config = replace(
                encoding_config,
                abort_on_error=self.global_settings.abort_on_encoding_error,
            )
            self.logger.debug(
                f"Applied global abort_on_encoding_error: {self.global_settings.abort_on_encoding_error}"
            )

        # Apply separator style if global setting exists
        if self.global_settings.separator_style:
            try:
                global_style = SeparatorStyle(self.global_settings.separator_style)
                output_config = replace(output_config, separator_style=global_style)
                self.logger.debug(
                    f"Applied global separator style: {self.global_settings.separator_style}"
                )
            except ValueError:
                self.logger.warning(
                    f"Invalid global separator style: {self.global_settings.separator_style}"
                )

        # Apply line ending if global setting exists
        if self.global_settings.line_ending:
            try:
                global_ending = LineEnding.from_str(self.global_settings.line_ending)
                output_config = replace(output_config, line_ending=global_ending)
                self.logger.debug(
                    f"Applied global line ending: {self.global_settings.line_ending}"
                )
            except ValueError:
                self.logger.warning(
                    f"Invalid global line ending: {self.global_settings.line_ending}"
                )

        # Apply filter settings
        if self.global_settings.remove_scraped_metadata is not None:
            filter_config = replace(
                filter_config,
                remove_scraped_metadata=self.global_settings.remove_scraped_metadata,
            )
            self.logger.debug(
                f"Applied global remove_scraped_metadata: {self.global_settings.remove_scraped_metadata}"
            )

        # Apply security settings
        if self.global_settings.security_check and not config.security.security_check:
            try:
                security_mode = SecurityCheckMode(self.global_settings.security_check)
                security_config = replace(security_config, security_check=security_mode)
                self.logger.debug(
                    f"Applied global security_check: {self.global_settings.security_check}"
                )
            except ValueError:
                self.logger.warning(
                    f"Invalid global security_check mode: {self.global_settings.security_check}"
                )

        # Return updated config
        return replace(
            config,
            encoding=encoding_config,
            output=output_config,
            filter=filter_config,
            security=security_config,
        )

    def _remove_scraped_metadata(self, content: str) -> str:
        """Remove scraped metadata from the end of markdown content."""
        if not self.config.filter.remove_scraped_metadata:
            return content

        # Pattern to match scraped metadata at the end of the file
        # Looks for a horizontal rule followed by scraped metadata
        pattern = (
            r"\n\n---\n\n"
            r"\*Scraped from:.*?\*\n\n"
            r"\*Scraped at:.*?\*\n\n"
            r"\*Source URL:.*?\*\s*$"
        )

        # Remove the metadata if found
        cleaned_content = re.sub(pattern, "", content, flags=re.DOTALL)

        if cleaned_content != content:
            self.logger.debug("Removed scraped metadata from file content")

        return cleaned_content

    async def write_combined_file(
        self, output_path: Path, files_to_process: List[Tuple[Path, str]]
    ) -> int:
        """Write all files to the combined output file."""
        total_files = len(files_to_process)
        self.logger.info(f"Processing {total_files} file(s) for inclusion...")

        # Prepare include files if any
        include_files = await self._prepare_include_files()

        # Combine include files with regular files
        all_files = include_files + files_to_process

        try:
            # Open output file
            output_encoding = self.config.encoding.target_charset or "utf-8"

            with open(
                output_path,
                "w",
                encoding=output_encoding,
                newline=self.config.output.line_ending.value,
            ) as outfile:

                files_written = 0

                for i, (file_path, rel_path) in enumerate(all_files, 1):
                    # Skip if output file itself
                    if file_path.resolve() == output_path.resolve():
                        self.logger.warning(f"Skipping output file itself: {file_path}")
                        continue

                    # Process and write file
                    if await self._write_single_file(
                        outfile, file_path, rel_path, i, len(all_files)
                    ):
                        files_written += 1

                return files_written

        except IOError as e:
            raise PermissionError(f"Cannot write to output file: {e}")

    async def _prepare_include_files(self) -> List[Tuple[Path, str]]:
        """Prepare include files from configuration."""
        include_files = []

        if not self.config.input_include_files:
            return include_files

        for i, include_path in enumerate(self.config.input_include_files):
            if not include_path.exists():
                self.logger.warning(f"Include file not found: {include_path}")
                continue

            # Use special prefix for include files
            if i == 0:
                rel_path = f"intro:{include_path.name}"
            else:
                rel_path = f"include:{include_path.name}"

            include_files.append((include_path, rel_path))

        return include_files

    async def _write_single_file(
        self, outfile, file_path: Path, rel_path: str, file_num: int, total_files: int
    ) -> bool:
        """Write a single file to the output."""
        try:
            # Log progress
            if self.config.logging.verbose:
                self.logger.debug(
                    f"Processing file ({file_num}/{total_files}): {file_path.name}"
                )

            # Read file with encoding handling
            content, encoding_info = await self.encoding_handler.read_file(file_path)

            # Apply preset processing if available
            preset = None
            if self.preset_manager:
                preset = self.preset_manager.get_preset_for_file(
                    file_path, self.config.preset.preset_group
                )
                if preset:
                    self.logger.debug(f"Applying preset to {file_path}")
                    content = self.preset_manager.process_content(
                        content, preset, file_path
                    )

            # Remove scraped metadata if requested
            # Check file-specific override first
            remove_metadata = self.config.filter.remove_scraped_metadata
            if (
                preset
                and hasattr(preset, "remove_scraped_metadata")
                and preset.remove_scraped_metadata is not None
            ):
                remove_metadata = preset.remove_scraped_metadata

            if remove_metadata:
                content = self._remove_scraped_metadata(content)

            # Check for content deduplication
            # Skip deduplication for symlinks when include_symlinks is enabled
            skip_dedupe = (
                self.config.filter.include_symlinks and file_path.is_symlink()
            )
            
            if self._content_dedupe and not rel_path.startswith(("intro:", "include:")) and not skip_dedupe:
                content_checksum = calculate_checksum(content)

                if content_checksum in self._processed_checksums:
                    self.logger.debug(f"Skipping duplicate content: {file_path}")
                    return False

                self._processed_checksums.add(content_checksum)

            # Generate separator
            # Check if preset overrides separator style
            separator_style = self.config.output.separator_style
            if self.preset_manager and preset and preset.separator_style:
                try:
                    separator_style = SeparatorStyle(preset.separator_style)
                except ValueError:
                    self.logger.warning(
                        f"Invalid separator style in preset: {preset.separator_style}"
                    )

            # Temporarily override separator style if needed
            original_style = self.separator_generator.config.output.separator_style
            if separator_style != original_style:
                # Create a temporary config with the new style
                from dataclasses import replace

                temp_output = replace(
                    self.separator_generator.config.output,
                    separator_style=separator_style,
                )
                temp_config = replace(
                    self.separator_generator.config, output=temp_output
                )
                self.separator_generator.config = temp_config

            separator = await self.separator_generator.generate_separator(
                file_path=file_path,
                rel_path=rel_path,
                encoding_info=encoding_info,
                file_content=content,
            )

            # Restore original config if changed
            if separator_style != original_style:
                self.separator_generator.config = self.config

            # Write separator
            if separator:
                outfile.write(separator)

                # Add blank line for some styles
                if self.config.output.separator_style in [
                    SeparatorStyle.STANDARD,
                    SeparatorStyle.DETAILED,
                    SeparatorStyle.MARKDOWN,
                ]:
                    outfile.write(self.config.output.line_ending.value)

            # Write content
            outfile.write(content)

            # Ensure newline at end if needed
            if (
                content
                and not content.endswith(("\n", "\r"))
                and self.config.output.separator_style
                != SeparatorStyle.MACHINE_READABLE
            ):
                outfile.write(self.config.output.line_ending.value)

            # Write closing separator
            closing = await self.separator_generator.generate_closing_separator()
            if closing:
                outfile.write(closing)
                outfile.write(self.config.output.line_ending.value)

            # Add inter-file spacing
            if (
                file_num < total_files
                and self.config.output.separator_style != SeparatorStyle.NONE
            ):
                outfile.write(self.config.output.line_ending.value)

            return True

        except Exception as e:
            self.logger.error(f"Error processing file {file_path}: {e}")

            if self.config.encoding.abort_on_error:
                raise EncodingError(f"Failed to process {file_path}: {e}")

            # Write error placeholder
            error_msg = f"[ERROR: Unable to read file '{file_path}'. Reason: {e}]"
            outfile.write(error_msg)
            outfile.write(self.config.output.line_ending.value)

            return True

======= m1f/presets.py | CHECKSUM_SHA256: 82088476064f8cfa6fdd5fcaca013d7eadf40876b2db4cca92a7ebdd51efad86 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Preset system for m1f - Apply file-specific processing rules.

This module provides a flexible preset system that allows different processing
rules for different file types within the same m1f bundle.
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Any, Union
import yaml
import fnmatch
import logging
from enum import Enum

logger = logging.getLogger(__name__)


class ProcessingAction(Enum):
    """Available processing actions for files."""

    NONE = "none"
    MINIFY = "minify"
    STRIP_TAGS = "strip_tags"
    STRIP_COMMENTS = "strip_comments"
    COMPRESS_WHITESPACE = "compress_whitespace"
    REMOVE_EMPTY_LINES = "remove_empty_lines"
    JOIN_PARAGRAPHS = "join_paragraphs"
    CUSTOM = "custom"


@dataclass
class FilePreset:
    """Preset configuration for a specific file type or pattern."""

    # File matching
    patterns: List[str] = field(default_factory=list)  # Glob patterns
    extensions: List[str] = field(default_factory=list)  # File extensions

    # Processing options
    actions: List[ProcessingAction] = field(default_factory=list)
    strip_tags: List[str] = field(default_factory=list)  # HTML tags to strip
    preserve_tags: List[str] = field(default_factory=list)  # Tags to preserve

    # Output options
    separator_style: Optional[str] = None  # DEPRECATED - use global_settings.separator_style instead
    include_metadata: bool = True
    max_lines: Optional[int] = None  # Truncate after N lines

    # File-specific filter overrides
    max_file_size: Optional[str] = None  # Override max file size for these files
    security_check: Optional[str] = None  # Override security check for these files
    include_dot_paths: Optional[bool] = None
    include_binary_files: Optional[bool] = None
    remove_scraped_metadata: Optional[bool] = None

    # Custom processing
    custom_processor: Optional[str] = None  # Name of custom processor
    processor_args: Dict[str, Any] = field(default_factory=dict)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "FilePreset":
        """Create FilePreset from dictionary."""
        # Convert action strings to enums
        if "actions" in data:
            data["actions"] = [
                ProcessingAction(action) if isinstance(action, str) else action
                for action in data["actions"]
            ]
        return cls(**data)


@dataclass
class GlobalSettings:
    """Global settings that apply to all files unless overridden."""

    # General settings
    encoding: Optional[str] = None  # Target encoding (e.g., 'utf-8')
    separator_style: Optional[str] = None  # Default separator style
    line_ending: Optional[str] = None  # 'lf' or 'crlf'

    # Input/Output settings
    source_directory: Optional[str] = None  # Source directory path
    input_file: Optional[str] = None  # Input file path
    output_file: Optional[str] = None  # Output file path
    input_include_files: Optional[Union[str, List[str]]] = None  # Intro files

    # Output control settings
    add_timestamp: Optional[bool] = None  # Add timestamp to filename
    filename_mtime_hash: Optional[bool] = None  # Add hash to filename
    force: Optional[bool] = None  # Force overwrite existing files
    minimal_output: Optional[bool] = None  # Only create main output file
    skip_output_file: Optional[bool] = None  # Skip creating main output file

    # Archive settings
    create_archive: Optional[bool] = None  # Create backup archive
    archive_type: Optional[str] = None  # 'zip' or 'tar.gz'

    # Runtime behavior
    verbose: Optional[bool] = None  # Enable verbose output
    quiet: Optional[bool] = None  # Suppress all output

    # Global include/exclude patterns
    include_patterns: List[str] = field(default_factory=list)
    exclude_patterns: List[str] = field(default_factory=list)
    include_extensions: List[str] = field(default_factory=list)
    exclude_extensions: List[str] = field(default_factory=list)

    # File filtering options
    include_dot_paths: Optional[bool] = None
    include_binary_files: Optional[bool] = None
    include_symlinks: Optional[bool] = None
    no_default_excludes: Optional[bool] = None
    max_file_size: Optional[str] = None  # e.g., "50KB", "10MB"
    exclude_paths_file: Optional[Union[str, List[str]]] = None
    include_paths_file: Optional[Union[str, List[str]]] = None

    # Processing options
    remove_scraped_metadata: Optional[bool] = None
    abort_on_encoding_error: Optional[bool] = None

    # Security options
    security_check: Optional[str] = None  # 'abort', 'skip', 'warn'

    # Extension-specific defaults
    extension_settings: Dict[str, FilePreset] = field(default_factory=dict)


@dataclass
class PresetGroup:
    """A group of presets with shared configuration."""

    name: str
    description: str = ""
    base_path: Optional[Path] = None

    # File presets by name
    file_presets: Dict[str, FilePreset] = field(default_factory=dict)

    # Default preset for unmatched files
    default_preset: Optional[FilePreset] = None

    # Group-level settings
    enabled: bool = True
    priority: int = 0  # Higher priority groups are checked first

    # Global settings for this group
    global_settings: Optional[GlobalSettings] = None

    def get_preset_for_file(self, file_path: Path) -> Optional[FilePreset]:
        """Get the appropriate preset for a file, merging with global settings."""
        if not self.enabled:
            return None

        # First, check for specific preset match
        matched_preset = None

        # Check each preset's patterns
        for preset_name, preset in self.file_presets.items():
            # Check extensions
            if preset.extensions:
                if file_path.suffix.lower() in [
                    ext.lower() if ext.startswith(".") else f".{ext.lower()}"
                    for ext in preset.extensions
                ]:
                    logger.debug(
                        f"File {file_path} matched extension in preset {preset_name}"
                    )
                    matched_preset = preset
                    break

            # Check patterns
            if preset.patterns:
                for pattern in preset.patterns:
                    if fnmatch.fnmatch(str(file_path), pattern):
                        logger.debug(
                            f"File {file_path} matched pattern '{pattern}' in preset {preset_name}"
                        )
                        matched_preset = preset
                        break

            if matched_preset:
                break

        # If no specific match, use default
        if not matched_preset:
            matched_preset = self.default_preset
            if matched_preset:
                logger.debug(f"Using default preset for {file_path}")

        # Now merge with global settings if available
        if matched_preset and self.global_settings:
            return self._merge_with_globals(matched_preset, file_path)

        return matched_preset

    def _merge_with_globals(self, preset: FilePreset, file_path: Path) -> FilePreset:
        """Merge preset with global extension settings."""
        # Check for global extension defaults
        global_preset = None
        ext = file_path.suffix.lower()
        if ext in self.global_settings.extension_settings:
            global_preset = self.global_settings.extension_settings[ext]

        if not global_preset:
            # No global extension settings to merge
            return preset

        # Create merged preset - local settings override global
        from dataclasses import replace

        merged = replace(preset)

        # Merge actions (local takes precedence if defined)
        if not merged.actions and global_preset.actions:
            merged.actions = global_preset.actions.copy()

        # Merge strip_tags (local overrides)
        if not merged.strip_tags and global_preset.strip_tags:
            merged.strip_tags = global_preset.strip_tags.copy()

        # Merge preserve_tags (combine lists)
        if global_preset.preserve_tags:
            if merged.preserve_tags:
                merged.preserve_tags = list(
                    set(merged.preserve_tags + global_preset.preserve_tags)
                )
            else:
                merged.preserve_tags = global_preset.preserve_tags.copy()

        # Other settings - local always overrides
        if merged.separator_style is None and global_preset.separator_style:
            merged.separator_style = global_preset.separator_style

        if merged.max_lines is None and global_preset.max_lines:
            merged.max_lines = global_preset.max_lines

        return merged


class PresetManager:
    """Manages loading and applying presets."""

    def __init__(self):
        self.groups: Dict[str, PresetGroup] = {}
        self._builtin_processors = self._register_builtin_processors()
        self._merged_global_settings: Optional[GlobalSettings] = None

    def load_preset_file(self, preset_path: Path) -> None:
        """Load presets from a YAML file."""
        # Reset cached merged settings when loading new files
        self._merged_global_settings = None
        
        try:
            with open(preset_path, "r", encoding="utf-8") as f:
                data = yaml.safe_load(f)

            if not isinstance(data, dict):
                raise ValueError(
                    f"Preset file must contain a dictionary, got {type(data)}"
                )

            # Load each group
            for group_name, group_data in data.items():
                if not isinstance(group_data, dict):
                    logger.warning(f"Skipping invalid group {group_name}")
                    continue

                group = self._parse_group(group_name, group_data)
                self.groups[group_name] = group
                logger.debug(
                    f"Loaded preset group '{group_name}' with {len(group.file_presets)} presets"
                )

        except Exception as e:
            logger.error(f"Failed to load preset file {preset_path}: {e}")
            raise

    def _parse_group(self, name: str, data: Dict[str, Any]) -> PresetGroup:
        """Parse a preset group from configuration."""
        group = PresetGroup(
            name=name,
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            priority=data.get("priority", 0),
        )

        # Parse base path
        if "base_path" in data:
            group.base_path = Path(data["base_path"])

        # Parse global settings
        if "global_settings" in data:
            global_data = data["global_settings"]
            group.global_settings = GlobalSettings()

            # Parse general settings
            if "encoding" in global_data:
                group.global_settings.encoding = global_data["encoding"]
            if "separator_style" in global_data:
                group.global_settings.separator_style = global_data["separator_style"]
            if "line_ending" in global_data:
                group.global_settings.line_ending = global_data["line_ending"]
            
            # Parse input/output settings
            if "source_directory" in global_data:
                group.global_settings.source_directory = global_data["source_directory"]
            if "input_file" in global_data:
                group.global_settings.input_file = global_data["input_file"]
            if "output_file" in global_data:
                group.global_settings.output_file = global_data["output_file"]
            if "input_include_files" in global_data:
                group.global_settings.input_include_files = global_data["input_include_files"]
            
            # Parse output control settings
            if "add_timestamp" in global_data:
                group.global_settings.add_timestamp = global_data["add_timestamp"]
            if "filename_mtime_hash" in global_data:
                group.global_settings.filename_mtime_hash = global_data["filename_mtime_hash"]
            if "force" in global_data:
                group.global_settings.force = global_data["force"]
            if "minimal_output" in global_data:
                group.global_settings.minimal_output = global_data["minimal_output"]
            if "skip_output_file" in global_data:
                group.global_settings.skip_output_file = global_data["skip_output_file"]
            
            # Parse archive settings
            if "create_archive" in global_data:
                group.global_settings.create_archive = global_data["create_archive"]
            if "archive_type" in global_data:
                group.global_settings.archive_type = global_data["archive_type"]
            
            # Parse runtime behavior
            if "verbose" in global_data:
                group.global_settings.verbose = global_data["verbose"]
            if "quiet" in global_data:
                group.global_settings.quiet = global_data["quiet"]

            # Parse include/exclude patterns
            if "include_patterns" in global_data:
                group.global_settings.include_patterns = global_data["include_patterns"]
            if "exclude_patterns" in global_data:
                group.global_settings.exclude_patterns = global_data["exclude_patterns"]
            if "include_extensions" in global_data:
                group.global_settings.include_extensions = global_data[
                    "include_extensions"
                ]
            if "exclude_extensions" in global_data:
                group.global_settings.exclude_extensions = global_data[
                    "exclude_extensions"
                ]

            # Parse file filtering options
            if "include_dot_paths" in global_data:
                group.global_settings.include_dot_paths = global_data[
                    "include_dot_paths"
                ]
            if "include_binary_files" in global_data:
                group.global_settings.include_binary_files = global_data[
                    "include_binary_files"
                ]
            if "include_symlinks" in global_data:
                group.global_settings.include_symlinks = global_data["include_symlinks"]
            if "no_default_excludes" in global_data:
                group.global_settings.no_default_excludes = global_data[
                    "no_default_excludes"
                ]
            if "max_file_size" in global_data:
                group.global_settings.max_file_size = global_data["max_file_size"]
            if "exclude_paths_file" in global_data:
                group.global_settings.exclude_paths_file = global_data[
                    "exclude_paths_file"
                ]
            if "include_paths_file" in global_data:
                group.global_settings.include_paths_file = global_data[
                    "include_paths_file"
                ]

            # Parse processing options
            if "remove_scraped_metadata" in global_data:
                group.global_settings.remove_scraped_metadata = global_data[
                    "remove_scraped_metadata"
                ]
            if "abort_on_encoding_error" in global_data:
                group.global_settings.abort_on_encoding_error = global_data[
                    "abort_on_encoding_error"
                ]

            # Parse security options
            if "security_check" in global_data:
                group.global_settings.security_check = global_data["security_check"]

            # Parse extension-specific settings
            if "extensions" in global_data:
                for ext, preset_data in global_data["extensions"].items():
                    # Normalize extension
                    ext = ext.lower() if ext.startswith(".") else f".{ext.lower()}"
                    group.global_settings.extension_settings[ext] = (
                        FilePreset.from_dict(preset_data)
                    )

        # Parse file presets
        presets_data = data.get("presets", {})
        for preset_name, preset_data in presets_data.items():
            if preset_name == "default":
                group.default_preset = FilePreset.from_dict(preset_data)
            else:
                group.file_presets[preset_name] = FilePreset.from_dict(preset_data)

        return group

    def get_preset_for_file(
        self, file_path: Path, group_name: Optional[str] = None
    ) -> Optional[FilePreset]:
        """Get the appropriate preset for a file."""
        # If specific group requested
        if group_name:
            if group_name in self.groups:
                return self.groups[group_name].get_preset_for_file(file_path)
            else:
                logger.warning(f"Preset group '{group_name}' not found")
                return None

        # Check all groups by priority
        sorted_groups = sorted(
            self.groups.values(), key=lambda g: g.priority, reverse=True
        )

        for group in sorted_groups:
            preset = group.get_preset_for_file(file_path)
            if preset:
                return preset

        return None

    def get_global_settings(self) -> Optional[GlobalSettings]:
        """Get merged global settings from all loaded preset groups."""
        if self._merged_global_settings is not None:
            return self._merged_global_settings

        # Sort groups by priority (highest first)
        sorted_groups = sorted(
            self.groups.values(), key=lambda g: g.priority, reverse=True
        )

        # Merge global settings from all groups
        merged = GlobalSettings()

        for group in sorted_groups:  # Process higher priority first
            if not group.enabled or not group.global_settings:
                continue

            gs = group.global_settings

            # Merge general settings (first non-None value wins due to priority order)
            if gs.encoding and merged.encoding is None:
                merged.encoding = gs.encoding
            if gs.separator_style and merged.separator_style is None:
                merged.separator_style = gs.separator_style
            if gs.line_ending and merged.line_ending is None:
                merged.line_ending = gs.line_ending
            
            # Merge input/output settings
            if gs.source_directory and merged.source_directory is None:
                merged.source_directory = gs.source_directory
            if gs.input_file and merged.input_file is None:
                merged.input_file = gs.input_file
            if gs.output_file and merged.output_file is None:
                merged.output_file = gs.output_file
            if gs.input_include_files and merged.input_include_files is None:
                merged.input_include_files = gs.input_include_files
            
            # Merge output control settings
            if gs.add_timestamp is not None and merged.add_timestamp is None:
                merged.add_timestamp = gs.add_timestamp
            if gs.filename_mtime_hash is not None and merged.filename_mtime_hash is None:
                merged.filename_mtime_hash = gs.filename_mtime_hash
            if gs.force is not None and merged.force is None:
                merged.force = gs.force
            if gs.minimal_output is not None and merged.minimal_output is None:
                merged.minimal_output = gs.minimal_output
            if gs.skip_output_file is not None and merged.skip_output_file is None:
                merged.skip_output_file = gs.skip_output_file
            
            # Merge archive settings
            if gs.create_archive is not None and merged.create_archive is None:
                merged.create_archive = gs.create_archive
            if gs.archive_type and merged.archive_type is None:
                merged.archive_type = gs.archive_type
            
            # Merge runtime behavior
            if gs.verbose is not None and merged.verbose is None:
                merged.verbose = gs.verbose
            if gs.quiet is not None and merged.quiet is None:
                merged.quiet = gs.quiet

            # Merge patterns (combine lists)
            merged.include_patterns.extend(gs.include_patterns)
            merged.exclude_patterns.extend(gs.exclude_patterns)
            merged.include_extensions.extend(gs.include_extensions)
            merged.exclude_extensions.extend(gs.exclude_extensions)

            # Merge file filtering options (higher priority overrides)
            if gs.include_dot_paths is not None and merged.include_dot_paths is None:
                merged.include_dot_paths = gs.include_dot_paths
            if gs.include_binary_files is not None and merged.include_binary_files is None:
                merged.include_binary_files = gs.include_binary_files
            if gs.include_symlinks is not None and merged.include_symlinks is None:
                merged.include_symlinks = gs.include_symlinks
            if gs.no_default_excludes is not None and merged.no_default_excludes is None:
                merged.no_default_excludes = gs.no_default_excludes
            if gs.max_file_size and merged.max_file_size is None:
                merged.max_file_size = gs.max_file_size
            if gs.exclude_paths_file and merged.exclude_paths_file is None:
                merged.exclude_paths_file = gs.exclude_paths_file
            if gs.include_paths_file and merged.include_paths_file is None:
                merged.include_paths_file = gs.include_paths_file

            # Merge processing options
            if gs.remove_scraped_metadata is not None and merged.remove_scraped_metadata is None:
                merged.remove_scraped_metadata = gs.remove_scraped_metadata
            if gs.abort_on_encoding_error is not None and merged.abort_on_encoding_error is None:
                merged.abort_on_encoding_error = gs.abort_on_encoding_error

            # Merge security options
            if gs.security_check and merged.security_check is None:
                merged.security_check = gs.security_check

            # Merge extension settings (higher priority overrides)
            for ext, preset in gs.extension_settings.items():
                if ext not in merged.extension_settings:
                    merged.extension_settings[ext] = preset

        # Remove duplicates from lists
        merged.include_patterns = list(set(merged.include_patterns))
        merged.exclude_patterns = list(set(merged.exclude_patterns))
        merged.include_extensions = list(set(merged.include_extensions))
        merged.exclude_extensions = list(set(merged.exclude_extensions))

        self._merged_global_settings = merged
        return merged

    def process_content(self, content: str, preset: FilePreset, file_path: Path) -> str:
        """Apply preset processing to file content."""
        if not preset.actions:
            return content

        for action in preset.actions:
            if action == ProcessingAction.NONE:
                continue
            elif action == ProcessingAction.MINIFY:
                content = self._minify_content(content, file_path)
            elif action == ProcessingAction.STRIP_TAGS:
                content = self._strip_tags(
                    content, preset.strip_tags, preset.preserve_tags
                )
            elif action == ProcessingAction.STRIP_COMMENTS:
                content = self._strip_comments(content, file_path)
            elif action == ProcessingAction.COMPRESS_WHITESPACE:
                content = self._compress_whitespace(content)
            elif action == ProcessingAction.REMOVE_EMPTY_LINES:
                content = self._remove_empty_lines(content)
            elif action == ProcessingAction.JOIN_PARAGRAPHS:
                content = self._join_paragraphs(content)
            elif action == ProcessingAction.CUSTOM:
                content = self._apply_custom_processor(
                    content, preset.custom_processor, preset.processor_args, file_path
                )

        # Apply line limit if specified
        if preset.max_lines:
            lines = content.splitlines()
            if len(lines) > preset.max_lines:
                content = "\n".join(lines[: preset.max_lines])
                content += f"\n... (truncated after {preset.max_lines} lines)"

        return content

    def get_file_specific_settings(self, file_path: Path) -> Optional[Dict[str, Any]]:
        """Get file-specific settings (security_check, max_file_size, etc.) for a file."""
        # Get the preset for this file
        preset = self.get_preset_for_file(file_path)
        if not preset:
            return None

        # Collect file-specific settings
        settings = {}

        if preset.security_check is not None:
            settings["security_check"] = preset.security_check
        if preset.max_file_size is not None:
            settings["max_file_size"] = preset.max_file_size
        if preset.include_dot_paths is not None:
            settings["include_dot_paths"] = preset.include_dot_paths
        if preset.include_binary_files is not None:
            settings["include_binary_files"] = preset.include_binary_files
        if preset.remove_scraped_metadata is not None:
            settings["remove_scraped_metadata"] = preset.remove_scraped_metadata

        return settings if settings else None

    def _minify_content(self, content: str, file_path: Path) -> str:
        """Minify content based on file type."""
        ext = file_path.suffix.lower()

        if ext in [".html", ".htm"]:
            # Basic HTML minification
            import re

            # Remove comments
            content = re.sub(r"<!--.*?-->", "", content, flags=re.DOTALL)
            # Remove unnecessary whitespace
            content = re.sub(r"\s+", " ", content)
            content = re.sub(r">\s+<", "><", content)
        elif ext in [".css"]:
            # Basic CSS minification
            import re

            content = re.sub(r"/\*.*?\*/", "", content, flags=re.DOTALL)
            content = re.sub(r"\s+", " ", content)
            content = re.sub(r";\s*}", "}", content)
        elif ext in [".js"]:
            # Very basic JS minification (be careful!)
            lines = content.splitlines()
            minified = []
            for line in lines:
                line = line.strip()
                if line and not line.startswith("//"):
                    minified.append(line)
            content = " ".join(minified)

        return content.strip()

    def _strip_tags(
        self, content: str, tags_to_strip: List[str], preserve_tags: List[str]
    ) -> str:
        """Strip HTML tags from content."""
        # If no specific tags provided, strip all tags
        if not tags_to_strip:
            # Use a simple regex to strip all HTML tags
            import re

            return re.sub(r"<[^>]+>", "", content)

        try:
            from bs4 import BeautifulSoup

            soup = BeautifulSoup(content, "html.parser")

            for tag in tags_to_strip:
                for element in soup.find_all(tag):
                    if preserve_tags and element.name in preserve_tags:
                        continue
                    element.decompose()

            return str(soup)
        except ImportError:
            logger.warning(
                "BeautifulSoup not installed - using regex fallback for tag stripping"
            )
            # Fallback to regex-based stripping
            import re

            for tag in tags_to_strip:
                if tag not in preserve_tags:
                    # Remove opening and closing tags
                    pattern = rf"<{tag}[^>]*>.*?</{tag}>"
                    content = re.sub(
                        pattern, "", content, flags=re.DOTALL | re.IGNORECASE
                    )
                    # Remove self-closing tags
                    pattern = rf"<{tag}[^>]*/?>"
                    content = re.sub(pattern, "", content, flags=re.IGNORECASE)
            return content

    def _strip_comments(self, content: str, file_path: Path) -> str:
        """Strip comments based on file type."""
        ext = file_path.suffix.lower()

        if ext in [".py"]:
            lines = content.splitlines()
            result = []
            in_docstring = False
            docstring_char = None

            for line in lines:
                stripped = line.strip()

                # Handle docstrings
                if '"""' in line or "'''" in line:
                    if not in_docstring:
                        in_docstring = True
                        docstring_char = '"""' if '"""' in line else "'''"
                    elif docstring_char in line:
                        in_docstring = False
                        docstring_char = None

                # Skip comment lines (but not in docstrings)
                if not in_docstring and stripped.startswith("#"):
                    continue

                # Remove inline comments
                if not in_docstring and "#" in line:
                    # Simple approach - might need refinement
                    line = line.split("#")[0].rstrip()

                result.append(line)

            content = "\n".join(result)

        elif ext in [".js", ".java", ".c", ".cpp"]:
            # Remove single-line comments
            import re

            content = re.sub(r"//.*$", "", content, flags=re.MULTILINE)
            # Remove multi-line comments
            content = re.sub(r"/\*.*?\*/", "", content, flags=re.DOTALL)

        return content

    def _compress_whitespace(self, content: str) -> str:
        """Compress multiple whitespace characters."""
        import re

        # Replace multiple spaces with single space
        content = re.sub(r" +", " ", content)
        # Replace multiple newlines with double newline
        content = re.sub(r"\n\n+", "\n\n", content)
        return content

    def _remove_empty_lines(self, content: str) -> str:
        """Remove empty lines from content."""
        lines = content.splitlines()
        non_empty = [line for line in lines if line.strip()]
        return "\n".join(non_empty)

    def _join_paragraphs(self, content: str) -> str:
        """Join multi-line paragraphs into single lines for markdown files."""
        lines = content.splitlines()
        result = []
        current_paragraph = []
        in_code_block = False
        in_list = False
        list_indent = 0
        
        i = 0
        while i < len(lines):
            line = lines[i]
            stripped = line.strip()
            
            # Check for code blocks
            if stripped.startswith('```'):
                # Flush current paragraph
                if current_paragraph:
                    result.append(' '.join(current_paragraph))
                    current_paragraph = []
                
                # Add code block as-is
                result.append(line)
                in_code_block = not in_code_block
                i += 1
                continue
            
            # If in code block, add line as-is
            if in_code_block:
                result.append(line)
                i += 1
                continue
            
            # Check for indented code block (4 spaces or tab)
            if line.startswith('    ') or line.startswith('\t'):
                # Flush current paragraph
                if current_paragraph:
                    result.append(' '.join(current_paragraph))
                    current_paragraph = []
                result.append(line)
                i += 1
                continue
            
            # Check for tables
            if '|' in line and (i == 0 or i > 0 and '|' in lines[i-1]):
                # Flush current paragraph
                if current_paragraph:
                    result.append(' '.join(current_paragraph))
                    current_paragraph = []
                result.append(line)
                i += 1
                continue
            
            # Check for horizontal rules
            if stripped in ['---', '***', '___'] or (
                len(stripped) >= 3 and 
                all(c in '-*_' for c in stripped) and 
                len(set(stripped)) == 1
            ):
                # Flush current paragraph
                if current_paragraph:
                    result.append(' '.join(current_paragraph))
                    current_paragraph = []
                result.append(line)
                i += 1
                continue
            
            # Check for headings
            if stripped.startswith('#'):
                # Flush current paragraph
                if current_paragraph:
                    result.append(' '.join(current_paragraph))
                    current_paragraph = []
                # Add heading on single line
                result.append(stripped)
                i += 1
                continue
            
            # Check for blockquotes
            if stripped.startswith('>'):
                # Flush current paragraph
                if current_paragraph:
                    result.append(' '.join(current_paragraph))
                    current_paragraph = []
                
                # Collect all consecutive blockquote lines
                blockquote_lines = []
                while i < len(lines) and lines[i].strip().startswith('>'):
                    # Remove the > prefix and join
                    content = lines[i].strip()[1:].strip()
                    if content:
                        blockquote_lines.append(content)
                    i += 1
                
                if blockquote_lines:
                    result.append('> ' + ' '.join(blockquote_lines))
                continue
            
            # Check for list items
            import re
            list_pattern = re.match(r'^(\s*)([-*+]|\d+\.)\s+(.*)$', line)
            if list_pattern:
                # Flush current paragraph
                if current_paragraph:
                    result.append(' '.join(current_paragraph))
                    current_paragraph = []
                
                indent = list_pattern.group(1)
                marker = list_pattern.group(2)
                content = list_pattern.group(3)
                
                # Collect multi-line list item
                list_item_lines = [content] if content else []
                i += 1
                
                # Look for continuation lines
                while i < len(lines):
                    next_line = lines[i]
                    next_stripped = next_line.strip()
                    
                    # Check if it's a new list item or other block element
                    if (re.match(r'^\s*[-*+]\s+', next_line) or 
                        re.match(r'^\s*\d+\.\s+', next_line) or
                        next_stripped.startswith('#') or
                        next_stripped.startswith('>') or
                        next_stripped.startswith('```') or
                        next_stripped in ['---', '***', '___'] or
                        not next_stripped):
                        break
                    
                    # It's a continuation of the current list item
                    if next_line.startswith(' ' * (len(indent) + 2)) or next_line.startswith('\t'):
                        # Remove the indentation and add to current item
                        continuation = next_line[len(indent) + 2:].strip()
                        if continuation:
                            list_item_lines.append(continuation)
                        i += 1
                    else:
                        break
                
                # Join the list item content
                joined_content = ' '.join(list_item_lines) if list_item_lines else ''
                result.append(f"{indent}{marker} {joined_content}")
                continue
            
            # Empty line - flush current paragraph
            if not stripped:
                if current_paragraph:
                    result.append(' '.join(current_paragraph))
                    current_paragraph = []
                # Don't add empty lines
                i += 1
                continue
            
            # Regular paragraph line
            current_paragraph.append(stripped)
            i += 1
        
        # Flush any remaining paragraph
        if current_paragraph:
            result.append(' '.join(current_paragraph))
        
        return '\n'.join(result)

    def _apply_custom_processor(
        self, content: str, processor_name: str, args: Dict[str, Any], file_path: Path
    ) -> str:
        """Apply a custom processor."""
        if processor_name in self._builtin_processors:
            return self._builtin_processors[processor_name](content, args, file_path)
        else:
            logger.warning(f"Unknown custom processor: {processor_name}")
            return content

    def _register_builtin_processors(self) -> Dict[str, callable]:
        """Register built-in custom processors."""
        return {
            "truncate": self._processor_truncate,
            "redact_secrets": self._processor_redact_secrets,
            "extract_functions": self._processor_extract_functions,
        }

    def _processor_truncate(
        self, content: str, args: Dict[str, Any], file_path: Path
    ) -> str:
        """Truncate content to specified length."""
        max_chars = args.get("max_chars", 1000)
        if len(content) > max_chars:
            return content[:max_chars] + f"\n... (truncated at {max_chars} chars)"
        return content

    def _processor_redact_secrets(
        self, content: str, args: Dict[str, Any], file_path: Path
    ) -> str:
        """Redact potential secrets."""
        import re

        patterns = args.get(
            "patterns",
            [
                r'(?i)(api[_-]?key|secret|password|token)\s*[:=]\s*["\']?[\w-]+["\']?',
                r"(?i)bearer\s+[\w-]+",
            ],
        )

        for pattern in patterns:
            content = re.sub(pattern, "[REDACTED]", content)

        return content

    def _processor_extract_functions(
        self, content: str, args: Dict[str, Any], file_path: Path
    ) -> str:
        """Extract only function definitions."""
        if file_path.suffix.lower() != ".py":
            return content

        import ast

        try:
            tree = ast.parse(content)
            functions = []

            for node in ast.walk(tree):
                if isinstance(node, ast.FunctionDef):
                    # Get function source
                    start_line = node.lineno - 1
                    end_line = node.end_lineno
                    lines = content.splitlines()
                    func_lines = lines[start_line:end_line]
                    functions.append("\n".join(func_lines))

            return "\n\n".join(functions) if functions else "# No functions found"
        except:
            return content


# Convenience function
def load_presets(
    preset_paths: Union[Path, List[Path]], auto_load_user_presets: bool = True
) -> PresetManager:
    """Load presets from one or more files."""
    from .config_loader import PresetConfigLoader

    manager = PresetManager()

    # Convert single path to list
    if isinstance(preset_paths, Path):
        preset_paths = [preset_paths]
    elif not preset_paths:
        preset_paths = []

    # Get all preset files to load
    all_preset_files = PresetConfigLoader.load_all_presets(
        project_presets=preset_paths,
        include_global=auto_load_user_presets,
        include_user=auto_load_user_presets,
    )

    # Load each file
    for path in all_preset_files:
        if path.exists():
            manager.load_preset_file(path)
            logger.debug(f"Loaded preset file: {path}")
        else:
            logger.warning(f"Preset file not found: {path}")

    return manager


def list_loaded_presets(manager: PresetManager) -> str:
    """Generate a summary of loaded presets."""
    lines = ["Loaded Preset Groups:"]

    # Sort by priority
    sorted_groups = sorted(
        manager.groups.items(), key=lambda x: x[1].priority, reverse=True
    )

    for name, group in sorted_groups:
        status = "enabled" if group.enabled else "disabled"
        lines.append(f"\n{name} (priority: {group.priority}, {status})")
        if group.description:
            lines.append(f"  Description: {group.description}")

        # Show global settings
        if group.globals and group.globals.extension_defaults:
            lines.append("  Global extensions:")
            for ext, preset in group.globals.extension_defaults.items():
                actions = (
                    [a.value for a in preset.actions] if preset.actions else ["none"]
                )
                lines.append(f"    {ext}: {', '.join(actions)}")

        # Show presets
        if group.file_presets:
            lines.append("  Presets:")
            for preset_name, preset in group.file_presets.items():
                if preset.extensions:
                    lines.append(f"    {preset_name}: {', '.join(preset.extensions)}")
                elif preset.patterns:
                    lines.append(f"    {preset_name}: {preset.patterns[0]}...")

    return "\n".join(lines)

======= m1f/security_scanner.py | CHECKSUM_SHA256: fdb0bbea4b75ffa1f3146dbc2ea91e1de1e3bb3bf361f302fbbedc40fe95978f ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Security scanner module for detecting sensitive information in files.
"""

from __future__ import annotations

import asyncio
import re
from pathlib import Path
from typing import List, Tuple, Dict

from .config import Config
from .logging import LoggerManager

# Try to import detect_secrets
try:
    from detect_secrets.core.scan import scan_file
    from detect_secrets.settings import get_settings, default_settings
    import detect_secrets.plugins

    DETECT_SECRETS_AVAILABLE = True
except Exception:
    DETECT_SECRETS_AVAILABLE = False


class SecurityScanner:
    """Handles security scanning for sensitive information."""

    # Regex patterns for fallback detection
    SENSITIVE_PATTERNS = [
        re.compile(r'password\s*[=:]\s*["\']?[\w\-\.]+["\']?', re.IGNORECASE),
        re.compile(r'passwd\s*[=:]\s*["\']?[\w\-\.]+["\']?', re.IGNORECASE),
        re.compile(r'pwd\s*[=:]\s*["\']?[\w\-\.]+["\']?', re.IGNORECASE),
        re.compile(r'secret[_-]?key\s*[=:]\s*["\']?[\w\-\.]+["\']?', re.IGNORECASE),
        re.compile(r'api[_-]?key\s*[=:]\s*["\']?[\w\-\.]+["\']?', re.IGNORECASE),
        re.compile(r'apikey\s*[=:]\s*["\']?[\w\-\.]+["\']?', re.IGNORECASE),
        re.compile(r'token\s*[=:]\s*["\']?[\w\-\.]+["\']?', re.IGNORECASE),
        re.compile(r'auth[_-]?token\s*[=:]\s*["\']?[\w\-\.]+["\']?', re.IGNORECASE),
        re.compile(r'access[_-]?token\s*[=:]\s*["\']?[\w\-\.]+["\']?', re.IGNORECASE),
        re.compile(r'private[_-]?key\s*[=:]\s*["\']?[\w\-\.]+["\']?', re.IGNORECASE),
        re.compile(
            r'aws[_-]?access[_-]?key[_-]?id\s*[=:]\s*["\']?[\w\-\.]+["\']?',
            re.IGNORECASE,
        ),
        re.compile(
            r'aws[_-]?secret[_-]?access[_-]?key\s*[=:]\s*["\']?[\w\-\.]+["\']?',
            re.IGNORECASE,
        ),
    ]

    def __init__(self, config: Config, logger_manager: LoggerManager):
        self.config = config
        self.logger = logger_manager.get_logger(__name__)
        self.preset_manager = None  # Will be set by core.py if available

        if DETECT_SECRETS_AVAILABLE:
            self.logger.info("Security scanning will use 'detect-secrets' library")
            # Initialize detect-secrets
            try:
                get_settings()
            except Exception as e:
                self.logger.warning(f"Failed to initialize detect-secrets: {e}")
        else:
            self.logger.info(
                "'detect-secrets' not available. Using regex-based scanning"
            )

    async def scan_files(
        self, files_to_process: List[Tuple[Path, str]]
    ) -> List[Dict[str, any]]:
        """Scan files for sensitive information."""
        if not self.config.security.security_check:
            return []

        self.logger.info("Starting security scan...")

        findings = []

        for file_path, rel_path in files_to_process:
            file_findings = await self._scan_single_file(file_path, rel_path)
            findings.extend(file_findings)

        if findings:
            self.logger.warning(f"Security scan found {len(findings)} potential issues")
        else:
            self.logger.info("Security scan completed. No issues found")

        return findings

    async def _scan_single_file(
        self, file_path: Path, rel_path: str
    ) -> List[Dict[str, any]]:
        """Scan a single file for sensitive information."""
        findings = []

        # Check if file has specific security_check override
        if self.preset_manager:
            file_settings = self.preset_manager.get_file_specific_settings(file_path)
            if file_settings and "security_check" in file_settings:
                security_check = file_settings["security_check"]
                if security_check is None or security_check == "null":
                    # Security check disabled for this file type
                    self.logger.debug(
                        f"Security check disabled for {file_path} by preset"
                    )
                    return []
                # Note: We could also handle file-specific abort/skip/warn here if needed

        if DETECT_SECRETS_AVAILABLE:
            # Use detect-secrets
            try:
                with default_settings():
                    secrets_collection = scan_file(str(file_path))

                    for secret in secrets_collection:
                        findings.append(
                            {
                                "path": rel_path,
                                "type": secret.type,
                                "line": secret.line_number,
                                "message": f"Detected '{secret.type}' on line {secret.line_number}",
                            }
                        )

            except Exception as e:
                self.logger.warning(f"detect-secrets failed on {file_path}: {e}")
                # Fall back to regex scanning
                findings.extend(await self._regex_scan_file(file_path, rel_path))
        else:
            # Use regex-based scanning
            findings.extend(await self._regex_scan_file(file_path, rel_path))

        return findings

    async def _regex_scan_file(
        self, file_path: Path, rel_path: str
    ) -> List[Dict[str, any]]:
        """Scan a file using regex patterns."""
        findings = []

        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                lines = f.readlines()

            for line_num, line in enumerate(lines, 1):
                for pattern in self.SENSITIVE_PATTERNS:
                    if pattern.search(line):
                        # Try to determine the type of secret
                        secret_type = self._determine_secret_type(line)

                        findings.append(
                            {
                                "path": rel_path,
                                "type": secret_type,
                                "line": line_num,
                                "message": f"Potential {secret_type} detected on line {line_num}",
                            }
                        )
                        break  # Only report once per line

        except Exception as e:
            self.logger.warning(f"Could not scan {file_path} for security: {e}")

        return findings

    def _determine_secret_type(self, line: str) -> str:
        """Determine the type of secret based on the line content."""
        line_lower = line.lower()

        if any(word in line_lower for word in ["password", "passwd", "pwd"]):
            return "Password"
        elif "api" in line_lower and "key" in line_lower:
            return "API Key"
        elif "secret" in line_lower and "key" in line_lower:
            return "Secret Key"
        elif "token" in line_lower:
            return "Auth Token"
        elif "private" in line_lower and "key" in line_lower:
            return "Private Key"
        elif "aws" in line_lower:
            return "AWS Credential"
        else:
            return "Secret"

======= m1f/separator_generator.py | CHECKSUM_SHA256: 005e68b9a84ad29af973785f196dd568b0e231cae9144167ca07104990b590ff ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Separator generator module for creating file separators in various styles.
"""

from __future__ import annotations

import json
import uuid
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional

from .config import Config, SeparatorStyle
from .constants import MACHINE_READABLE_BOUNDARY_PREFIX
from .encoding_handler import EncodingInfo
from .logging import LoggerManager
from .utils import format_file_size, calculate_checksum


class SeparatorGenerator:
    """Generates file separators in various styles."""

    def __init__(self, config: Config, logger_manager: LoggerManager):
        self.config = config
        self.logger = logger_manager.get_logger(__name__)
        self._current_uuid: Optional[str] = None

    async def generate_separator(
        self,
        file_path: Path,
        rel_path: str,
        encoding_info: EncodingInfo,
        file_content: str,
    ) -> str:
        """Generate a file separator based on the configured style."""
        style = self.config.output.separator_style
        linesep = self.config.output.line_ending.value

        if style == SeparatorStyle.NONE:
            return ""

        # Gather file metadata
        metadata = self._gather_metadata(file_path, rel_path, encoding_info)

        # Calculate checksum if needed
        checksum = ""
        if style in [
            SeparatorStyle.STANDARD,
            SeparatorStyle.DETAILED,
            SeparatorStyle.MARKDOWN,
            SeparatorStyle.MACHINE_READABLE,
        ]:
            checksum = calculate_checksum(file_content)

        # Generate separator based on style
        if style == SeparatorStyle.STANDARD:
            return self._generate_standard(metadata, checksum)
        elif style == SeparatorStyle.DETAILED:
            return self._generate_detailed(metadata, checksum, linesep)
        elif style == SeparatorStyle.MARKDOWN:
            return self._generate_markdown(file_path, metadata, checksum, linesep)
        elif style == SeparatorStyle.MACHINE_READABLE:
            return self._generate_machine_readable(metadata, checksum, linesep)
        else:
            return f"--- {rel_path} ---"

    async def generate_closing_separator(self) -> Optional[str]:
        """Generate a closing separator if needed."""
        style = self.config.output.separator_style

        if style == SeparatorStyle.NONE:
            return ""
        elif style == SeparatorStyle.MARKDOWN:
            return "```"
        elif style == SeparatorStyle.MACHINE_READABLE and self._current_uuid:
            return f"--- {MACHINE_READABLE_BOUNDARY_PREFIX}_END_FILE_CONTENT_BLOCK_{self._current_uuid} ---"

        return None

    def _gather_metadata(
        self, file_path: Path, rel_path: str, encoding_info: EncodingInfo
    ) -> dict:
        """Gather metadata about the file."""
        try:
            stat_info = file_path.stat()
            mod_time = datetime.fromtimestamp(stat_info.st_mtime)

            return {
                "relative_path": rel_path,
                "mod_date_str": mod_time.strftime("%Y-%m-%d %H:%M:%S"),
                "file_size_bytes": stat_info.st_size,
                "file_size_hr": format_file_size(stat_info.st_size),
                "file_ext": (
                    file_path.suffix.lower() if file_path.suffix else "[no extension]"
                ),
                "display_encoding": encoding_info.original_encoding,
                "encoding": encoding_info.target_encoding
                or encoding_info.original_encoding,
                "original_encoding": encoding_info.original_encoding,
                "had_encoding_errors": encoding_info.had_errors,
                "stat_info": stat_info,
            }
        except Exception as e:
            self.logger.warning(f"Could not get metadata for {file_path}: {e}")
            return {
                "relative_path": rel_path,
                "mod_date_str": "[unknown]",
                "file_size_bytes": 0,
                "file_size_hr": "[unknown]",
                "file_ext": (
                    file_path.suffix.lower() if file_path.suffix else "[no extension]"
                ),
                "display_encoding": encoding_info.original_encoding,
                "encoding": encoding_info.target_encoding
                or encoding_info.original_encoding,
                "original_encoding": encoding_info.original_encoding,
                "had_encoding_errors": encoding_info.had_errors,
                "stat_info": None,
            }

    def _generate_standard(self, metadata: dict, checksum: str) -> str:
        """Generate Standard style separator."""
        if checksum:
            return f"======= {metadata['relative_path']} | CHECKSUM_SHA256: {checksum} ======"
        return f"======= {metadata['relative_path']} ======"

    def _generate_detailed(self, metadata: dict, checksum: str, linesep: str) -> str:
        """Generate Detailed style separator."""
        separator_lines = [
            "=" * 88,
            f"== FILE: {metadata['relative_path']}",
            f"== DATE: {metadata['mod_date_str']} | SIZE: {metadata['file_size_hr']} | TYPE: {metadata['file_ext']}",
        ]

        # Add encoding information if available
        if metadata["display_encoding"]:
            encoding_status = f"ENCODING: {metadata['display_encoding']}"
            if (
                metadata["encoding"]
                and metadata["original_encoding"]
                and metadata["encoding"] != metadata["original_encoding"]
            ):
                encoding_status += f" (converted to {metadata['encoding']})"
            if metadata["had_encoding_errors"]:
                encoding_status += " (with conversion errors)"
            separator_lines.append(f"== {encoding_status}")

        if checksum:
            separator_lines.append(f"== CHECKSUM_SHA256: {checksum}")

        separator_lines.append("=" * 88)
        return linesep.join(separator_lines)

    def _generate_markdown(
        self, file_path: Path, metadata: dict, checksum: str, linesep: str
    ) -> str:
        """Generate Markdown style separator."""
        # Determine language hint for syntax highlighting
        md_lang_hint = (
            file_path.suffix[1:]
            if file_path.suffix and len(file_path.suffix) > 1
            else ""
        )

        metadata_line = f"**Date Modified:** {metadata['mod_date_str']} | **Size:** {metadata['file_size_hr']} | **Type:** {metadata['file_ext']}"

        # Add encoding information if available
        if metadata["display_encoding"]:
            encoding_status = f"**Encoding:** {metadata['display_encoding']}"
            if (
                metadata["encoding"]
                and metadata["original_encoding"]
                and metadata["encoding"] != metadata["original_encoding"]
            ):
                encoding_status += f" (converted to {metadata['encoding']})"
            if metadata["had_encoding_errors"]:
                encoding_status += " (with conversion errors)"
            metadata_line += f" | {encoding_status}"

        if checksum:
            metadata_line += f" | **Checksum (SHA256):** {checksum}"

        separator_lines = [
            f"## {metadata['relative_path']}",
            metadata_line,
            "",  # Empty line before code block
            f"```{md_lang_hint}",
        ]
        return linesep.join(separator_lines)

    def _generate_machine_readable(
        self, metadata: dict, checksum: str, linesep: str
    ) -> str:
        """Generate MachineReadable style separator."""
        # Generate new UUID for this file
        self._current_uuid = str(uuid.uuid4())

        # Create metadata for the file
        meta = {
            "original_filepath": str(metadata["relative_path"]),
            "original_filename": Path(metadata["relative_path"]).name,
            "timestamp_utc_iso": datetime.fromtimestamp(
                metadata["stat_info"].st_mtime if metadata["stat_info"] else 0,
                tz=timezone.utc,
            )
            .isoformat()
            .replace("+00:00", "Z"),
            "type": metadata["file_ext"],
            "size_bytes": metadata["file_size_bytes"],
            "checksum_sha256": checksum if checksum else "",
        }

        # Add encoding information
        if metadata["original_encoding"]:
            meta["encoding"] = self._normalize_encoding_name(
                metadata["original_encoding"]
            )

            if metadata["encoding"] != metadata["original_encoding"]:
                meta["target_encoding"] = self._normalize_encoding_name(
                    metadata["encoding"]
                )

        if metadata["had_encoding_errors"]:
            meta["had_encoding_errors"] = True

        json_meta = json.dumps(meta, indent=4)

        separator_lines = [
            f"--- {MACHINE_READABLE_BOUNDARY_PREFIX}_BEGIN_FILE_METADATA_BLOCK_{self._current_uuid} ---",
            "METADATA_JSON:",
            json_meta,
            f"--- {MACHINE_READABLE_BOUNDARY_PREFIX}_END_FILE_METADATA_BLOCK_{self._current_uuid} ---",
            f"--- {MACHINE_READABLE_BOUNDARY_PREFIX}_BEGIN_FILE_CONTENT_BLOCK_{self._current_uuid} ---",
            "",
        ]
        return linesep.join(separator_lines)

    def _normalize_encoding_name(self, encoding_name: str) -> str:
        """Normalize encoding names to canonical forms."""
        if not encoding_name:
            return encoding_name

        enc_lower = encoding_name.lower()

        # Map common encoding name variants
        encoding_map = {
            "utf_8": "utf-8",
            "utf8": "utf-8",
            "utf-8": "utf-8",
            "utf_16": "utf-16",
            "utf16": "utf-16",
            "utf-16": "utf-16",
            "utf_16_le": "utf-16-le",
            "utf16le": "utf-16-le",
            "utf-16-le": "utf-16-le",
            "utf_16_be": "utf-16-be",
            "utf16be": "utf-16-be",
            "utf-16-be": "utf-16-be",
            "latin_1": "latin-1",
            "latin1": "latin-1",
            "latin-1": "latin-1",
            "iso_8859_1": "latin-1",
            "iso-8859-1": "latin-1",
            "cp1252": "windows-1252",
            "windows_1252": "windows-1252",
            "windows-1252": "windows-1252",
        }

        return encoding_map.get(enc_lower, encoding_name)

======= m1f/utils.py | CHECKSUM_SHA256: 8a47743ea0a409cbec53d96a94781512b896dee92e1545857bf16e3ea401c441 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Utility functions for m1f.
"""

from __future__ import annotations

import hashlib
import re
from pathlib import Path
from typing import Union, List, Tuple


def format_duration(seconds: float) -> str:
    """Format duration in seconds to a human-readable string."""
    if seconds < 60:
        return f"{seconds:.2f} seconds"
    elif seconds < 3600:
        minutes = seconds / 60
        return f"{minutes:.2f} minutes"
    else:
        hours = seconds / 3600
        return f"{hours:.2f} hours"


def format_file_size(size_bytes: int) -> str:
    """Format file size in bytes to human-readable string."""
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.2f} KB"
    elif size_bytes < 1024 * 1024 * 1024:
        return f"{size_bytes / (1024 * 1024):.2f} MB"
    else:
        return f"{size_bytes / (1024 * 1024 * 1024):.2f} GB"


def calculate_checksum(content: str) -> str:
    """Calculate SHA-256 checksum of content."""
    return hashlib.sha256(content.encode("utf-8")).hexdigest()


def is_binary_file(file_path: Path) -> bool:
    """Check if a file is likely binary based on its content."""
    # Common binary extensions
    binary_extensions = {
        # Images
        ".jpg",
        ".jpeg",
        ".png",
        ".gif",
        ".bmp",
        ".tiff",
        ".tif",
        ".ico",
        ".webp",
        ".svgz",
        # Audio
        ".mp3",
        ".wav",
        ".ogg",
        ".flac",
        ".aac",
        ".wma",
        ".m4a",
        # Video
        ".mp4",
        ".avi",
        ".mkv",
        ".mov",
        ".wmv",
        ".flv",
        ".webm",
        ".mpeg",
        ".mpg",
        # Archives
        ".zip",
        ".rar",
        ".7z",
        ".tar",
        ".gz",
        ".bz2",
        ".xz",
        ".jar",
        ".war",
        ".ear",
        # Executables
        ".exe",
        ".dll",
        ".so",
        ".dylib",
        ".bin",
        ".msi",
        ".pdb",
        ".lib",
        ".o",
        ".obj",
        ".pyc",
        ".pyo",
        ".class",
        # Documents
        ".pdf",
        ".doc",
        ".ppt",
        ".xls",
        # Databases
        ".db",
        ".sqlite",
        ".mdb",
        ".accdb",
        ".dbf",
        ".dat",
        # Fonts
        ".ttf",
        ".otf",
        ".woff",
        ".woff2",
        ".eot",
        # Others
        ".iso",
        ".img",
        ".vhd",
        ".vhdx",
        ".vmdk",
        ".bak",
        ".tmp",
        ".lock",
        ".swo",
        ".swp",
    }

    # Check by extension first
    if file_path.suffix.lower() in binary_extensions:
        return True

    # Try reading first few bytes
    try:
        with open(file_path, "rb") as f:
            # Read first 1024 bytes
            chunk = f.read(1024)

            # Check for null bytes
            if b"\0" in chunk:
                return True

            # Try to decode as UTF-8
            try:
                chunk.decode("utf-8")
                return False
            except UnicodeDecodeError:
                return True

    except Exception:
        # If we can't read the file, assume it's binary
        return True


def normalize_path(path: Union[str, Path]) -> Path:
    """Normalize a path to use forward slashes and resolve it."""
    return Path(path).resolve()


def is_hidden_path(path: Path) -> bool:
    """Check if a path (file or directory) is hidden."""
    # Check if any part of the path starts with a dot
    for part in path.parts:
        if part.startswith(".") and part not in (".", ".."):
            return True
    return False


def get_relative_path(file_path: Path, base_path: Path) -> str:
    """Get relative path from base path, handling edge cases."""
    try:
        return str(file_path.relative_to(base_path))
    except ValueError:
        # If file is not under base path, return absolute path
        return str(file_path)


def parse_file_size(size_str: str) -> int:
    """Parse a file size string and return size in bytes.

    Supports formats like:
    - 1024 (bytes)
    - 10KB, 10K
    - 1.5MB, 1.5M
    - 2GB, 2G
    - 500TB, 500T

    Args:
        size_str: String representation of file size

    Returns:
        Size in bytes

    Raises:
        ValueError: If the size string cannot be parsed
    """
    if not size_str:
        raise ValueError("Empty size string")

    # Remove whitespace and convert to uppercase
    size_str = size_str.strip().upper()

    # Match number followed by optional unit
    pattern = r"^(\d+(?:\.\d+)?)\s*([KMGTB]?B?)?$"
    match = re.match(pattern, size_str)

    if not match:
        raise ValueError(f"Invalid size format: {size_str}")

    number = float(match.group(1))
    unit = match.group(2) or ""

    # Handle unit suffixes
    multipliers = {
        "": 1,
        "B": 1,
        "K": 1024,
        "KB": 1024,
        "M": 1024**2,
        "MB": 1024**2,
        "G": 1024**3,
        "GB": 1024**3,
        "T": 1024**4,
        "TB": 1024**4,
    }

    if unit not in multipliers:
        raise ValueError(f"Unknown size unit: {unit}")

    return int(number * multipliers[unit])


def sort_directories_by_depth_and_name(directories: List[str]) -> List[str]:
    """Sort directory paths by depth (ascending) and name.

    Sorting rules:
    1. Directories higher in the tree come first (lower depth)
    2. Within the same depth level, sort alphabetically

    Args:
        directories: List of directory path strings

    Returns:
        Sorted list of directory paths
    """

    def sort_key(dir_path: str) -> Tuple[int, str]:
        path_obj = Path(dir_path)

        # Calculate depth (number of path components)
        depth = len(path_obj.parts)

        # Return sort key tuple: (depth, lowercase_path)
        return (depth, dir_path.lower())

    return sorted(directories, key=sort_key)


def sort_files_by_depth_and_name(
    file_paths: List[Tuple[Path, str]],
) -> List[Tuple[Path, str]]:
    """Sort file paths by depth (ascending) and name, with README.md prioritized.

    Sorting rules:
    1. Files higher in the directory tree come first (lower depth)
    2. Within the same directory:
       - README.md (case-insensitive) always comes first
       - Other files are sorted alphabetically

    Args:
        file_paths: List of tuples (full_path, relative_path)

    Returns:
        Sorted list of file path tuples
    """

    def sort_key(item: Tuple[Path, str]) -> Tuple[int, str, int, str]:
        full_path, rel_path = item
        path_obj = Path(rel_path)

        # Calculate depth (number of path components)
        depth = len(path_obj.parts)

        # Get parent directory path
        parent = str(path_obj.parent)

        # Get filename
        filename = path_obj.name

        # Check if this is README.md (case-insensitive)
        is_not_readme = 0 if filename.lower() == "readme.md" else 1

        # Return sort key tuple:
        # (depth, parent_path, is_not_readme, lowercase_filename)
        return (depth, parent.lower(), is_not_readme, filename.lower())

    return sorted(file_paths, key=sort_key)

======= s1f/__init__.py | CHECKSUM_SHA256: bfcd862db57c7a677a07f3a38bd8285f36bf234a8071edf9205f25279ccad83d ======
"""
s1f - Split One File
====================

A modern Python tool to split a combined file (created by m1f) back into individual files.
"""

try:
    from .._version import __version__, __version_info__
except ImportError:
    # Fallback when running as standalone script
    __version__ = "3.1.0"
    __version_info__ = (3, 1, 0)

__author__ = "Franz und Franz (https://franz.agency)"
__project__ = "https://m1f.dev"

from .exceptions import S1FError
from .cli import main

__all__ = [
    "S1FError",
    "main",
    "__version__",
    "__version_info__",
    "__author__",
    "__project__",
]

======= s1f/__main__.py | CHECKSUM_SHA256: b8052cea2bc539ef7bb546956bf356316945943571fe80164a8c727568694fec ======
# Copyright 2025 Franz und Franz GmbH
# SPDX-License-Identifier: Apache-2.0

"""Allow the s1f package to be run as a module."""

import sys
from .cli import main

if __name__ == "__main__":
    sys.exit(main())

======= s1f/cli.py | CHECKSUM_SHA256: c87cc0b4fc6476628d7007ca16ac5756f92e3ece8868a78cd62145d1ecb099d8 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Command-line interface for s1f."""

import argparse
import asyncio
import sys
from pathlib import Path
from typing import Optional, Sequence

from . import __version__, __project__
from .config import Config
from .core import FileSplitter
from .logging import setup_logging
from .exceptions import ConfigurationError


def create_argument_parser() -> argparse.ArgumentParser:
    """Create and configure the argument parser."""
    parser = argparse.ArgumentParser(
        description="s1f - Split combined files back into original files",
        epilog=f"""Examples:
  # Extract files from archive
  s1f archive.m1f.txt ./output/
  
  # List files without extracting
  s1f --list archive.m1f.txt
  
  # Extract with original encoding
  s1f archive.m1f.txt ./output/ --respect-encoding
  
Project home: {__project__}""",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    # Support both positional and option-style arguments for backward compatibility
    # Option-style (for backward compatibility)
    parser.add_argument(
        "-i",
        "--input-file",
        type=Path,
        dest="input_file_opt",
        help="Path to the combined file (m1f output)",
    )

    parser.add_argument(
        "-d",
        "--destination-directory",
        type=Path,
        dest="destination_directory_opt",
        help="Directory where files will be extracted",
    )

    # Positional arguments (new style)
    parser.add_argument(
        "input_file",
        type=Path,
        nargs="?",
        help="Path to the combined file (m1f output)",
    )

    parser.add_argument(
        "destination_directory",
        type=Path,
        nargs="?",
        help="Directory where files will be extracted",
    )

    # Optional arguments
    parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="Overwrite existing files without prompting",
    )

    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Enable verbose output for debugging",
    )

    parser.add_argument(
        "-l",
        "--list",
        action="store_true",
        help="List files in the archive without extracting",
    )

    parser.add_argument(
        "--version",
        action="version",
        version=f"s1f {__version__}",
        help="Show version information and exit",
    )

    # Timestamp handling
    timestamp_group = parser.add_mutually_exclusive_group()
    timestamp_group.add_argument(
        "--timestamp-mode",
        choices=["original", "current"],
        default="original",
        help="How to set file timestamps (default: %(default)s)",
    )

    # Checksum handling
    parser.add_argument(
        "--ignore-checksum",
        action="store_true",
        help="Skip checksum verification",
    )

    # Encoding handling
    encoding_group = parser.add_argument_group("encoding options")
    encoding_group.add_argument(
        "--respect-encoding",
        action="store_true",
        help="Write files using their original encoding (when available)",
    )

    encoding_group.add_argument(
        "--target-encoding",
        type=str,
        help="Force all files to be written with this encoding (e.g., 'utf-8', 'latin-1')",
    )

    return parser


def validate_args(args: argparse.Namespace) -> None:
    """Validate command-line arguments."""
    # Handle backward compatibility for option-style arguments
    if args.input_file_opt:
        args.input_file = args.input_file_opt
    if args.destination_directory_opt:
        args.destination_directory = args.destination_directory_opt

    # Ensure required arguments are provided
    if not args.input_file:
        raise ConfigurationError("Missing required argument: input_file")
    if not args.list and not args.destination_directory:
        raise ConfigurationError("Missing required argument: destination_directory")

    # Check if input file exists
    if not args.input_file.exists():
        raise ConfigurationError(f"Input file does not exist: {args.input_file}")

    if not args.input_file.is_file():
        raise ConfigurationError(f"Input path is not a file: {args.input_file}")

    # Validate encoding options
    if args.target_encoding and args.respect_encoding:
        raise ConfigurationError(
            "Cannot use both --target-encoding and --respect-encoding"
        )

    # Validate target encoding if specified
    if args.target_encoding:
        try:
            # Test if the encoding is valid
            "test".encode(args.target_encoding)
        except LookupError:
            raise ConfigurationError(f"Unknown encoding: {args.target_encoding}")


async def async_main(argv: Optional[Sequence[str]] = None) -> int:
    """Async main entry point."""
    # Parse arguments
    parser = create_argument_parser()
    args = parser.parse_args(argv)

    try:
        # Validate arguments
        validate_args(args)

        # Create configuration
        config = Config.from_args(args)

        # Setup logging
        logger_manager = setup_logging(config)

        # Create file splitter
        splitter = FileSplitter(config, logger_manager)

        # Run in list mode or extraction mode
        if args.list:
            result, exit_code = await splitter.list_files()
        else:
            result, exit_code = await splitter.split_file()

        # Cleanup
        await logger_manager.cleanup()

        return exit_code

    except ConfigurationError as e:
        print(f"Error: {e}", file=sys.stderr)
        return e.exit_code
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.", file=sys.stderr)
        return 130
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback

            traceback.print_exc()
        return 1


def main(argv: Optional[Sequence[str]] = None) -> int:
    """Main entry point."""
    return asyncio.run(async_main(argv))


if __name__ == "__main__":
    sys.exit(main())

======= s1f/config.py | CHECKSUM_SHA256: d5583a46700a646adcbb7b21b2cf24f81442d5efa500a2bcf7b0ac9fbaa9b04f ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Configuration for s1f."""

from dataclasses import dataclass
from pathlib import Path
from typing import Optional
from argparse import Namespace


@dataclass
class Config:
    """Configuration for the s1f file splitter."""

    input_file: Path
    destination_directory: Optional[Path] = None
    force_overwrite: bool = False
    verbose: bool = False
    timestamp_mode: str = "original"
    ignore_checksum: bool = False
    respect_encoding: bool = False
    target_encoding: Optional[str] = None

    def __post_init__(self):
        """Validate configuration after initialization."""
        # Ensure paths are Path objects
        self.input_file = Path(self.input_file)
        if self.destination_directory is not None:
            self.destination_directory = Path(self.destination_directory)

        # Validate timestamp mode
        if self.timestamp_mode not in ["original", "current"]:
            raise ValueError(f"Invalid timestamp_mode: {self.timestamp_mode}")

    @classmethod
    def from_args(cls, args: Namespace) -> "Config":
        """Create configuration from command line arguments."""
        return cls(
            input_file=Path(args.input_file),
            destination_directory=(
                Path(args.destination_directory) if args.destination_directory else None
            ),
            force_overwrite=args.force,
            verbose=args.verbose,
            timestamp_mode=args.timestamp_mode,
            ignore_checksum=args.ignore_checksum,
            respect_encoding=args.respect_encoding,
            target_encoding=args.target_encoding,
        )

    @property
    def output_encoding(self) -> str:
        """Determine the default output encoding based on configuration."""
        if self.target_encoding:
            return self.target_encoding
        return "utf-8"

======= s1f/core.py | CHECKSUM_SHA256: ae1122b33a79bbfe97d2d228a4b8946f86221ad5660ca7fe10e4c1836e82a873 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Core file splitter functionality for s1f."""

import time
from pathlib import Path
from typing import List, Optional, Tuple
import logging

from .config import Config
from .models import ExtractedFile, ExtractionResult
from .parsers import CombinedFileParser
from .writers import FileWriter
from .utils import format_size, is_binary_content
from .exceptions import FileParsingError, S1FError
from .logging import LoggerManager


class FileSplitter:
    """Main class for splitting combined files back into individual files."""

    def __init__(self, config: Config, logger_manager: LoggerManager):
        self.config = config
        self.logger_manager = logger_manager
        self.logger = logger_manager.get_logger(__name__)
        self.parser = CombinedFileParser(self.logger)
        self.writer = FileWriter(config, self.logger)

    async def list_files(self) -> Tuple[ExtractionResult, int]:
        """List files in the combined file without extracting.

        Returns:
            Tuple of (ExtractionResult, exit_code)
        """
        start_time = time.time()

        try:
            # Read the input file
            content = await self._read_input_file()

            # Parse the content
            self.logger.info("Parsing combined file...")
            extracted_files = self.parser.parse(content)

            if not extracted_files:
                self.logger.error("No files found in the combined file.")
                return ExtractionResult(), 2

            # Display file list
            print(
                f"\nFound {len(extracted_files)} file(s) in {self.config.input_file}:\n"
            )

            total_size = 0
            for i, file in enumerate(extracted_files, 1):
                meta = file.metadata
                size_str = (
                    format_size(meta.size_bytes) if meta.size_bytes else "Unknown"
                )

                # Build info line
                info_parts = [f"{i:4d}. {meta.path}"]
                info_parts.append(f"[{size_str}]")

                if meta.checksum_sha256:
                    info_parts.append(f"SHA256: {meta.checksum_sha256[:16]}...")

                if meta.encoding:
                    info_parts.append(f"Encoding: {meta.encoding}")

                if meta.type:
                    info_parts.append(f"Type: {meta.type}")

                print("  ".join(info_parts))

                if meta.size_bytes:
                    total_size += meta.size_bytes

            print(f"\nTotal size: {format_size(total_size)}")

            result = ExtractionResult(
                files_created=0,
                files_overwritten=0,
                files_failed=0,
                execution_time=time.time() - start_time,
            )

            return result, 0

        except S1FError as e:
            self.logger.error(f"Error: {e}")
            return (
                ExtractionResult(execution_time=time.time() - start_time),
                e.exit_code,
            )
        except KeyboardInterrupt:
            self.logger.info("\nOperation cancelled by user.")
            return ExtractionResult(execution_time=time.time() - start_time), 130
        except Exception as e:
            self.logger.error(f"Unexpected error: {e}")
            if self.config.verbose:
                import traceback

                self.logger.debug(traceback.format_exc())
            return ExtractionResult(execution_time=time.time() - start_time), 1

    async def split_file(self) -> Tuple[ExtractionResult, int]:
        """Split the combined file into individual files.

        Returns:
            Tuple of (ExtractionResult, exit_code)
        """
        start_time = time.time()

        try:
            # Read the input file
            content = await self._read_input_file()

            # Parse the content
            self.logger.info("Parsing combined file...")
            extracted_files = self.parser.parse(content)

            if not extracted_files:
                self.logger.error("No files found in the combined file.")
                return ExtractionResult(), 2

            self.logger.info(f"Found {len(extracted_files)} file(s) to extract")

            # Ensure destination directory exists
            self.config.destination_directory.mkdir(parents=True, exist_ok=True)

            # Write the files
            result = await self.writer.write_files(extracted_files)

            # Set execution time
            result.execution_time = time.time() - start_time

            # Log summary
            self._log_summary(result)

            # Determine exit code
            if result.files_failed > 0:
                exit_code = 1
            else:
                exit_code = 0

            return result, exit_code

        except S1FError as e:
            self.logger.error(f"Error: {e}")
            return (
                ExtractionResult(execution_time=time.time() - start_time),
                e.exit_code,
            )
        except KeyboardInterrupt:
            self.logger.info("\nOperation cancelled by user.")
            return ExtractionResult(execution_time=time.time() - start_time), 130
        except Exception as e:
            self.logger.error(f"Unexpected error: {e}")
            if self.config.verbose:
                import traceback

                self.logger.debug(traceback.format_exc())
            return ExtractionResult(execution_time=time.time() - start_time), 1

    async def _read_input_file(self) -> str:
        """Read the input file content."""
        if not self.config.input_file.exists():
            raise FileParsingError(
                f"Input file '{self.config.input_file}' does not exist.",
                str(self.config.input_file),
            )

        try:
            # First, try to detect if the file is binary
            sample_bytes = self.config.input_file.read_bytes()[:8192]
            if is_binary_content(sample_bytes):
                raise FileParsingError(
                    f"Input file '{self.config.input_file}' appears to be binary.",
                    str(self.config.input_file),
                )

            # Try to read with UTF-8 first
            try:
                content = self.config.input_file.read_text(encoding="utf-8")
            except UnicodeDecodeError:
                # Try with latin-1 as fallback (can decode any byte sequence)
                self.logger.warning(
                    f"Failed to decode '{self.config.input_file}' as UTF-8, "
                    f"trying latin-1 encoding..."
                )
                content = self.config.input_file.read_text(encoding="latin-1")

            # Check if the file is empty
            if not content.strip():
                raise FileParsingError(
                    f"Input file '{self.config.input_file}' is empty.",
                    str(self.config.input_file),
                )

            file_size = self.config.input_file.stat().st_size
            self.logger.info(
                f"Read input file '{self.config.input_file}' "
                f"({format_size(file_size)})"
            )

            return content

        except (IOError, OSError) as e:
            raise FileParsingError(
                f"Failed to read input file '{self.config.input_file}': {e}",
                str(self.config.input_file),
            )

    def _log_summary(self, result: ExtractionResult):
        """Log extraction summary."""
        self.logger.info("")
        self.logger.info("=== Extraction Summary ===")
        self.logger.info(f"Files created:     {result.files_created}")
        self.logger.info(f"Files overwritten: {result.files_overwritten}")

        if result.files_failed > 0:
            self.logger.error(f"Files failed:      {result.files_failed}")
        else:
            self.logger.info(f"Files failed:      {result.files_failed}")

        self.logger.info(f"Total processed:   {result.total_files}")
        self.logger.info(f"Success rate:      {result.success_rate:.1f}%")
        self.logger.info(f"Time taken:        {result.execution_time:.2f} seconds")
        self.logger.info("")

        if result.files_failed == 0 and result.total_files > 0:
            self.logger.info("✓ All files extracted successfully!")
        elif result.files_failed > 0:
            self.logger.error(
                f"✗ Extraction completed with {result.files_failed} error(s). "
                f"Check the logs above for details."
            )


# Alias for backward compatibility with tests
S1FExtractor = FileSplitter

======= s1f/exceptions.py | CHECKSUM_SHA256: b9c6419f88cc54a73c827859125e7f5829359caaa108eca01016881f8a729276 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Custom exceptions for s1f."""

from typing import Optional


class S1FError(Exception):
    """Base exception for all s1f errors."""

    def __init__(self, message: str, exit_code: int = 1):
        super().__init__(message)
        self.exit_code = exit_code


class FileParsingError(S1FError):
    """Raised when file parsing fails."""

    def __init__(self, message: str, file_path: Optional[str] = None):
        super().__init__(message, exit_code=2)
        self.file_path = file_path


class FileWriteError(S1FError):
    """Raised when file writing fails."""

    def __init__(self, message: str, file_path: Optional[str] = None):
        super().__init__(message, exit_code=3)
        self.file_path = file_path


class ConfigurationError(S1FError):
    """Raised when configuration is invalid."""

    def __init__(self, message: str):
        super().__init__(message, exit_code=4)


class ChecksumMismatchError(S1FError):
    """Raised when checksum verification fails."""

    def __init__(self, file_path: str, expected: str, actual: str):
        message = (
            f"Checksum mismatch for {file_path}: expected {expected}, got {actual}"
        )
        super().__init__(message, exit_code=5)
        self.file_path = file_path
        self.expected_checksum = expected
        self.actual_checksum = actual

======= s1f/logging.py | CHECKSUM_SHA256: 9b507eddbc3de36bc6ef44c1f698d42ae71bfd55abf138982aeaeb5ddf065822 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Logging configuration for s1f."""

import logging
import sys
from dataclasses import dataclass
from typing import Optional, Dict, Any, List
from pathlib import Path

try:
    from colorama import init, Fore, Style

    COLORAMA_AVAILABLE = True
    init(autoreset=True)
except ImportError:
    COLORAMA_AVAILABLE = False


@dataclass
class LogLevel:
    """Log level configuration."""

    name: str
    value: int
    color: Optional[str] = None


LOG_LEVELS = {
    "DEBUG": LogLevel(
        "DEBUG", logging.DEBUG, Fore.BLUE if COLORAMA_AVAILABLE else None
    ),
    "INFO": LogLevel("INFO", logging.INFO, Fore.GREEN if COLORAMA_AVAILABLE else None),
    "WARNING": LogLevel(
        "WARNING", logging.WARNING, Fore.YELLOW if COLORAMA_AVAILABLE else None
    ),
    "ERROR": LogLevel("ERROR", logging.ERROR, Fore.RED if COLORAMA_AVAILABLE else None),
    "CRITICAL": LogLevel(
        "CRITICAL", logging.CRITICAL, Fore.RED if COLORAMA_AVAILABLE else None
    ),
}


class ColoredFormatter(logging.Formatter):
    """Custom formatter that adds color to log messages."""

    def format(self, record: logging.LogRecord) -> str:
        """Format the log record with colors if available."""
        if COLORAMA_AVAILABLE:
            # Get the appropriate color for the log level
            level_name = record.levelname
            if level_name in LOG_LEVELS and LOG_LEVELS[level_name].color:
                color = LOG_LEVELS[level_name].color
                record.levelname = f"{color}{level_name}{Style.RESET_ALL}"

        return super().format(record)


class LoggerManager:
    """Manages logging configuration and logger instances."""

    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        self.loggers: Dict[str, logging.Logger] = {}
        self._setup_root_logger()

    def _setup_root_logger(self):
        """Setup the root logger with appropriate handlers."""
        root_logger = logging.getLogger()
        root_logger.setLevel(logging.DEBUG if self.verbose else logging.INFO)

        # Remove existing handlers
        for handler in root_logger.handlers[:]:
            root_logger.removeHandler(handler)

        # Create console handler
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(logging.DEBUG if self.verbose else logging.INFO)

        # Set formatter
        if COLORAMA_AVAILABLE:
            formatter = ColoredFormatter("%(levelname)-8s: %(message)s")
        else:
            formatter = logging.Formatter("%(levelname)-8s: %(message)s")

        console_handler.setFormatter(formatter)
        root_logger.addHandler(console_handler)

    def get_logger(self, name: str) -> logging.Logger:
        """Get or create a logger with the given name."""
        if name not in self.loggers:
            logger = logging.getLogger(name)
            self.loggers[name] = logger
        return self.loggers[name]

    async def cleanup(self):
        """Cleanup logging resources."""
        # Nothing to cleanup for now, but might be needed in the future
        pass


def setup_logging(config) -> LoggerManager:
    """Setup logging based on configuration."""
    return LoggerManager(verbose=config.verbose)


def get_logger(name: str) -> logging.Logger:
    """Get a logger instance."""
    return logging.getLogger(name)

======= s1f/models.py | CHECKSUM_SHA256: 18629e7a454bd5250b72f24120d95cc84682ea799e07acfbb8de776e533711df ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Data models for s1f."""

from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any


@dataclass
class FileMetadata:
    """Metadata for an extracted file."""

    path: str
    checksum_sha256: Optional[str] = None
    size_bytes: Optional[int] = None
    modified: Optional[datetime] = None
    encoding: Optional[str] = None
    line_endings: Optional[str] = None
    type: Optional[str] = None
    had_encoding_errors: bool = False


@dataclass
class ExtractedFile:
    """Represents a file extracted from the combined file."""

    metadata: FileMetadata
    content: str

    @property
    def path(self) -> str:
        """Convenience property for accessing the file path."""
        return self.metadata.path


@dataclass
class ExtractionResult:
    """Result of the extraction process."""

    files_created: int = 0
    files_overwritten: int = 0
    files_failed: int = 0
    execution_time: float = 0.0

    @property
    def total_files(self) -> int:
        """Total number of files processed."""
        return self.files_created + self.files_overwritten + self.files_failed

    @property
    def success_rate(self) -> float:
        """Percentage of successfully processed files."""
        if self.total_files == 0:
            return 0.0
        return (self.files_created + self.files_overwritten) / self.total_files * 100

    @property
    def extracted_count(self) -> int:
        """Total number of successfully extracted files."""
        return self.files_created + self.files_overwritten

    @property
    def success(self) -> bool:
        """Whether the extraction was successful."""
        return self.files_failed == 0 and self.extracted_count > 0


@dataclass
class SeparatorMatch:
    """Represents a matched separator in the content."""

    separator_type: str
    start_index: int
    end_index: int
    metadata: Dict[str, Any]
    header_length: int = 0
    uuid: Optional[str] = None

======= s1f/parsers.py | CHECKSUM_SHA256: f06494843bc57df7eb546df2d5093ca9a17b647b48f16c3c46c873c1d181ade1 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Parsers for different separator formats."""

import json
import re
from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Any, Pattern
from datetime import datetime
import logging

from .models import ExtractedFile, FileMetadata, SeparatorMatch
from .utils import convert_to_posix_path, parse_iso_timestamp
from .exceptions import FileParsingError


class SeparatorParser(ABC):
    """Abstract base class for separator parsers."""

    def __init__(self, logger: logging.Logger):
        self.logger = logger

    @property
    @abstractmethod
    def name(self) -> str:
        """Get the name of this parser."""
        pass

    @property
    @abstractmethod
    def pattern(self) -> Pattern:
        """Get the regex pattern for this separator type."""
        pass

    @abstractmethod
    def parse_match(
        self, match: re.Match, content: str, index: int
    ) -> Optional[SeparatorMatch]:
        """Parse a regex match into a SeparatorMatch object."""
        pass

    @abstractmethod
    def extract_content(
        self,
        content: str,
        current_match: SeparatorMatch,
        next_match: Optional[SeparatorMatch],
    ) -> str:
        """Extract file content between separators."""
        pass


class PYMK1FParser(SeparatorParser):
    """Parser for PYMK1F format with UUID-based separators."""

    PATTERN = re.compile(
        r"--- PYMK1F_BEGIN_FILE_METADATA_BLOCK_([a-f0-9-]+) ---\r?\n"
        r"METADATA_JSON:\r?\n"
        r"(\{(?:.|\s)*?\})\r?\n"
        r"--- PYMK1F_END_FILE_METADATA_BLOCK_\1 ---\r?\n"
        r"--- PYMK1F_BEGIN_FILE_CONTENT_BLOCK_\1 ---\r?\n",
        re.MULTILINE | re.DOTALL,
    )

    END_MARKER_PATTERN = "--- PYMK1F_END_FILE_CONTENT_BLOCK_{uuid} ---"

    @property
    def name(self) -> str:
        return "PYMK1F"

    @property
    def pattern(self) -> Pattern:
        return self.PATTERN

    def parse_match(
        self, match: re.Match, content: str, index: int
    ) -> Optional[SeparatorMatch]:
        """Parse a PYMK1F format match."""
        try:
            uuid = match.group(1)
            json_str = match.group(2)
            meta = json.loads(json_str)

            # Extract path from metadata
            path = meta.get("original_filepath", "").strip()
            path = convert_to_posix_path(path)

            if not path:
                self.logger.warning(
                    f"PYMK1F block at offset {match.start()} has missing or empty path"
                )
                return None

            # Parse timestamp if available
            timestamp = None
            if "timestamp_utc_iso" in meta:
                try:
                    timestamp = parse_iso_timestamp(meta["timestamp_utc_iso"])
                except ValueError as e:
                    self.logger.warning(f"Failed to parse timestamp: {e}")

            # Extract encoding info
            encoding = meta.get("encoding")
            had_errors = meta.get("had_encoding_errors", False)
            if had_errors and encoding:
                encoding += " (with conversion errors)"

            return SeparatorMatch(
                separator_type=self.name,
                start_index=match.start(),
                end_index=match.end(),
                metadata={
                    "path": path,
                    "checksum_sha256": meta.get("checksum_sha256"),
                    "size_bytes": meta.get("size_bytes"),
                    "modified": timestamp,
                    "encoding": encoding,
                    "line_endings": meta.get("line_endings", ""),
                    "type": meta.get("type"),
                },
                header_length=len(match.group(0)),
                uuid=uuid,
            )

        except json.JSONDecodeError as e:
            self.logger.warning(
                f"PYMK1F block at offset {match.start()} has invalid JSON: {e}"
            )
            return None
        except Exception as e:
            self.logger.warning(
                f"Error parsing PYMK1F block at offset {match.start()}: {e}"
            )
            return None

    def extract_content(
        self,
        content: str,
        current_match: SeparatorMatch,
        next_match: Optional[SeparatorMatch],
    ) -> str:
        """Extract content for PYMK1F format."""
        content_start = current_match.end_index

        # Find the end marker with matching UUID
        if current_match.uuid:
            end_marker = self.END_MARKER_PATTERN.format(uuid=current_match.uuid)
            end_pos = content.find(end_marker, content_start)

            if end_pos != -1:
                file_content = content[content_start:end_pos]
            else:
                self.logger.warning(
                    f"PYMK1F file '{current_match.metadata['path']}' missing end marker"
                )
                # Fallback to next separator or EOF
                if next_match:
                    file_content = content[content_start : next_match.start_index]
                else:
                    file_content = content[content_start:]
        else:
            # No UUID available
            if next_match:
                file_content = content[content_start : next_match.start_index]
            else:
                file_content = content[content_start:]

        # Apply pragmatic fix for trailing \r if needed
        if (
            current_match.metadata.get("size_bytes") is not None
            and current_match.metadata.get("checksum_sha256") is not None
        ):
            file_content = self._apply_trailing_cr_fix(
                file_content, current_match.metadata
            )

        return file_content

    def _apply_trailing_cr_fix(self, content: str, metadata: Dict[str, Any]) -> str:
        """Apply pragmatic fix for trailing \r character."""
        try:
            current_bytes = content.encode("utf-8")
            current_size = len(current_bytes)
            original_size = metadata["size_bytes"]

            if current_size == original_size + 1 and content.endswith("\r"):
                # Verify if removing \r would match the original checksum
                import hashlib

                fixed_bytes = content[:-1].encode("utf-8")
                fixed_checksum = hashlib.sha256(fixed_bytes).hexdigest()

                if (
                    fixed_checksum == metadata["checksum_sha256"]
                    and len(fixed_bytes) == original_size
                ):
                    self.logger.info(
                        f"Applied trailing \\r fix for '{metadata['path']}'"
                    )
                    return content[:-1]

        except Exception as e:
            self.logger.warning(f"Error during trailing \\r fix attempt: {e}")

        return content


class MachineReadableParser(SeparatorParser):
    """Parser for legacy MachineReadable format."""

    PATTERN = re.compile(
        r"# PYM1F-BOUNDARY-99C5F740A78D4ABC82E3F9882D5A281E\r?\n"
        r"# FILE: (.*?)\r?\n"
        r"# PYM1F-BOUNDARY-99C5F740A78D4ABC82E3F9882D5A281E\r?\n"
        r"# METADATA: (\{.*?\})\r?\n"
        r"# PYM1F-BOUNDARY-99C5F740A78D4ABC82E3F9882D5A281E\r?\n",
        re.MULTILINE,
    )

    END_MARKER_PATTERN = re.compile(
        r"# PYM1F-BOUNDARY-99C5F740A78D4ABC82E3F9882D5A281E\r?\n"
        r"# END FILE\r?\n"
        r"# PYM1F-BOUNDARY-99C5F740A78D4ABC82E3F9882D5A281E",
        re.MULTILINE,
    )

    @property
    def name(self) -> str:
        return "MachineReadable"

    @property
    def pattern(self) -> Pattern:
        return self.PATTERN

    def parse_match(
        self, match: re.Match, content: str, index: int
    ) -> Optional[SeparatorMatch]:
        """Parse a MachineReadable format match."""
        try:
            path = match.group(1).strip()
            path = convert_to_posix_path(path)

            if not path:
                self.logger.warning(
                    f"MachineReadable block at offset {match.start()} has empty path"
                )
                return None

            # Parse metadata JSON
            json_str = match.group(2)
            meta = json.loads(json_str)

            # Parse timestamp if available
            timestamp = None
            if "modified" in meta:
                try:
                    timestamp = parse_iso_timestamp(meta["modified"])
                except ValueError as e:
                    self.logger.warning(f"Failed to parse timestamp: {e}")

            # Calculate header length including potential blank line
            header_len = len(match.group(0))
            next_pos = match.end()
            if next_pos < len(content) and content[next_pos : next_pos + 2] in [
                "\r\n",
                "\n",
            ]:
                header_len += 2 if content[next_pos : next_pos + 2] == "\r\n" else 1

            return SeparatorMatch(
                separator_type=self.name,
                start_index=match.start(),
                end_index=match.end(),
                metadata={
                    "path": path,
                    "checksum_sha256": meta.get("checksum_sha256"),
                    "size_bytes": meta.get("size_bytes"),
                    "modified": timestamp,
                    "encoding": meta.get("encoding"),
                    "line_endings": meta.get("line_endings", ""),
                    "type": meta.get("type"),
                },
                header_length=header_len,
            )

        except json.JSONDecodeError as e:
            self.logger.warning(
                f"MachineReadable block at offset {match.start()} has invalid JSON: {e}"
            )
            return None
        except Exception as e:
            self.logger.warning(
                f"Error parsing MachineReadable block at offset {match.start()}: {e}"
            )
            return None

    def extract_content(
        self,
        content: str,
        current_match: SeparatorMatch,
        next_match: Optional[SeparatorMatch],
    ) -> str:
        """Extract content for MachineReadable format."""
        content_start = current_match.end_index

        # Find the end marker
        end_search = self.END_MARKER_PATTERN.search(content, content_start)

        if end_search:
            end_pos = end_search.start()
            # Check for newline before marker
            if end_pos > 1 and content[end_pos - 2 : end_pos] == "\r\n":
                end_pos -= 2
            elif end_pos > 0 and content[end_pos - 1] == "\n":
                end_pos -= 1
        else:
            self.logger.warning(
                f"MachineReadable file '{current_match.metadata['path']}' missing end marker"
            )
            # Fallback to next separator or EOF
            if next_match:
                end_pos = next_match.start_index
            else:
                end_pos = len(content)

        return content[content_start:end_pos]


class MarkdownParser(SeparatorParser):
    """Parser for Markdown format."""

    PATTERN = re.compile(
        r"^(## (.*?)$\r?\n"
        r"(?:\*\*Date Modified:\*\* .*? \| \*\*Size:\*\* .*? \| \*\*Type:\*\* .*?"
        r"(?:\s\|\s\*\*Encoding:\*\*\s(.*?)(?:\s\(with conversion errors\))?)?"
        r"(?:\s\|\s\*\*Checksum \(SHA256\):\*\*\s([0-9a-fA-F]{64}))?)$\r?\n\r?\n"
        r"```(?:.*?)$\r?\n)",
        re.MULTILINE,
    )

    @property
    def name(self) -> str:
        return "Markdown"

    @property
    def pattern(self) -> Pattern:
        return self.PATTERN

    def parse_match(
        self, match: re.Match, content: str, index: int
    ) -> Optional[SeparatorMatch]:
        """Parse a Markdown format match."""
        path = match.group(2).strip()
        path = convert_to_posix_path(path)

        if not path:
            return None

        encoding = None
        if match.group(3):
            encoding = match.group(3)

        return SeparatorMatch(
            separator_type=self.name,
            start_index=match.start(),
            end_index=match.end(),
            metadata={
                "path": path,
                "checksum_sha256": match.group(4) if match.group(4) else None,
                "encoding": encoding,
            },
            header_length=len(match.group(1)),
        )

    def extract_content(
        self,
        content: str,
        current_match: SeparatorMatch,
        next_match: Optional[SeparatorMatch],
    ) -> str:
        """Extract content for Markdown format."""
        content_start = current_match.end_index

        if next_match:
            raw_content = content[content_start : next_match.start_index]
        else:
            raw_content = content[content_start:]

        # Strip inter-file newline if not last file
        if next_match:
            if raw_content.endswith("\r\n"):
                raw_content = raw_content[:-2]
            elif raw_content.endswith("\n"):
                raw_content = raw_content[:-1]

        # Strip closing marker
        if raw_content.endswith("```\r\n"):
            return raw_content[:-5]
        elif raw_content.endswith("```\n"):
            return raw_content[:-4]
        elif raw_content.endswith("```"):
            return raw_content[:-3]
        else:
            self.logger.warning(
                f"Markdown file '{current_match.metadata['path']}' missing closing marker"
            )
            return raw_content


class DetailedParser(SeparatorParser):
    """Parser for Detailed format."""

    PATTERN = re.compile(
        r"^(========================================================================================$\r?\n"
        r"== FILE: (.*?)$\r?\n"
        r"== DATE: .*? \| SIZE: .*? \| TYPE: .*?$\r?\n"
        r"(?:== ENCODING: (.*?)(?:\s\(with conversion errors\))?$\r?\n)?"
        r"(?:== CHECKSUM_SHA256: ([0-9a-fA-F]{64})$\r?\n)?"
        r"========================================================================================$\r?\n?)",
        re.MULTILINE,
    )

    @property
    def name(self) -> str:
        return "Detailed"

    @property
    def pattern(self) -> Pattern:
        return self.PATTERN

    def parse_match(
        self, match: re.Match, content: str, index: int
    ) -> Optional[SeparatorMatch]:
        """Parse a Detailed format match."""
        path = match.group(2).strip()
        path = convert_to_posix_path(path)

        if not path:
            return None

        return SeparatorMatch(
            separator_type=self.name,
            start_index=match.start(),
            end_index=match.end(),
            metadata={
                "path": path,
                "checksum_sha256": match.group(4) if match.group(4) else None,
                "encoding": match.group(3) if match.group(3) else None,
            },
            header_length=len(match.group(1)),
        )

    def extract_content(
        self,
        content: str,
        current_match: SeparatorMatch,
        next_match: Optional[SeparatorMatch],
    ) -> str:
        """Extract content for Detailed format."""
        return self._extract_standard_format_content(content, current_match, next_match)

    def _extract_standard_format_content(
        self,
        content: str,
        current_match: SeparatorMatch,
        next_match: Optional[SeparatorMatch],
    ) -> str:
        """Extract content for Standard/Detailed formats."""
        content_start = current_match.end_index

        if next_match:
            raw_content = content[content_start : next_match.start_index]
        else:
            raw_content = content[content_start:]

        # Strip leading blank line
        if raw_content.startswith("\r\n"):
            raw_content = raw_content[2:]
        elif raw_content.startswith("\n"):
            raw_content = raw_content[1:]

        # Strip trailing inter-file newline if not last file
        if next_match:
            if raw_content.endswith("\r\n"):
                raw_content = raw_content[:-2]
            elif raw_content.endswith("\n"):
                raw_content = raw_content[:-1]

        return raw_content


class StandardParser(DetailedParser):
    """Parser for Standard format."""

    PATTERN = re.compile(
        r"======= (.*?)(?:\s*\|\s*CHECKSUM_SHA256:\s*([0-9a-fA-F]{64}))?\s*======",
        re.MULTILINE,
    )

    @property
    def name(self) -> str:
        return "Standard"

    @property
    def pattern(self) -> Pattern:
        return self.PATTERN

    def parse_match(
        self, match: re.Match, content: str, index: int
    ) -> Optional[SeparatorMatch]:
        """Parse a Standard format match."""
        path = match.group(1).strip()
        path = convert_to_posix_path(path)

        if not path:
            return None

        return SeparatorMatch(
            separator_type=self.name,
            start_index=match.start(),
            end_index=match.end(),
            metadata={
                "path": path,
                "checksum_sha256": match.group(2) if match.group(2) else None,
                "encoding": None,
            },
            header_length=0,  # Standard format doesn't have multi-line headers
        )


class CombinedFileParser:
    """Main parser that coordinates all separator parsers."""

    def __init__(self, logger: logging.Logger):
        self.logger = logger
        self.parsers = [
            PYMK1FParser(logger),
            MachineReadableParser(logger),
            MarkdownParser(logger),
            DetailedParser(logger),
            StandardParser(logger),
        ]

    def parse(self, content: str) -> List[ExtractedFile]:
        """Parse the combined file content and extract individual files."""
        # Find all matches from all parsers
        matches: List[SeparatorMatch] = []

        for parser in self.parsers:
            for match in parser.pattern.finditer(content):
                separator_match = parser.parse_match(match, content, len(matches))
                if separator_match:
                    matches.append(separator_match)

        # Sort by position in file
        matches.sort(key=lambda m: m.start_index)

        if not matches:
            self.logger.warning("No recognizable file separators found")
            return []

        # Extract files
        extracted_files: List[ExtractedFile] = []

        for i, current_match in enumerate(matches):
            # Find the appropriate parser
            parser = next(
                p for p in self.parsers if p.name == current_match.separator_type
            )

            # Get next match if available
            next_match = matches[i + 1] if i + 1 < len(matches) else None

            # Extract content
            file_content = parser.extract_content(content, current_match, next_match)

            # Create metadata
            metadata = FileMetadata(
                path=current_match.metadata["path"],
                checksum_sha256=current_match.metadata.get("checksum_sha256"),
                size_bytes=current_match.metadata.get("size_bytes"),
                modified=current_match.metadata.get("modified"),
                encoding=current_match.metadata.get("encoding"),
                line_endings=current_match.metadata.get("line_endings"),
                type=current_match.metadata.get("type"),
            )

            # Create extracted file
            extracted_file = ExtractedFile(metadata=metadata, content=file_content)
            extracted_files.append(extracted_file)

            self.logger.debug(
                f"Identified file: '{metadata.path}', type: {current_match.separator_type}, "
                f"content length: {len(file_content)}"
            )

        return extracted_files

======= s1f/utils.py | CHECKSUM_SHA256: fc0c09d935d7778e6edd8da2e3ebaf0323db37244b438cd1f08d75f5924b8845 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Utility functions for s1f."""

import hashlib
import os
from pathlib import Path, PureWindowsPath
from typing import Optional, Union
from datetime import datetime, timezone
import re


def convert_to_posix_path(path_str: Optional[str]) -> str:
    """Convert a path string to use forward slashes."""
    if path_str is None:
        return ""
    return str(path_str).replace("\\", "/")


def calculate_sha256(content: bytes) -> str:
    """Calculate SHA256 checksum of the given bytes."""
    return hashlib.sha256(content).hexdigest()


def parse_iso_timestamp(timestamp_str: str) -> datetime:
    """Parse ISO timestamp string to datetime object.

    Handles both 'Z' suffix and explicit timezone offset formats.
    """
    if timestamp_str.endswith("Z"):
        # Replace 'Z' with '+00:00' for UTC
        timestamp_str = timestamp_str[:-1] + "+00:00"

    return datetime.fromisoformat(timestamp_str)


def normalize_line_endings(content: str, target: str = "\n") -> str:
    """Normalize line endings in content.

    Args:
        content: The content to normalize
        target: The target line ending ("\n", "\r\n", or "\r")

    Returns:
        Content with normalized line endings
    """
    # First normalize all to \n
    content = content.replace("\r\n", "\n").replace("\r", "\n")

    # Then convert to target if different
    if target != "\n":
        content = content.replace("\n", target)

    return content


def get_line_ending_style(content: str) -> str:
    """Detect the predominant line ending style in content.

    Returns:
        One of: "LF", "CRLF", "CR", or "MIXED"
    """
    lf_count = content.count("\n") - content.count("\r\n")
    crlf_count = content.count("\r\n")
    cr_count = content.count("\r") - content.count("\r\n")

    if lf_count > 0 and crlf_count == 0 and cr_count == 0:
        return "LF"
    elif crlf_count > 0 and lf_count == 0 and cr_count == 0:
        return "CRLF"
    elif cr_count > 0 and lf_count == 0 and crlf_count == 0:
        return "CR"
    elif lf_count + crlf_count + cr_count > 0:
        return "MIXED"
    else:
        return "NONE"


def validate_file_path(path: Path, base_dir: Path) -> bool:
    """Validate that a file path is safe and within the base directory.

    Args:
        path: The path to validate
        base_dir: The base directory that should contain the path

    Returns:
        True if the path is valid and safe, False otherwise
    """
    try:
        # Resolve the path (but don't require it to exist)
        resolved_path = (base_dir / path).resolve()

        # Check if it's within the base directory
        resolved_path.relative_to(base_dir.resolve())

        # Check for suspicious patterns
        if ".." in path.parts:
            return False

        return True
    except ValueError:
        # relative_to() raises ValueError if path is not relative to base_dir
        return False


def format_size(size_bytes: int) -> str:
    """Format size in bytes to human-readable format."""
    for unit in ["B", "KB", "MB", "GB", "TB"]:
        if size_bytes < 1024.0:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.1f} PB"


def clean_encoding_name(encoding: str) -> str:
    """Clean up encoding name by removing error indicators."""
    if not encoding:
        return ""
    return encoding.split(" (with conversion errors)")[0].strip()


def is_binary_content(content: bytes, sample_size: int = 8192) -> bool:
    """Check if content appears to be binary.

    Args:
        content: The content to check
        sample_size: Number of bytes to sample

    Returns:
        True if content appears to be binary, False otherwise
    """
    # Sample the beginning of the content
    sample = content[:sample_size]

    # Check for null bytes (common in binary files)
    if b"\x00" in sample:
        return True

    # Check for high ratio of non-printable characters
    non_printable = sum(1 for byte in sample if byte < 32 and byte not in (9, 10, 13))

    if len(sample) > 0:
        ratio = non_printable / len(sample)
        return ratio > 0.3

    return False

======= s1f/writers.py | CHECKSUM_SHA256: 6b3674a219dbc95d59f3ea9061e63c56c0161e2a71f24eeaa6f0afb1f1eb5a51 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""File writers for s1f."""

import asyncio
import os
from pathlib import Path
from typing import List, Optional, Tuple
import logging
from datetime import datetime

from .config import Config
from .models import ExtractedFile, ExtractionResult
from .utils import (
    validate_file_path,
    calculate_sha256,
    clean_encoding_name,
    format_size,
    normalize_line_endings,
)
from .exceptions import FileWriteError, ChecksumMismatchError

try:
    import aiofiles

    AIOFILES_AVAILABLE = True
except ImportError:
    AIOFILES_AVAILABLE = False


class FileWriter:
    """Handles writing extracted files to disk."""

    def __init__(self, config: Config, logger: logging.Logger):
        self.config = config
        self.logger = logger

    async def write_files(
        self, extracted_files: List[ExtractedFile]
    ) -> ExtractionResult:
        """Write all extracted files to the destination directory."""
        result = ExtractionResult()

        self.logger.info(
            f"Writing {len(extracted_files)} extracted file(s) to '{self.config.destination_directory}'..."
        )

        # Create tasks for concurrent file writing if async is available
        if AIOFILES_AVAILABLE:
            tasks = [
                self._write_file_async(file_data, result)
                for file_data in extracted_files
            ]
            await asyncio.gather(*tasks, return_exceptions=True)
        else:
            # Fallback to synchronous writing
            for file_data in extracted_files:
                await self._write_file_sync(file_data, result)

        return result

    async def _write_file_async(
        self, file_data: ExtractedFile, result: ExtractionResult
    ):
        """Write a single file asynchronously."""
        try:
            output_path = await self._prepare_output_path(file_data)
            if output_path is None:
                result.files_failed += 1
                return

            # Check if file exists
            is_overwrite = output_path.exists()

            if is_overwrite and not self.config.force_overwrite:
                if not await self._confirm_overwrite_async(output_path):
                    self.logger.info(f"Skipping existing file '{output_path}'")
                    return

            # Determine encoding
            encoding = self._determine_encoding(file_data)

            # Write the file
            content_bytes = await self._encode_content(
                file_data.content, encoding, file_data.path
            )

            async with aiofiles.open(output_path, "wb") as f:
                await f.write(content_bytes)

            # Update result
            if is_overwrite:
                result.files_overwritten += 1
                self.logger.debug(f"Overwrote file: {output_path}")
            else:
                result.files_created += 1
                self.logger.debug(f"Created file: {output_path}")

            # Set file timestamp
            await self._set_file_timestamp(output_path, file_data)

            # Verify checksum if needed
            if not self.config.ignore_checksum and file_data.metadata.checksum_sha256:
                await self._verify_checksum_async(output_path, file_data)

        except Exception as e:
            self.logger.error(f"Failed to write file '{file_data.path}': {e}")
            result.files_failed += 1

    async def _write_file_sync(
        self, file_data: ExtractedFile, result: ExtractionResult
    ):
        """Write a single file synchronously (fallback when aiofiles not available)."""
        try:
            output_path = await self._prepare_output_path(file_data)
            if output_path is None:
                result.files_failed += 1
                return

            # Check if file exists
            is_overwrite = output_path.exists()

            if is_overwrite and not self.config.force_overwrite:
                if not self._confirm_overwrite_sync(output_path):
                    self.logger.info(f"Skipping existing file '{output_path}'")
                    return

            # Determine encoding
            encoding = self._determine_encoding(file_data)

            # Write the file
            content_bytes = await self._encode_content(
                file_data.content, encoding, file_data.path
            )
            output_path.write_bytes(content_bytes)

            # Update result
            if is_overwrite:
                result.files_overwritten += 1
                self.logger.debug(f"Overwrote file: {output_path}")
            else:
                result.files_created += 1
                self.logger.debug(f"Created file: {output_path}")

            # Set file timestamp
            await self._set_file_timestamp(output_path, file_data)

            # Verify checksum if needed
            if not self.config.ignore_checksum and file_data.metadata.checksum_sha256:
                self._verify_checksum_sync(output_path, file_data)

        except Exception as e:
            self.logger.error(f"Failed to write file '{file_data.path}': {e}")
            result.files_failed += 1

    async def _prepare_output_path(self, file_data: ExtractedFile) -> Optional[Path]:
        """Prepare the output path for a file."""
        relative_path = Path(file_data.path)

        # Validate path security
        if not validate_file_path(relative_path, self.config.destination_directory):
            self.logger.error(
                f"Skipping file '{file_data.path}' due to invalid path components"
            )
            return None

        output_path = self.config.destination_directory / relative_path

        # Create parent directories
        try:
            output_path.parent.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            self.logger.error(f"Failed to create directory for '{file_data.path}': {e}")
            return None

        self.logger.debug(f"Preparing to write: {output_path}")
        return output_path

    def _determine_encoding(self, file_data: ExtractedFile) -> str:
        """Determine the encoding to use for writing a file."""
        # Priority 1: Explicit target encoding from config
        if self.config.target_encoding:
            return self.config.target_encoding

        # Priority 2: Original encoding if respect_encoding is True
        if self.config.respect_encoding and file_data.metadata.encoding:
            clean_encoding = clean_encoding_name(file_data.metadata.encoding)

            # Validate encoding
            try:
                "test".encode(clean_encoding)
                return clean_encoding
            except (LookupError, UnicodeError):
                self.logger.warning(
                    f"Original encoding '{clean_encoding}' for file '{file_data.path}' "
                    f"is not recognized. Falling back to UTF-8."
                )

        # Default: UTF-8
        return "utf-8"

    async def _encode_content(
        self, content: str, encoding: str, file_path: str
    ) -> bytes:
        """Encode content with the specified encoding."""
        try:
            return content.encode(encoding, errors="strict")
        except UnicodeEncodeError:
            self.logger.warning(
                f"Cannot strictly encode file '{file_path}' with {encoding}. "
                f"Using replacement mode which may lose some characters."
            )
            return content.encode(encoding, errors="replace")

    async def _confirm_overwrite_async(self, path: Path) -> bool:
        """Asynchronously confirm file overwrite (returns True for now)."""
        # In async mode, we can't easily do interactive input
        # So we follow the force_overwrite setting
        return self.config.force_overwrite

    def _confirm_overwrite_sync(self, path: Path) -> bool:
        """Synchronously confirm file overwrite."""
        if self.config.force_overwrite:
            return True

        try:
            response = input(f"Output file '{path}' already exists. Overwrite? (y/N): ")
            return response.lower() == "y"
        except KeyboardInterrupt:
            self.logger.info("\nOperation cancelled by user (Ctrl+C).")
            raise

    async def _set_file_timestamp(self, path: Path, file_data: ExtractedFile):
        """Set file modification timestamp if configured."""
        if (
            self.config.timestamp_mode == "original"
            and file_data.metadata.modified is not None
        ):
            try:
                # Convert datetime to timestamp
                mod_time = file_data.metadata.modified.timestamp()
                access_time = mod_time

                # Use asyncio to run in executor for non-blocking
                loop = asyncio.get_event_loop()
                await loop.run_in_executor(
                    None, os.utime, path, (access_time, mod_time)
                )

                self.logger.debug(
                    f"Set original modification time for '{path}' to "
                    f"{file_data.metadata.modified}"
                )
            except Exception as e:
                self.logger.warning(
                    f"Could not set original modification time for '{path}': {e}"
                )

    async def _verify_checksum_async(self, path: Path, file_data: ExtractedFile):
        """Verify file checksum asynchronously."""
        try:
            # Read file content
            async with aiofiles.open(path, "rb") as f:
                content_bytes = await f.read()

            calculated_checksum = calculate_sha256(content_bytes)
            expected_checksum = file_data.metadata.checksum_sha256

            if calculated_checksum != expected_checksum:
                # Check if difference is due to line endings
                await self._check_line_ending_difference(
                    path, file_data, calculated_checksum, expected_checksum
                )
            else:
                self.logger.debug(f"Checksum VERIFIED for file '{path}'")

        except Exception as e:
            self.logger.warning(f"Error during checksum verification for '{path}': {e}")

    def _verify_checksum_sync(self, path: Path, file_data: ExtractedFile):
        """Verify file checksum synchronously."""
        try:
            content_bytes = path.read_bytes()
            calculated_checksum = calculate_sha256(content_bytes)
            expected_checksum = file_data.metadata.checksum_sha256

            if calculated_checksum != expected_checksum:
                # Check if difference is due to line endings
                self._check_line_ending_difference_sync(
                    path, file_data, calculated_checksum, expected_checksum
                )
            else:
                self.logger.debug(f"Checksum VERIFIED for file '{path}'")

        except Exception as e:
            self.logger.warning(f"Error during checksum verification for '{path}': {e}")

    async def _check_line_ending_difference(
        self, path: Path, file_data: ExtractedFile, calculated: str, expected: str
    ):
        """Check if checksum difference is due to line endings."""
        # Normalize line endings and recalculate
        normalized_content = normalize_line_endings(file_data.content, "\n")
        normalized_bytes = normalized_content.encode("utf-8")
        normalized_checksum = calculate_sha256(normalized_bytes)

        if normalized_checksum == expected:
            self.logger.debug(
                f"Checksum difference for '{path}' appears to be due to "
                f"line ending normalization"
            )
        else:
            self.logger.warning(
                f"CHECKSUM MISMATCH for file '{path}'. "
                f"Expected: {expected}, Calculated: {calculated}. "
                f"The file content may be corrupted or was altered."
            )

    def _check_line_ending_difference_sync(
        self, path: Path, file_data: ExtractedFile, calculated: str, expected: str
    ):
        """Check if checksum difference is due to line endings (sync version)."""
        # Same logic as async version
        normalized_content = normalize_line_endings(file_data.content, "\n")
        normalized_bytes = normalized_content.encode("utf-8")
        normalized_checksum = calculate_sha256(normalized_bytes)

        if normalized_checksum == expected:
            self.logger.debug(
                f"Checksum difference for '{path}' appears to be due to "
                f"line ending normalization"
            )
        else:
            self.logger.warning(
                f"CHECKSUM MISMATCH for file '{path}'. "
                f"Expected: {expected}, Calculated: {calculated}. "
                f"The file content may be corrupted or was altered."
            )

======= scrape_tool/__init__.py | CHECKSUM_SHA256: 2e2cf8ee716b2e5909ff39267ec7c47fb4db666f7f89a3ee71d8b16941fd2337 ======
"""Web scraper tool for downloading websites."""

from .._version import __version__, __version_info__

======= scrape_tool/__main__.py | CHECKSUM_SHA256: 38906b635a3c0519e4110e6688cd4fddce144bc7e9177282cee24a347c6e6eaa ======
"""Entry point for m1f-scrape module."""

from .cli import main

if __name__ == "__main__":
    main()

======= scrape_tool/cli.py | CHECKSUM_SHA256: 8bc639bd16285c70a22f88d70a7225577f6ef4f7cca29de32dc404cd89479ae5 ======
"""Command-line interface for m1f-scrape."""

import argparse
import sys
from pathlib import Path
from typing import Optional

from rich.console import Console

from . import __version__
from .config import Config, ScraperBackend
from .crawlers import WebCrawler

console = Console()


def create_parser() -> argparse.ArgumentParser:
    """Create the argument parser."""
    parser = argparse.ArgumentParser(
        prog="m1f-scrape",
        description="Download websites for offline viewing",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "--version", action="version", version=f"%(prog)s {__version__}"
    )

    # Global options
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose output"
    )
    parser.add_argument(
        "-q", "--quiet", action="store_true", help="Suppress all output except errors"
    )

    # Main arguments
    parser.add_argument("url", help="URL to scrape")
    parser.add_argument(
        "-o", "--output", type=Path, required=True, help="Output directory"
    )

    # Scraper options
    parser.add_argument(
        "--scraper",
        type=str,
        choices=[
            "httrack",
            "beautifulsoup",
            "bs4",
            "selectolax",
            "httpx",
            "scrapy",
            "playwright",
        ],
        default="beautifulsoup",
        help="Web scraper backend to use (default: beautifulsoup)",
    )

    parser.add_argument(
        "--scraper-config",
        type=Path,
        help="Path to scraper-specific configuration file (YAML/JSON)",
    )

    # Crawl options
    parser.add_argument("--max-depth", type=int, default=5, help="Maximum crawl depth")
    parser.add_argument(
        "--max-pages", type=int, default=1000, help="Maximum pages to crawl"
    )

    # Request options
    parser.add_argument(
        "--request-delay",
        type=float,
        default=15.0,
        help="Delay between requests in seconds (default: 15.0 for Cloudflare protection)",
    )

    parser.add_argument(
        "--concurrent-requests",
        type=int,
        default=2,
        help="Number of concurrent requests (default: 2 for Cloudflare protection)",
    )

    parser.add_argument("--user-agent", type=str, help="Custom user agent string")

    # Output options
    parser.add_argument(
        "--list-files",
        action="store_true",
        help="List all downloaded files after completion",
    )

    return parser


def main() -> None:
    """Main entry point."""
    parser = create_parser()
    args = parser.parse_args()

    # Create configuration
    config = Config()
    config.crawler.max_depth = args.max_depth
    config.crawler.max_pages = args.max_pages
    config.crawler.scraper_backend = ScraperBackend(args.scraper)
    config.crawler.request_delay = args.request_delay
    config.crawler.concurrent_requests = args.concurrent_requests
    config.crawler.respect_robots_txt = True  # Always respect robots.txt

    if args.user_agent:
        config.crawler.user_agent = args.user_agent

    # Load scraper-specific config if provided
    if args.scraper_config:
        import yaml
        import json

        if args.scraper_config.suffix == ".json":
            with open(args.scraper_config) as f:
                config.crawler.scraper_config = json.load(f)
        else:  # Assume YAML
            with open(args.scraper_config) as f:
                config.crawler.scraper_config = yaml.safe_load(f)

    config.verbose = args.verbose
    config.quiet = args.quiet

    # Create output directory
    args.output.mkdir(parents=True, exist_ok=True)

    console.print(f"Scraping website: {args.url}")
    console.print(f"Using scraper backend: {args.scraper}")
    console.print("This may take a while...")

    try:
        # Create crawler and download the website
        crawler = WebCrawler(config.crawler)
        site_dir = crawler.crawl_sync(args.url, args.output)

        # Find all downloaded HTML files
        html_files = crawler.find_downloaded_files(site_dir)

        console.print(
            f"✅ Successfully downloaded {len(html_files)} HTML files", style="green"
        )
        console.print(f"Output directory: {site_dir}")

        # List downloaded files if requested
        if args.list_files or config.verbose:
            console.print("\nDownloaded files:")
            for html_file in sorted(html_files):
                rel_path = html_file.relative_to(site_dir)
                console.print(f"  - {rel_path}")

    except Exception as e:
        console.print(f"❌ Error during scraping: {e}", style="red")
        if config.verbose:
            import traceback

            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()

======= scrape_tool/config.py | CHECKSUM_SHA256: c63389a1e1c41e039f7ef0b59d32165ad7fad8660574329f76ef8fc86fdd206a ======
"""Configuration models for m1f-scrape."""

from enum import Enum
from typing import Any, Dict, Optional

from pydantic import BaseModel, Field


class ScraperBackend(str, Enum):
    """Available scraper backends."""

    HTTRACK = "httrack"
    BEAUTIFULSOUP = "beautifulsoup"
    BS4 = "bs4"  # Alias for beautifulsoup
    SELECTOLAX = "selectolax"
    HTTPX = "httpx"
    SCRAPY = "scrapy"
    PLAYWRIGHT = "playwright"


class CrawlerConfig(BaseModel):
    """Configuration for web crawler."""

    max_depth: int = Field(default=5, ge=1, le=20, description="Maximum crawl depth")
    max_pages: int = Field(
        default=1000, ge=1, le=10000, description="Maximum pages to crawl"
    )
    follow_external_links: bool = Field(
        default=False, description="Follow links to external domains"
    )
    allowed_domains: Optional[list[str]] = Field(
        default=None, description="List of allowed domains to crawl"
    )
    excluded_paths: list[str] = Field(
        default_factory=list, description="URL paths to exclude from crawling"
    )
    scraper_backend: ScraperBackend = Field(
        default=ScraperBackend.BEAUTIFULSOUP, description="Web scraper backend to use"
    )
    scraper_config: Dict[str, Any] = Field(
        default_factory=dict, description="Backend-specific configuration"
    )
    request_delay: float = Field(
        default=15.0,
        ge=0,
        le=60,
        description="Delay between requests in seconds (default: 15s for Cloudflare)",
    )
    concurrent_requests: int = Field(
        default=2,
        ge=1,
        le=20,
        description="Number of concurrent requests (default: 2 for Cloudflare)",
    )
    user_agent: Optional[str] = Field(
        default=None, description="Custom user agent string"
    )
    respect_robots_txt: bool = Field(
        default=True, description="Respect robots.txt rules"
    )
    timeout: int = Field(
        default=30, ge=1, le=300, description="Request timeout in seconds"
    )
    retry_count: int = Field(
        default=3, ge=0, le=10, description="Number of retries for failed requests"
    )


class Config(BaseModel):
    """Main configuration for m1f-scrape."""

    crawler: CrawlerConfig = Field(
        default_factory=CrawlerConfig, description="Crawler configuration"
    )
    verbose: bool = Field(default=False, description="Enable verbose output")
    quiet: bool = Field(default=False, description="Suppress output except errors")

======= scrape_tool/crawlers.py | CHECKSUM_SHA256: fefa182f0fbbfee034e760c6f5b3ca42c677ea1d79b68edf1642d08fb3672cc9 ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Web crawling functionality using configurable scraper backends."""

import asyncio
import logging
from pathlib import Path
from typing import List, Dict, Any, Optional
from urllib.parse import urlparse

from .scrapers import create_scraper, ScraperConfig, ScrapedPage
from .config import CrawlerConfig, ScraperBackend

logger = logging.getLogger(__name__)


class WebCrawler:
    """Web crawler that uses configurable scraper backends."""

    def __init__(self, config: CrawlerConfig):
        """Initialize crawler with configuration.

        Args:
            config: CrawlerConfig instance with crawling settings
        """
        self.config = config
        self._scraper_config = self._create_scraper_config()

    def _create_scraper_config(self) -> ScraperConfig:
        """Create scraper configuration from crawler config.

        Returns:
            ScraperConfig instance
        """
        # Convert allowed_domains from set to list
        allowed_domains = (
            list(self.config.allowed_domains) if self.config.allowed_domains else []
        )

        # Convert excluded_paths to exclude_patterns
        exclude_patterns = (
            list(self.config.excluded_paths) if self.config.excluded_paths else []
        )

        # Create scraper config
        scraper_config = ScraperConfig(
            max_depth=self.config.max_depth,
            max_pages=self.config.max_pages,
            allowed_domains=allowed_domains,
            exclude_patterns=exclude_patterns,
            respect_robots_txt=self.config.respect_robots_txt,
            concurrent_requests=self.config.concurrent_requests,
            request_delay=self.config.request_delay,
            user_agent=self.config.user_agent,
            timeout=float(self.config.timeout),
            follow_redirects=True,  # Always follow redirects
        )

        # Apply any backend-specific configuration
        if self.config.scraper_config:
            for key, value in self.config.scraper_config.items():
                if hasattr(scraper_config, key):
                    setattr(scraper_config, key, value)

        return scraper_config

    async def crawl(self, start_url: str, output_dir: Path) -> Dict[str, Any]:
        """Crawl a website using the configured scraper backend.

        Args:
            start_url: Starting URL for crawling
            output_dir: Directory to store downloaded files

        Returns:
            Dictionary with crawl results including:
            - pages: List of scraped pages
            - total_pages: Total number of pages scraped
            - errors: List of any errors encountered

        Raises:
            Exception: If crawling fails
        """
        logger.info(
            f"Starting crawl of {start_url} using {self.config.scraper_backend} backend"
        )

        # Create output directory
        output_dir.mkdir(parents=True, exist_ok=True)

        # Parse URL to get domain for output structure
        parsed_url = urlparse(start_url)
        domain = parsed_url.netloc
        site_dir = output_dir / domain
        site_dir.mkdir(exist_ok=True)

        # Create scraper instance
        backend_name = self.config.scraper_backend.value
        scraper = create_scraper(backend_name, self._scraper_config)

        pages = []
        errors = []

        try:
            async with scraper:
                async for page in scraper.scrape_site(start_url):
                    pages.append(page)

                    # Save page to disk
                    try:
                        await self._save_page(page, site_dir)
                    except Exception as e:
                        logger.error(f"Failed to save page {page.url}: {e}")
                        errors.append({"url": page.url, "error": str(e)})
                        # Continue with other pages despite the error

        except Exception as e:
            logger.error(f"Crawl failed: {e}")
            raise

        logger.info(
            f"Crawl completed. Scraped {len(pages)} pages with {len(errors)} errors"
        )

        return {
            "pages": pages,
            "total_pages": len(pages),
            "errors": errors,
            "output_dir": site_dir,
        }

    async def _save_page(self, page: ScrapedPage, output_dir: Path) -> Path:
        """Save a scraped page to disk.

        Args:
            page: ScrapedPage instance
            output_dir: Directory to save the page

        Returns:
            Path to saved file
        """
        # Parse URL to create file path
        parsed = urlparse(page.url)

        # Create subdirectories based on URL path
        if parsed.path and parsed.path != "/":
            # Remove leading slash and split path
            path_parts = parsed.path.lstrip("/").split("/")

            # Handle file extension
            if path_parts[-1].endswith(".html") or "." in path_parts[-1]:
                filename = path_parts[-1]
                subdirs = path_parts[:-1]
            else:
                # Assume it's a directory, create index.html
                filename = "index.html"
                subdirs = path_parts

            # Create subdirectories
            if subdirs:
                subdir = output_dir / Path(*subdirs)
                subdir.mkdir(parents=True, exist_ok=True)
                file_path = subdir / filename
            else:
                file_path = output_dir / filename
        else:
            # Root page
            file_path = output_dir / "index.html"

        # Ensure .html extension
        if not file_path.suffix:
            file_path = file_path.with_suffix(".html")
        elif file_path.suffix not in (".html", ".htm"):
            file_path = file_path.with_name(f"{file_path.name}.html")

        # Write content
        file_path.parent.mkdir(parents=True, exist_ok=True)
        file_path.write_text(page.content, encoding=page.encoding)

        logger.debug(f"Saved {page.url} to {file_path}")

        # Save metadata if available
        try:
            metadata_path = file_path.with_suffix(".meta.json")
            import json

            metadata = {
                "url": page.url,
                "title": page.title,
                "encoding": page.encoding,
                "status_code": page.status_code,
                "headers": page.headers if page.headers else {},
                "metadata": page.metadata if page.metadata else {},
            }
            # Filter out None values and ensure all keys are strings
            clean_metadata = {}
            for k, v in metadata.items():
                if v is not None:
                    if isinstance(v, dict):
                        # Clean nested dictionaries - ensure no None keys
                        clean_v = {}
                        for sub_k, sub_v in v.items():
                            if sub_k is not None:
                                clean_v[str(sub_k)] = sub_v
                        clean_metadata[k] = clean_v
                    else:
                        clean_metadata[k] = v

            metadata_path.write_text(json.dumps(clean_metadata, indent=2, default=str))
        except Exception as e:
            logger.warning(f"Failed to save metadata for {page.url}: {e}")
            # Don't fail the entire page save just because metadata failed

        return file_path

    def find_downloaded_files(self, site_dir: Path) -> List[Path]:
        """Find all HTML files in the output directory.

        Args:
            site_dir: Directory containing downloaded files

        Returns:
            List of HTML file paths
        """
        if not site_dir.exists():
            logger.warning(f"Site directory does not exist: {site_dir}")
            return []

        html_files = []

        # Find all HTML files
        patterns = ["*.html", "*.htm"]
        for pattern in patterns:
            files = list(site_dir.rglob(pattern))
            html_files.extend(files)

        # Filter out metadata files
        filtered_files = [f for f in html_files if not f.name.endswith(".meta.json")]

        logger.info(f"Found {len(filtered_files)} HTML files in {site_dir}")
        return sorted(filtered_files)

    def crawl_sync(self, start_url: str, output_dir: Path) -> Path:
        """Synchronous version of crawl method.

        Args:
            start_url: Starting URL for crawling
            output_dir: Directory to store downloaded files

        Returns:
            Path to site directory
        """
        # Run async crawl in new event loop
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            result = loop.run_until_complete(self.crawl(start_url, output_dir))
            return result["output_dir"]
        finally:
            loop.close()

======= html2md_tool/config/__init__.py | CHECKSUM_SHA256: 25abe55da0e3290c9cff56101eb5059207b1d20ad3fa1afe5da78dc64c146bc2 ======
"""Configuration system for mf1-html2md."""

from .loader import load_config, save_config
from .models import (
    AssetConfig,
    Config,
    ConversionOptions,
    CrawlerConfig,
    ExtractorConfig,
    M1fConfig,
    OutputFormat,
    ProcessorConfig,
)

__all__ = [
    "AssetConfig",
    "Config",
    "ConversionOptions",
    "CrawlerConfig",
    "ExtractorConfig",
    "M1fConfig",
    "OutputFormat",
    "ProcessorConfig",
    "load_config",
    "save_config",
]

======= html2md_tool/config/loader.py | CHECKSUM_SHA256: 86382993f15fc837386e5969c9208333bfb3c88617259d8736ac63fceff244e1 ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Configuration loading and saving utilities."""

import json
from pathlib import Path
from typing import Any, Dict

import yaml

from .models import Config


def load_config(path: Path) -> Config:
    """Load configuration from file.

    Args:
        path: Path to configuration file (JSON or YAML)

    Returns:
        Config object

    Raises:
        ValueError: If file format is not supported
        FileNotFoundError: If file does not exist
    """
    if not path.exists():
        raise FileNotFoundError(f"Configuration file not found: {path}")

    suffix = path.suffix.lower()

    if suffix in [".json"]:
        with open(path, "r") as f:
            data = json.load(f)
    elif suffix in [".yaml", ".yml"]:
        with open(path, "r") as f:
            data = yaml.safe_load(f)
    else:
        raise ValueError(f"Unsupported configuration format: {suffix}")

    return Config(**data)


def save_config(config: Config, path: Path) -> None:
    """Save configuration to file.

    Args:
        config: Config object to save
        path: Path to save configuration to

    Raises:
        ValueError: If file format is not supported
    """
    suffix = path.suffix.lower()

    # Convert dataclass to dict
    data = _config_to_dict(config)

    if suffix in [".json"]:
        with open(path, "w") as f:
            json.dump(data, f, indent=2)
    elif suffix in [".yaml", ".yml"]:
        with open(path, "w") as f:
            yaml.dump(data, f, default_flow_style=False)
    else:
        raise ValueError(f"Unsupported configuration format: {suffix}")


def _config_to_dict(config: Config) -> Dict[str, Any]:
    """Convert Config object to dictionary.

    Args:
        config: Config object

    Returns:
        Dictionary representation
    """
    from dataclasses import asdict

    data = asdict(config)

    # Convert Path objects to strings
    def convert_paths(obj):
        if isinstance(obj, dict):
            return {k: convert_paths(v) for k, v in obj.items()}
        elif isinstance(obj, list):
            return [convert_paths(v) for v in obj]
        elif isinstance(obj, Path):
            return str(obj)
        else:
            return obj

    return convert_paths(data)

======= html2md_tool/config/models.py | CHECKSUM_SHA256: 5bef144cffe55814a93d0a54308dd7d897c0f033494bce1842727c30568cb95e ======
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Configuration models for mf1-html2md."""

from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set


class OutputFormat(Enum):
    """Output format options."""

    MARKDOWN = "markdown"
    HTML = "html"
    JSON = "json"


class ScraperBackend(str, Enum):
    """Available web scraper backends."""

    HTTRACK = "httrack"
    BEAUTIFULSOUP = "beautifulsoup"
    BS4 = "bs4"  # Alias for beautifulsoup
    SCRAPY = "scrapy"
    PLAYWRIGHT = "playwright"
    SELECTOLAX = "selectolax"
    HTTPX = "httpx"  # Alias for selectolax


@dataclass
class ConversionOptions:
    """Options for HTML to Markdown conversion."""

    strip_tags: List[str] = field(default_factory=lambda: ["script", "style"])
    keep_html_tags: List[str] = field(default_factory=list)
    code_language: str = ""
    heading_style: str = "atx"  # atx or setext
    bold_style: str = "**"  # ** or __
    italic_style: str = "*"  # * or _
    link_style: str = "inline"  # inline or reference
    list_marker: str = "-"  # -, *, or +
    code_block_style: str = "fenced"  # fenced or indented
    preserve_whitespace: bool = False
    wrap_width: int = 0  # 0 means no wrapping

    # Additional fields for test compatibility
    source_dir: Optional[str] = None
    destination_dir: Optional[Path] = None
    destination_directory: Optional[Path] = None  # Alias for destination_dir
    outermost_selector: Optional[str] = None
    ignore_selectors: Optional[List[str]] = None
    heading_offset: int = 0
    generate_frontmatter: bool = False
    add_frontmatter: bool = False  # Alias for generate_frontmatter
    frontmatter_fields: Optional[Dict[str, str]] = None
    convert_code_blocks: bool = True
    parallel: bool = False
    max_workers: int = 4

    def __post_init__(self):
        # Handle aliases
        if self.add_frontmatter:
            self.generate_frontmatter = True
        if self.destination_directory:
            self.destination_dir = self.destination_directory

    @classmethod
    def from_config_file(cls, path: Path) -> "ConversionOptions":
        """Load options from a configuration file."""
        import yaml

        with open(path, "r") as f:
            data = yaml.safe_load(f)

        # Handle aliases in config file
        if "source_directory" in data:
            data["source_dir"] = data.pop("source_directory")
        if "destination_directory" in data:
            data["destination_dir"] = data.pop("destination_directory")

        return cls(**data)


@dataclass
class AssetConfig:
    """Configuration for asset handling."""

    download: bool = True
    directory: Path = Path("assets")
    max_size: int = 10 * 1024 * 1024  # 10MB
    allowed_types: Set[str] = field(
        default_factory=lambda: {
            "image/jpeg",
            "image/png",
            "image/gif",
            "image/webp",
            "image/svg+xml",
            "application/pdf",
        }
    )


@dataclass
class ExtractorConfig:
    """Configuration for HTML extraction."""

    parser: str = "html.parser"  # BeautifulSoup parser
    encoding: str = "utf-8"
    decode_errors: str = "ignore"
    prettify: bool = False


@dataclass
class ProcessorConfig:
    """Configuration for Markdown processing."""

    template: Optional[Path] = None
    metadata: Dict[str, str] = field(default_factory=dict)
    frontmatter: bool = False
    toc: bool = False
    toc_depth: int = 3


@dataclass
class CrawlerConfig:
    """Configuration for web crawling."""

    max_depth: int = 1
    follow_links: bool = False
    allowed_domains: Set[str] = field(default_factory=set)
    excluded_paths: Set[str] = field(default_factory=set)
    rate_limit: float = 1.0  # seconds between requests
    timeout: int = 30
    user_agent: str = (
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0"
    )

    # HTTrack-specific options
    concurrent_requests: int = 4
    request_delay: float = 0.5  # seconds between requests
    respect_robots_txt: bool = True
    max_pages: int = 1000

    # Scraper backend configuration
    scraper_backend: ScraperBackend = ScraperBackend.BEAUTIFULSOUP
    scraper_config: Dict[str, Any] = field(default_factory=dict)


@dataclass
class M1fConfig:
    """Configuration for M1F integration."""

    enabled: bool = False
    options: Dict[str, str] = field(default_factory=dict)


@dataclass
class Config:
    """Main configuration class."""

    source: Path
    destination: Path

    # Conversion options
    conversion: ConversionOptions = field(default_factory=ConversionOptions)

    # Component configs
    extractor: ExtractorConfig = field(default_factory=ExtractorConfig)
    processor: ProcessorConfig = field(default_factory=ProcessorConfig)
    assets: AssetConfig = field(default_factory=AssetConfig)
    crawler: CrawlerConfig = field(default_factory=CrawlerConfig)
    m1f: M1fConfig = field(default_factory=M1fConfig)

    # General options
    verbose: bool = False
    quiet: bool = False
    log_file: Optional[Path] = None
    dry_run: bool = False
    overwrite: bool = False

    # Processing options
    parallel: bool = False
    max_workers: int = 4
    chunk_size: int = 10

    # File handling options
    file_extensions: List[str] = field(default_factory=lambda: [".html", ".htm"])
    exclude_patterns: List[str] = field(
        default_factory=lambda: [".*", "_*", "node_modules", "__pycache__"]
    )
    target_encoding: str = "utf-8"

    # Preprocessing configuration
    preprocessing: Optional[Any] = None  # PreprocessingConfig instance

    def __post_init__(self):
        """Initialize preprocessing with defaults if not provided."""
        if self.preprocessing is None:
            from ..preprocessors import PreprocessingConfig

            self.preprocessing = PreprocessingConfig(
                remove_elements=["script", "style", "noscript"],
                remove_empty_elements=True,
            )

======= scrape_tool/scrapers/__init__.py | CHECKSUM_SHA256: 8e90215fdfdd945f0be7e61e951a8057e1006304bd16ee9d0483ee263189161c ======
"""Web scraper backends for HTML2MD."""

from typing import Dict, Type, Optional
from .base import WebScraperBase, ScraperConfig, ScrapedPage
from .beautifulsoup import BeautifulSoupScraper
from .httrack import HTTrackScraper

# Import new scrapers with error handling for optional dependencies
try:
    from .selectolax import SelectolaxScraper

    SELECTOLAX_AVAILABLE = True
except ImportError:
    SELECTOLAX_AVAILABLE = False
    SelectolaxScraper = None

try:
    from .scrapy_scraper import ScrapyScraper

    SCRAPY_AVAILABLE = True
except ImportError:
    SCRAPY_AVAILABLE = False
    ScrapyScraper = None

try:
    from .playwright import PlaywrightScraper

    PLAYWRIGHT_AVAILABLE = True
except ImportError:
    PLAYWRIGHT_AVAILABLE = False
    PlaywrightScraper = None

__all__ = [
    "WebScraperBase",
    "ScraperConfig",
    "ScrapedPage",
    "create_scraper",
    "SCRAPER_REGISTRY",
    "BeautifulSoupScraper",
    "HTTrackScraper",
    "SelectolaxScraper",
    "ScrapyScraper",
    "PlaywrightScraper",
]

# Registry of available scraper backends
SCRAPER_REGISTRY: Dict[str, Type[WebScraperBase]] = {
    "beautifulsoup": BeautifulSoupScraper,
    "bs4": BeautifulSoupScraper,  # Alias
    "httrack": HTTrackScraper,
}

# Add optional scrapers if available
if SELECTOLAX_AVAILABLE:
    SCRAPER_REGISTRY["selectolax"] = SelectolaxScraper
    SCRAPER_REGISTRY["httpx"] = SelectolaxScraper  # Alias

if SCRAPY_AVAILABLE:
    SCRAPER_REGISTRY["scrapy"] = ScrapyScraper

if PLAYWRIGHT_AVAILABLE:
    SCRAPER_REGISTRY["playwright"] = PlaywrightScraper


def create_scraper(
    backend: str, config: Optional[ScraperConfig] = None
) -> WebScraperBase:
    """Factory function to create appropriate scraper instance.

    Args:
        backend: Name of the scraper backend to use
        config: Configuration for the scraper (uses defaults if not provided)

    Returns:
        Instance of the requested scraper backend

    Raises:
        ValueError: If the backend is not registered
    """
    if backend not in SCRAPER_REGISTRY:
        available = ", ".join(SCRAPER_REGISTRY.keys()) if SCRAPER_REGISTRY else "none"
        raise ValueError(
            f"Unknown scraper backend: {backend}. " f"Available backends: {available}"
        )

    if config is None:
        config = ScraperConfig()

    scraper_class = SCRAPER_REGISTRY[backend]
    return scraper_class(config)

======= scrape_tool/scrapers/base.py | CHECKSUM_SHA256: 16ed668b50cb09dfb4c3dcf3a23eb5b192800748d6df9539bf3f2bb56589291b ======
"""Abstract base class for web scrapers."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import List, Dict, Optional, AsyncGenerator, Set
from pathlib import Path
import logging

logger = logging.getLogger(__name__)


@dataclass
class ScraperConfig:
    """Configuration for web scrapers."""

    max_depth: int = 10
    max_pages: int = 1000
    allowed_domains: Optional[List[str]] = None
    exclude_patterns: Optional[List[str]] = None
    respect_robots_txt: bool = True
    concurrent_requests: int = 5
    request_delay: float = 0.5
    user_agent: str = (
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    )
    custom_headers: Optional[Dict[str, str]] = None
    timeout: float = 30.0
    follow_redirects: bool = True
    verify_ssl: bool = True

    def __post_init__(self):
        """Initialize mutable defaults."""
        if self.allowed_domains is None:
            self.allowed_domains = []
        if self.exclude_patterns is None:
            self.exclude_patterns = []
        if self.custom_headers is None:
            self.custom_headers = {}


@dataclass
class ScrapedPage:
    """Represents a scraped web page."""

    url: str
    content: str
    title: Optional[str] = None
    metadata: Optional[Dict[str, str]] = None
    encoding: str = "utf-8"
    status_code: Optional[int] = None
    headers: Optional[Dict[str, str]] = None

    def __post_init__(self):
        """Initialize mutable defaults."""
        if self.metadata is None:
            self.metadata = {}
        if self.headers is None:
            self.headers = {}


class WebScraperBase(ABC):
    """Abstract base class for web scrapers."""

    def __init__(self, config: ScraperConfig):
        """Initialize the scraper with configuration.

        Args:
            config: Scraper configuration
        """
        self.config = config
        self._visited_urls: Set[str] = set()

    @abstractmethod
    async def scrape_url(self, url: str) -> ScrapedPage:
        """Scrape a single URL.

        Args:
            url: URL to scrape

        Returns:
            ScrapedPage object containing the scraped content

        Raises:
            Exception: If scraping fails
        """
        pass

    @abstractmethod
    async def scrape_site(self, start_url: str) -> AsyncGenerator[ScrapedPage, None]:
        """Scrape an entire website starting from a URL.

        Args:
            start_url: URL to start crawling from

        Yields:
            ScrapedPage objects as they are scraped
        """
        pass

    def validate_url(self, url: str) -> bool:
        """Validate if a URL should be scraped based on configuration.

        Args:
            url: URL to validate

        Returns:
            True if URL should be scraped, False otherwise
        """
        from urllib.parse import urlparse

        try:
            parsed = urlparse(url)

            # Check if URL has valid scheme
            if parsed.scheme not in ("http", "https"):
                return False

            # Check allowed domains
            if self.config.allowed_domains:
                domain_allowed = False
                for domain in self.config.allowed_domains:
                    if domain in parsed.netloc:
                        domain_allowed = True
                        break
                if not domain_allowed:
                    return False

            # Check exclude patterns
            if self.config.exclude_patterns:
                for pattern in self.config.exclude_patterns:
                    if pattern in url:
                        logger.debug(f"URL {url} excluded by pattern: {pattern}")
                        return False

            return True

        except Exception as e:
            logger.error(f"Error validating URL {url}: {e}")
            return False

    def is_visited(self, url: str) -> bool:
        """Check if URL has already been visited.

        Args:
            url: URL to check

        Returns:
            True if URL has been visited, False otherwise
        """
        return url in self._visited_urls

    def mark_visited(self, url: str) -> None:
        """Mark URL as visited.

        Args:
            url: URL to mark as visited
        """
        self._visited_urls.add(url)

    async def __aenter__(self):
        """Async context manager entry."""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        pass

======= scrape_tool/scrapers/beautifulsoup.py | CHECKSUM_SHA256: 0fc4dff25b2a3db379e56cd0321dbbdeb40670b23d2b22376fde5667fdf2bdab ======
"""BeautifulSoup4-based web scraper implementation."""

import asyncio
import logging
from typing import Set, AsyncGenerator, Optional, Dict
from urllib.parse import urljoin, urlparse, unquote
import aiohttp
from bs4 import BeautifulSoup
import chardet

from .base import WebScraperBase, ScrapedPage, ScraperConfig

logger = logging.getLogger(__name__)


class BeautifulSoupScraper(WebScraperBase):
    """BeautifulSoup4-based web scraper for simple HTML extraction."""

    def __init__(self, config: ScraperConfig):
        """Initialize the BeautifulSoup scraper.

        Args:
            config: Scraper configuration
        """
        super().__init__(config)
        self.session: Optional[aiohttp.ClientSession] = None
        self._semaphore = asyncio.Semaphore(config.concurrent_requests)

    async def __aenter__(self):
        """Create aiohttp session on entry."""
        headers = {"User-Agent": self.config.user_agent}
        if self.config.custom_headers:
            headers.update(self.config.custom_headers)

        timeout = aiohttp.ClientTimeout(total=self.config.timeout)
        connector = aiohttp.TCPConnector(
            ssl=self.config.verify_ssl, limit=self.config.concurrent_requests * 2
        )

        self.session = aiohttp.ClientSession(
            headers=headers, timeout=timeout, connector=connector
        )
        return self

    async def __aexit__(self, *args):
        """Close aiohttp session on exit."""
        if self.session:
            await self.session.close()
            # Small delay to allow connections to close properly
            await asyncio.sleep(0.1)

    async def scrape_url(self, url: str) -> ScrapedPage:
        """Scrape a single URL using BeautifulSoup.

        Args:
            url: URL to scrape

        Returns:
            ScrapedPage object containing the scraped content

        Raises:
            Exception: If scraping fails
        """
        if not self.session:
            raise RuntimeError("Scraper must be used as async context manager")

        async with self._semaphore:  # Limit concurrent requests
            try:
                logger.info(f"Scraping URL: {url}")

                async with self.session.get(
                    url, allow_redirects=self.config.follow_redirects
                ) as response:
                    # Get response info
                    status_code = response.status
                    # Convert headers to dict with string keys
                    headers = {str(k): str(v) for k, v in response.headers.items()}

                    # Handle encoding
                    content_bytes = await response.read()

                    # Try to detect encoding if not specified
                    encoding = response.charset
                    if not encoding:
                        detected = chardet.detect(content_bytes)
                        encoding = detected.get("encoding", "utf-8")
                        logger.debug(f"Detected encoding for {url}: {encoding}")

                    # Decode content
                    try:
                        content = content_bytes.decode(encoding or "utf-8")
                    except (UnicodeDecodeError, LookupError):
                        # Fallback to utf-8 with error handling
                        content = content_bytes.decode("utf-8", errors="replace")
                        encoding = "utf-8"

                    # Parse with BeautifulSoup
                    soup = BeautifulSoup(content, "html.parser")

                    # Extract metadata
                    title = soup.find("title")
                    title_text = title.get_text(strip=True) if title else None

                    metadata = self._extract_metadata(soup)

                    return ScrapedPage(
                        url=str(response.url),  # Use final URL after redirects
                        content=str(soup),
                        title=title_text,
                        metadata=metadata,
                        encoding=encoding,
                        status_code=status_code,
                        headers=headers,
                    )

            except asyncio.TimeoutError:
                logger.error(f"Timeout while scraping {url}")
                raise
            except aiohttp.ClientError as e:
                logger.error(f"Client error while scraping {url}: {e}")
                raise
            except Exception as e:
                logger.error(f"Unexpected error while scraping {url}: {e}")
                raise

    async def scrape_site(self, start_url: str) -> AsyncGenerator[ScrapedPage, None]:
        """Scrape entire website starting from URL.

        Args:
            start_url: URL to start crawling from

        Yields:
            ScrapedPage objects as they are scraped
        """
        # Parse start URL to get base domain
        start_parsed = urlparse(start_url)
        base_domain = start_parsed.netloc

        # If no allowed domains specified, restrict to start domain
        if not self.config.allowed_domains:
            self.config.allowed_domains = [base_domain]
            logger.info(f"Restricting crawl to domain: {base_domain}")

        # URLs to visit
        to_visit: Set[str] = {start_url}
        depth_map: Dict[str, int] = {start_url: 0}

        async with self:
            while to_visit and len(self._visited_urls) < self.config.max_pages:
                # Get next URL
                url = to_visit.pop()

                # Skip if already visited
                if self.is_visited(url):
                    continue

                # Validate URL
                if not self.validate_url(url):
                    continue

                # Check depth
                current_depth = depth_map.get(url, 0)
                if current_depth > self.config.max_depth:
                    logger.debug(
                        f"Skipping {url} - exceeds max depth {self.config.max_depth}"
                    )
                    continue

                # Mark as visited
                self.mark_visited(url)

                try:
                    # Scrape the page
                    page = await self.scrape_url(url)
                    yield page

                    # Extract links if not at max depth
                    if current_depth < self.config.max_depth:
                        new_urls = self._extract_links(page.content, url)
                        for new_url in new_urls:
                            if (
                                new_url not in self._visited_urls
                                and new_url not in to_visit
                            ):
                                to_visit.add(new_url)
                                depth_map[new_url] = current_depth + 1
                                logger.debug(
                                    f"Added URL to queue: {new_url} (depth: {current_depth + 1})"
                                )

                    # Respect rate limit
                    if self.config.request_delay > 0:
                        await asyncio.sleep(self.config.request_delay)

                except Exception as e:
                    logger.error(f"Error processing {url}: {e}")
                    # Continue with other URLs
                    continue

        logger.info(f"Crawl complete. Visited {len(self._visited_urls)} pages")

    def _extract_metadata(self, soup: BeautifulSoup) -> Dict[str, str]:
        """Extract metadata from HTML.

        Args:
            soup: BeautifulSoup parsed HTML

        Returns:
            Dictionary of metadata key-value pairs
        """
        metadata = {}

        # Extract meta tags
        for meta in soup.find_all("meta"):
            # Try different meta tag formats
            name = meta.get("name") or meta.get("property") or meta.get("http-equiv")
            content = meta.get("content", "")

            if name and content:
                # Ensure name is a string
                metadata[str(name)] = content

        # Extract other useful information
        # Canonical URL
        canonical = soup.find("link", {"rel": "canonical"})
        if canonical and canonical.get("href"):
            metadata["canonical"] = canonical["href"]

        # Author
        author = soup.find("meta", {"name": "author"})
        if author and author.get("content"):
            metadata["author"] = author["content"]

        return metadata

    def _extract_links(self, html_content: str, base_url: str) -> Set[str]:
        """Extract all links from HTML content.

        Args:
            html_content: HTML content to parse
            base_url: Base URL for resolving relative links

        Returns:
            Set of absolute URLs found in the content
        """
        links = set()

        try:
            soup = BeautifulSoup(html_content, "html.parser")

            # Find all links (only from anchor tags, not link tags which often point to CSS)
            for tag in soup.find_all("a"):
                href = tag.get("href")
                if href:
                    # Clean and resolve URL
                    href = href.strip()
                    if href and not href.startswith(
                        ("#", "javascript:", "mailto:", "tel:")
                    ):
                        absolute_url = urljoin(base_url, href)
                        # Remove fragment
                        absolute_url = absolute_url.split("#")[0]
                        if absolute_url:
                            # Skip non-HTML resources
                            if not any(
                                absolute_url.endswith(ext)
                                for ext in [
                                    ".css",
                                    ".js",
                                    ".json",
                                    ".xml",
                                    ".ico",
                                    ".jpg",
                                    ".jpeg",
                                    ".png",
                                    ".gif",
                                    ".svg",
                                    ".webp",
                                    ".pdf",
                                    ".zip",
                                ]
                            ):
                                links.add(unquote(absolute_url))

        except Exception as e:
            logger.error(f"Error extracting links from {base_url}: {e}")

        return links

======= scrape_tool/scrapers/httrack.py | CHECKSUM_SHA256: 3dc83d400b6f00a82cba11206953e46709cde74a7d1b19ed0db12110973b1a8d ======
"""HTTrack-based web scraper implementation."""

import asyncio
import logging
import os
import shutil
import tempfile
from pathlib import Path
from typing import AsyncGenerator, Optional, Set
from urllib.parse import urlparse, urljoin

from .base import WebScraperBase, ScrapedPage, ScraperConfig

logger = logging.getLogger(__name__)


class HTTrackScraper(WebScraperBase):
    """HTTrack-based web scraper for complete website mirroring."""

    def __init__(self, config: ScraperConfig):
        """Initialize the HTTrack scraper.

        Args:
            config: Scraper configuration
        """
        super().__init__(config)
        self.httrack_path = shutil.which("httrack")
        if not self.httrack_path:
            raise RuntimeError(
                "HTTrack not found. Please install HTTrack: "
                "apt-get install httrack (Linux) or "
                "brew install httrack (macOS) or "
                "download from https://www.httrack.com (Windows)"
            )
        self.temp_dir: Optional[Path] = None

    async def __aenter__(self):
        """Create temporary directory for HTTrack output."""
        self.temp_dir = Path(tempfile.mkdtemp(prefix="html2md_httrack_"))
        logger.debug(f"Created temporary directory: {self.temp_dir}")
        return self

    async def __aexit__(self, *args):
        """Clean up temporary directory."""
        if self.temp_dir and self.temp_dir.exists():
            try:
                shutil.rmtree(self.temp_dir)
                logger.debug(f"Cleaned up temporary directory: {self.temp_dir}")
            except Exception as e:
                logger.warning(f"Failed to clean up temp directory: {e}")

    async def scrape_url(self, url: str) -> ScrapedPage:
        """Scrape a single URL using HTTrack.

        Note: HTTrack is designed for full site mirroring, so this method
        will create a minimal mirror and extract just the requested page.

        Args:
            url: URL to scrape

        Returns:
            ScrapedPage object containing the scraped content
        """
        if not self.temp_dir:
            raise RuntimeError("Scraper must be used as async context manager")

        # Create a subdirectory for this specific URL
        url_hash = str(hash(url))[-8:]
        output_dir = self.temp_dir / f"single_{url_hash}"
        output_dir.mkdir(exist_ok=True)

        # Build HTTrack command for single page
        cmd = [
            self.httrack_path,
            url,
            "-O",
            str(output_dir),
            "-r1",  # Depth 1 (just this page)
            "-%P",  # No external pages
            "-p1",  # Download HTML files
            "-%e0",  # Don't download error pages
            "--quiet",  # Quiet mode
            "--disable-security-limits",
            f"--user-agent={self.config.user_agent}",
            "--timeout=" + str(int(self.config.timeout)),
        ]

        if not self.config.verify_ssl:
            cmd.append("--assume-insecure")

        # Run HTTrack
        logger.debug(f"Running HTTrack command: {' '.join(cmd)}")
        process = await asyncio.create_subprocess_exec(
            *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
        )

        stdout, stderr = await process.communicate()

        if process.returncode != 0:
            error_msg = stderr.decode("utf-8", errors="replace")
            raise RuntimeError(f"HTTrack failed: {error_msg}")

        # Find the downloaded file
        # HTTrack creates files in a domain subdirectory
        parsed_url = urlparse(url)

        # Try multiple possible locations
        possible_files = [
            # Domain/path structure
            output_dir / parsed_url.netloc / parsed_url.path.lstrip("/"),
            output_dir / parsed_url.netloc / (parsed_url.path.lstrip("/") + ".html"),
            output_dir / parsed_url.netloc / "index.html",
            # Sometimes HTTrack puts files directly in output dir
            output_dir / "index.html",
        ]

        # If path ends with /, add index.html
        if parsed_url.path.endswith("/") or not parsed_url.path:
            possible_files.insert(
                0,
                output_dir
                / parsed_url.netloc
                / parsed_url.path.lstrip("/")
                / "index.html",
            )

        expected_file = None
        for pf in possible_files:
            if pf.exists() and pf.is_file():
                expected_file = pf
                break

        if not expected_file:
            # Try to find any HTML file in the domain directory
            domain_dir = output_dir / parsed_url.netloc
            if domain_dir.exists():
                html_files = list(domain_dir.rglob("*.html"))
                # Exclude HTTrack's own index files
                html_files = [f for f in html_files if "hts-cache" not in str(f)]
                if html_files:
                    expected_file = html_files[0]

        if not expected_file:
            # Last resort: find any HTML file
            html_files = list(output_dir.rglob("*.html"))
            # Exclude HTTrack's own files and cache
            html_files = [
                f
                for f in html_files
                if "hts-cache" not in str(f) and f.name != "index.html"
            ]
            if html_files:
                expected_file = html_files[0]
            else:
                raise RuntimeError(f"HTTrack did not download any HTML files for {url}")

        # Read the content
        try:
            content = expected_file.read_text(encoding="utf-8")
        except UnicodeDecodeError:
            content = expected_file.read_text(encoding="latin-1")

        # Extract title from content
        title = None
        if "<title>" in content and "</title>" in content:
            start = content.find("<title>") + 7
            end = content.find("</title>")
            title = content[start:end].strip()

        return ScrapedPage(url=url, content=content, title=title, encoding="utf-8")

    async def scrape_site(self, start_url: str) -> AsyncGenerator[ScrapedPage, None]:
        """Scrape entire website using HTTrack.

        Args:
            start_url: URL to start crawling from

        Yields:
            ScrapedPage objects as they are scraped
        """
        if not self.temp_dir:
            raise RuntimeError("Scraper must be used as async context manager")

        output_dir = self.temp_dir / "site"
        output_dir.mkdir(exist_ok=True)

        # Build HTTrack command with conservative settings for Cloudflare
        # Calculate connection rate (max 0.5 connections per second)
        connection_rate = min(0.5, 1 / self.config.request_delay)

        # Limit concurrent connections (max 2 for Cloudflare sites)
        concurrent_connections = min(2, self.config.concurrent_requests)

        cmd = [
            self.httrack_path,
            start_url,
            "-O",
            str(output_dir),
            f"-r{self.config.max_depth}",  # Max depth
            "-%P",  # No external pages
            "--quiet",  # Quiet mode
            "--disable-security-limits",
            f"--user-agent={self.config.user_agent}",
            "--timeout=" + str(int(self.config.timeout)),
            f"--sockets={concurrent_connections}",  # Max 2 connections
            f"--connection-per-second={connection_rate:.2f}",  # Max 0.5/sec
            f"--max-files={self.config.max_pages}",
            "--max-rate=100000",  # Limit bandwidth to 100KB/s
            "--min-rate=1000",  # Minimum 1KB/s
        ]

        # Add domain restrictions
        if self.config.allowed_domains:
            for domain in self.config.allowed_domains:
                cmd.extend(["+*" + domain + "*"])
        else:
            # Restrict to same domain by default
            parsed = urlparse(start_url)
            cmd.extend(["+*" + parsed.netloc + "*"])

        # Add exclusions
        if self.config.exclude_patterns:
            for pattern in self.config.exclude_patterns:
                cmd.extend(["-*" + pattern + "*"])

        if not self.config.verify_ssl:
            cmd.append("--assume-insecure")

        if self.config.respect_robots_txt:
            cmd.append("--robots=3")  # Respect robots.txt

        # Run HTTrack
        logger.info(f"Starting HTTrack crawl from {start_url}")
        logger.debug(f"HTTrack command: {' '.join(cmd)}")

        process = await asyncio.create_subprocess_exec(
            *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
        )

        # Wait for HTTrack to complete
        stdout, stderr = await process.communicate()

        if process.returncode != 0:
            error_msg = stderr.decode("utf-8", errors="replace")
            logger.error(f"HTTrack failed: {error_msg}")
            # Continue to process any files that were downloaded

        # Find all downloaded HTML files
        html_files = list(output_dir.rglob("*.html"))
        logger.info(f"HTTrack downloaded {len(html_files)} HTML files")

        # Yield each file as a ScrapedPage
        for html_file in html_files:
            # Skip HTTrack's own files
            if html_file.name in ("index.html", "hts-log.txt", "hts-cache"):
                continue

            try:
                # Reconstruct URL from file path
                rel_path = html_file.relative_to(output_dir)
                parts = rel_path.parts

                # First part should be domain
                if len(parts) > 0:
                    domain = parts[0]
                    path_parts = parts[1:] if len(parts) > 1 else []

                    # Reconstruct URL
                    parsed_start = urlparse(start_url)
                    url = f"{parsed_start.scheme}://{domain}/" + "/".join(path_parts)

                    # Remove .html extension if it wasn't in original
                    if url.endswith("/index.html"):
                        url = url[:-11]  # Remove /index.html
                    elif url.endswith(".html") and ".html" not in start_url:
                        url = url[:-5]  # Remove .html

                    # Read content
                    try:
                        content = html_file.read_text(encoding="utf-8")
                    except UnicodeDecodeError:
                        content = html_file.read_text(encoding="latin-1")

                    # Extract title
                    title = None
                    if "<title>" in content and "</title>" in content:
                        start_idx = content.find("<title>") + 7
                        end_idx = content.find("</title>")
                        title = content[start_idx:end_idx].strip()

                    self.mark_visited(url)

                    yield ScrapedPage(
                        url=url, content=content, title=title, encoding="utf-8"
                    )

            except Exception as e:
                logger.error(f"Error processing {html_file}: {e}")
                continue

======= scrape_tool/scrapers/playwright.py | CHECKSUM_SHA256: 696893fd8100ce57b7578b81c902b537f4d2f0952f303209c15ca365f447a787 ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Playwright scraper backend for JavaScript-heavy websites."""

import asyncio
import logging
from typing import AsyncIterator, Set, Optional, Dict, Any, TYPE_CHECKING
from urllib.parse import urljoin, urlparse
import re

try:
    from playwright.async_api import async_playwright, Browser, BrowserContext, Page

    PLAYWRIGHT_AVAILABLE = True
except ImportError:
    PLAYWRIGHT_AVAILABLE = False
    if TYPE_CHECKING:
        from playwright.async_api import Page
    else:
        Page = Any

from .base import WebScraperBase, ScrapedPage, ScraperConfig

logger = logging.getLogger(__name__)


class PlaywrightScraper(WebScraperBase):
    """Browser-based scraper using Playwright for JavaScript rendering.

    Playwright provides:
    - Full JavaScript execution and rendering
    - Support for SPAs and dynamic content
    - Multiple browser engines (Chromium, Firefox, WebKit)
    - Screenshot and PDF generation capabilities
    - Network interception and modification
    - Mobile device emulation

    Best for:
    - JavaScript-heavy websites and SPAs
    - Sites requiring user interaction (clicking, scrolling)
    - Content behind authentication
    - Visual regression testing
    """

    def __init__(self, config: ScraperConfig):
        """Initialize the Playwright scraper.

        Args:
            config: Scraper configuration

        Raises:
            ImportError: If playwright is not installed
        """
        if not PLAYWRIGHT_AVAILABLE:
            raise ImportError(
                "playwright is required for this scraper. "
                "Install with: pip install playwright && playwright install"
            )

        super().__init__(config)
        self._playwright = None
        self._browser: Optional[Browser] = None
        self._context: Optional[BrowserContext] = None
        self._visited_urls: Set[str] = set()

        # Browser configuration from scraper config
        self._browser_config = config.__dict__.get("browser_config", {})
        self._browser_type = self._browser_config.get("browser", "chromium")
        self._headless = self._browser_config.get("headless", True)
        self._viewport = self._browser_config.get(
            "viewport", {"width": 1920, "height": 1080}
        )
        self._wait_until = self._browser_config.get("wait_until", "networkidle")
        self._wait_timeout = self._browser_config.get("wait_timeout", 30000)

    async def __aenter__(self):
        """Enter async context and launch browser."""
        self._playwright = await async_playwright().start()

        # Launch browser based on type
        if self._browser_type == "firefox":
            self._browser = await self._playwright.firefox.launch(
                headless=self._headless
            )
        elif self._browser_type == "webkit":
            self._browser = await self._playwright.webkit.launch(
                headless=self._headless
            )
        else:  # Default to chromium
            self._browser = await self._playwright.chromium.launch(
                headless=self._headless
            )

        # Create browser context with custom user agent
        self._context = await self._browser.new_context(
            user_agent=self.config.user_agent,
            viewport=self._viewport,
            ignore_https_errors=True,  # Handle self-signed certificates
            accept_downloads=False,
        )

        # Set default timeout
        self._context.set_default_timeout(self._wait_timeout)

        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Exit async context and cleanup."""
        if self._context:
            await self._context.close()
        if self._browser:
            await self._browser.close()
        if self._playwright:
            await self._playwright.stop()

    async def scrape_url(self, url: str) -> ScrapedPage:
        """Scrape a single URL using Playwright.

        Args:
            url: URL to scrape

        Returns:
            ScrapedPage object with scraped content

        Raises:
            Exception: If scraping fails
        """
        if not self._context:
            raise RuntimeError("Scraper not initialized. Use async context manager.")

        page = None
        try:
            # Create new page
            page = await self._context.new_page()

            # Navigate to URL
            response = await page.goto(url, wait_until=self._wait_until)

            if not response:
                raise Exception(f"Failed to navigate to {url}")

            # Wait for any additional dynamic content
            if self._browser_config.get("wait_for_selector"):
                await page.wait_for_selector(
                    self._browser_config["wait_for_selector"],
                    timeout=self._wait_timeout,
                )

            # Execute any custom JavaScript
            if self._browser_config.get("execute_script"):
                await page.evaluate(self._browser_config["execute_script"])

            # Get the final rendered HTML
            content = await page.content()

            # Extract title
            title = await page.title()

            # Extract metadata
            metadata = await self._extract_metadata(page)

            # Get response headers and status
            status_code = response.status
            headers = response.headers

            # Detect encoding
            encoding = "utf-8"  # Default for rendered content

            # Take screenshot if configured
            if self._browser_config.get("screenshot"):
                screenshot_path = self._browser_config.get(
                    "screenshot_path", "screenshot.png"
                )
                await page.screenshot(path=screenshot_path, full_page=True)
                metadata["screenshot"] = screenshot_path

            return ScrapedPage(
                url=page.url,  # Use final URL after redirects
                content=content,
                title=title,
                encoding=encoding,
                status_code=status_code,
                headers=headers,
                metadata=metadata,
            )

        except Exception as e:
            logger.error(f"Error scraping {url} with Playwright: {e}")
            raise
        finally:
            if page:
                await page.close()

    async def _extract_metadata(self, page: Page) -> Dict[str, Any]:
        """Extract metadata from the page."""
        metadata = {}

        # Extract meta tags
        meta_tags = await page.evaluate(
            """
            () => {
                const metadata = {};
                
                // Get description
                const desc = document.querySelector('meta[name="description"]');
                if (desc) metadata.description = desc.content;
                
                // Get keywords
                const keywords = document.querySelector('meta[name="keywords"]');
                if (keywords) metadata.keywords = keywords.content;
                
                // Get Open Graph tags
                document.querySelectorAll('meta[property^="og:"]').forEach(tag => {
                    metadata[tag.getAttribute('property')] = tag.content;
                });
                
                // Get Twitter Card tags
                document.querySelectorAll('meta[name^="twitter:"]').forEach(tag => {
                    metadata[tag.getAttribute('name')] = tag.content;
                });
                
                // Get canonical URL
                const canonical = document.querySelector('link[rel="canonical"]');
                if (canonical) metadata.canonical = canonical.href;
                
                // Get page load time
                if (window.performance && window.performance.timing) {
                    const timing = window.performance.timing;
                    metadata.load_time = timing.loadEventEnd - timing.navigationStart;
                }
                
                return metadata;
            }
        """
        )

        metadata.update(meta_tags)

        # Add browser info
        metadata["browser"] = self._browser_type
        metadata["viewport"] = self._viewport

        return metadata

    async def scrape_site(self, start_url: str) -> AsyncIterator[ScrapedPage]:
        """Scrape an entire website using Playwright.

        Args:
            start_url: Starting URL for crawling

        Yields:
            ScrapedPage objects for each scraped page
        """
        if not self._context:
            raise RuntimeError("Scraper not initialized. Use async context manager.")

        # Parse start URL to get base domain
        parsed_start = urlparse(start_url)
        base_domain = parsed_start.netloc

        # Initialize queue
        queue = asyncio.Queue()
        await queue.put((start_url, 0))  # (url, depth)

        # Track visited URLs
        self._visited_urls.clear()
        self._visited_urls.add(start_url)

        # Semaphore for concurrent pages
        semaphore = asyncio.Semaphore(self.config.concurrent_requests)

        # Active tasks
        tasks = set()
        pages_scraped = 0

        async def process_url(url: str, depth: int):
            """Process a single URL and extract links."""
            async with semaphore:
                page = None
                try:
                    # Respect request delay
                    if self.config.request_delay > 0:
                        await asyncio.sleep(self.config.request_delay)

                    # Create new page
                    page = await self._context.new_page()

                    # Navigate to URL
                    response = await page.goto(url, wait_until=self._wait_until)

                    if not response:
                        logger.warning(f"Failed to navigate to {url}")
                        return None

                    # Wait for dynamic content
                    if self._browser_config.get("wait_for_selector"):
                        await page.wait_for_selector(
                            self._browser_config["wait_for_selector"],
                            timeout=self._wait_timeout,
                        )

                    # Get content
                    content = await page.content()
                    title = await page.title()
                    metadata = await self._extract_metadata(page)

                    # Create scraped page
                    scraped_page = ScrapedPage(
                        url=page.url,
                        content=content,
                        title=title,
                        encoding="utf-8",
                        status_code=response.status,
                        headers=response.headers,
                        metadata=metadata,
                    )

                    # Extract links if not at max depth
                    if depth < self.config.max_depth:
                        # Get all links using JavaScript
                        links = await page.evaluate(
                            """
                            () => {
                                return Array.from(document.querySelectorAll('a[href]'))
                                    .map(a => a.href)
                                    .filter(href => href && (href.startsWith('http://') || href.startsWith('https://')));
                            }
                        """
                        )

                        for link in links:
                            # Parse URL
                            parsed_url = urlparse(link)

                            # Skip if different domain (unless allowed)
                            if self.config.allowed_domains:
                                if parsed_url.netloc not in self.config.allowed_domains:
                                    continue
                            elif parsed_url.netloc != base_domain:
                                continue

                            # Skip if matches exclude pattern
                            if self.config.exclude_patterns:
                                if any(
                                    re.match(pattern, link)
                                    for pattern in self.config.exclude_patterns
                                ):
                                    continue

                            # Skip if already visited
                            if link in self._visited_urls:
                                continue

                            # Add to queue
                            self._visited_urls.add(link)
                            await queue.put((link, depth + 1))

                    return scraped_page

                except Exception as e:
                    logger.error(f"Error processing {url}: {e}")
                    return None
                finally:
                    if page:
                        await page.close()

        # Process URLs from queue
        while not queue.empty() or tasks:
            # Start new tasks if under limit
            while not queue.empty() and len(tasks) < self.config.concurrent_requests:
                try:
                    url, depth = queue.get_nowait()

                    # Check max pages limit
                    if pages_scraped >= self.config.max_pages:
                        break

                    # Create task
                    task = asyncio.create_task(process_url(url, depth))
                    tasks.add(task)

                except asyncio.QueueEmpty:
                    break

            # Wait for at least one task to complete
            if tasks:
                done, tasks = await asyncio.wait(
                    tasks, return_when=asyncio.FIRST_COMPLETED
                )

                # Process completed tasks
                for task in done:
                    page = await task
                    if page:
                        pages_scraped += 1
                        yield page

                        # Check if we've hit the page limit
                        if pages_scraped >= self.config.max_pages:
                            # Cancel remaining tasks
                            for t in tasks:
                                t.cancel()
                            return

        logger.info(f"Playwright scraping complete. Scraped {pages_scraped} pages")

======= scrape_tool/scrapers/scrapy_scraper.py | CHECKSUM_SHA256: 332c697704db363b69e05f5b0b62d075b2bd7227ba340910c60bc47c0dd0e20a ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Scrapy backend for industrial-strength web scraping."""

import asyncio
import logging
import tempfile
from pathlib import Path
from typing import AsyncIterator, Optional, Dict, Any, List
from urllib.parse import urlparse
import json

try:
    import scrapy
    from scrapy.crawler import CrawlerProcess, CrawlerRunner
    from scrapy.utils.project import get_project_settings
    from twisted.internet import reactor, defer
    from scrapy.utils.log import configure_logging

    SCRAPY_AVAILABLE = True
except ImportError:
    SCRAPY_AVAILABLE = False

from .base import WebScraperBase, ScrapedPage, ScraperConfig

logger = logging.getLogger(__name__)


class ScrapySpider(scrapy.Spider if SCRAPY_AVAILABLE else object):
    """Custom Scrapy spider for HTML2MD."""

    name = "html2md_spider"

    def __init__(
        self, start_url: str, config: ScraperConfig, output_file: str, *args, **kwargs
    ):
        """Initialize spider with configuration."""
        # Initialize parent class first if Scrapy is available
        if SCRAPY_AVAILABLE and scrapy.Spider in self.__class__.__mro__:
            super().__init__(*args, **kwargs)

        self.start_urls = [start_url]
        self.config = config
        self.output_file = output_file
        self.pages_scraped = 0

        # Parse domain for allowed domains
        parsed = urlparse(start_url)
        if config.allowed_domains:
            self.allowed_domains = list(config.allowed_domains)
        else:
            self.allowed_domains = [parsed.netloc]

    def parse(self, response):
        """Parse a response and extract data."""
        # Check page limit
        if self.pages_scraped >= self.config.max_pages:
            return

        self.pages_scraped += 1

        # Extract page data
        # Convert headers to string dict (headers might contain bytes)
        headers = {}
        for key, value in response.headers.items():
            key_str = key.decode("utf-8") if isinstance(key, bytes) else str(key)
            value_str = (
                value[0].decode("utf-8")
                if isinstance(value[0], bytes)
                else str(value[0])
            )
            headers[key_str] = value_str

        page_data = {
            "url": response.url,
            "content": response.text,
            "title": response.css("title::text").get(""),
            "encoding": response.encoding,
            "status_code": response.status,
            "headers": headers,
            "metadata": self._extract_metadata(response),
        }

        # Save to output file
        with open(self.output_file, "a", encoding="utf-8") as f:
            f.write(json.dumps(page_data) + "\n")

        # Follow links if not at max depth
        depth = response.meta.get("depth", 0)
        if depth < self.config.max_depth and self.pages_scraped < self.config.max_pages:
            # Extract all links
            for href in response.css("a::attr(href)").getall():
                # Skip non-HTTP links
                if href.startswith(("mailto:", "tel:", "javascript:", "#")):
                    continue

                # Skip if matches exclude pattern
                if self.config.exclude_patterns:
                    if any(pattern in href for pattern in self.config.exclude_patterns):
                        continue

                yield response.follow(href, callback=self.parse)

    def _extract_metadata(self, response) -> Dict[str, Any]:
        """Extract metadata from the response."""
        metadata = {}

        # Meta description
        desc = response.css('meta[name="description"]::attr(content)').get()
        if desc:
            metadata["description"] = desc

        # Meta keywords
        keywords = response.css('meta[name="keywords"]::attr(content)').get()
        if keywords:
            metadata["keywords"] = keywords

        # Open Graph tags
        for og_tag in response.css('meta[property^="og:"]'):
            prop = og_tag.css("::attr(property)").get()
            content = og_tag.css("::attr(content)").get()
            if prop and content:
                metadata[prop] = content

        return metadata


class ScrapyScraper(WebScraperBase):
    """Industrial-strength scraper using Scrapy framework.

    Scrapy provides:
    - Built-in request throttling and retry logic
    - Concurrent request handling with Twisted
    - Middleware system for customization
    - robots.txt compliance
    - Auto-throttle based on server response times

    Best for:
    - Large-scale web scraping projects
    - Sites requiring complex crawling logic
    - Projects needing middleware (proxies, auth, etc.)
    """

    def __init__(self, config: ScraperConfig):
        """Initialize the Scrapy scraper.

        Args:
            config: Scraper configuration

        Raises:
            ImportError: If scrapy is not installed
        """
        if not SCRAPY_AVAILABLE:
            raise ImportError(
                "scrapy is required for this scraper. "
                "Install with: pip install scrapy"
            )

        super().__init__(config)
        self._temp_dir: Optional[Path] = None
        self._output_file: Optional[Path] = None

    async def __aenter__(self):
        """Enter async context."""
        # Create temporary directory for output
        self._temp_dir = Path(tempfile.mkdtemp(prefix="scrapy_html2md_"))
        self._output_file = self._temp_dir / "output.jsonl"
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Exit async context and cleanup."""
        # Cleanup temporary files
        if self._temp_dir and self._temp_dir.exists():
            import shutil

            shutil.rmtree(self._temp_dir)

    async def scrape_url(self, url: str) -> ScrapedPage:
        """Scrape a single URL using Scrapy.

        Args:
            url: URL to scrape

        Returns:
            ScrapedPage object with scraped content
        """
        # Use a simpler approach for single URLs - just use aiohttp
        # since Scrapy is more suited for site-wide crawling
        import aiohttp
        import aiofiles

        async with aiohttp.ClientSession() as session:
            headers = {"User-Agent": self.config.user_agent}
            timeout = aiohttp.ClientTimeout(total=self.config.timeout)

            async with session.get(
                url,
                headers=headers,
                timeout=timeout,
                allow_redirects=self.config.follow_redirects,
            ) as response:
                content = await response.text()

                # Parse with BeautifulSoup to extract title
                from bs4 import BeautifulSoup

                soup = BeautifulSoup(content, "html.parser")
                title = soup.title.string if soup.title else ""

                # Extract metadata
                metadata = {}
                desc_tag = soup.find("meta", attrs={"name": "description"})
                if desc_tag and desc_tag.get("content"):
                    metadata["description"] = desc_tag["content"]

                keywords_tag = soup.find("meta", attrs={"name": "keywords"})
                if keywords_tag and keywords_tag.get("content"):
                    metadata["keywords"] = keywords_tag["content"]

                # Extract OG tags
                for og_tag in soup.find_all(
                    "meta", attrs={"property": lambda x: x and x.startswith("og:")}
                ):
                    if og_tag.get("content"):
                        metadata[og_tag["property"]] = og_tag["content"]

                return ScrapedPage(
                    url=str(response.url),
                    content=content,
                    title=title,
                    encoding=response.charset or "utf-8",
                    status_code=response.status,
                    headers=dict(response.headers),
                    metadata=metadata,
                )

    async def scrape_site(self, start_url: str) -> AsyncIterator[ScrapedPage]:
        """Scrape an entire website using Scrapy.

        Args:
            start_url: Starting URL for crawling

        Yields:
            ScrapedPage objects for each scraped page
        """
        # Clear output file
        if self._output_file.exists():
            self._output_file.unlink()

        # Configure Scrapy settings
        settings = get_project_settings()
        settings.update(
            {
                "USER_AGENT": self.config.user_agent,
                "ROBOTSTXT_OBEY": self.config.respect_robots_txt,
                "CONCURRENT_REQUESTS": self.config.concurrent_requests,
                "DOWNLOAD_DELAY": self.config.request_delay,
                "RANDOMIZE_DOWNLOAD_DELAY": True,  # Randomize delays
                "DEPTH_LIMIT": self.config.max_depth,
                "LOG_ENABLED": logger.isEnabledFor(logging.DEBUG),
                "TELNETCONSOLE_ENABLED": False,
                "AUTOTHROTTLE_ENABLED": True,  # Enable auto-throttle
                "AUTOTHROTTLE_START_DELAY": self.config.request_delay,
                "AUTOTHROTTLE_MAX_DELAY": self.config.request_delay * 10,
                "AUTOTHROTTLE_TARGET_CONCURRENCY": self.config.concurrent_requests,
                "HTTPCACHE_ENABLED": True,  # Enable cache
                "HTTPCACHE_DIR": str(self._temp_dir / "cache"),
                "REDIRECT_ENABLED": self.config.follow_redirects,
                "DOWNLOAD_TIMEOUT": self.config.timeout,
            }
        )

        # Use multiprocessing to run Scrapy in a separate process
        # to avoid reactor threading issues
        import multiprocessing
        import time

        def run_spider_process():
            """Run spider in separate process."""
            from scrapy.crawler import CrawlerProcess
            from scrapy.utils.project import get_project_settings

            # Re-create settings in the new process
            settings = get_project_settings()
            settings.update(
                {
                    "USER_AGENT": self.config.user_agent,
                    "ROBOTSTXT_OBEY": self.config.respect_robots_txt,
                    "CONCURRENT_REQUESTS": self.config.concurrent_requests,
                    "DOWNLOAD_DELAY": self.config.request_delay,
                    "RANDOMIZE_DOWNLOAD_DELAY": True,
                    "DEPTH_LIMIT": self.config.max_depth,
                    "LOG_ENABLED": logger.isEnabledFor(logging.DEBUG),
                    "TELNETCONSOLE_ENABLED": False,
                    "AUTOTHROTTLE_ENABLED": True,
                    "AUTOTHROTTLE_START_DELAY": self.config.request_delay,
                    "AUTOTHROTTLE_MAX_DELAY": self.config.request_delay * 10,
                    "AUTOTHROTTLE_TARGET_CONCURRENCY": self.config.concurrent_requests,
                    "HTTPCACHE_ENABLED": True,
                    "HTTPCACHE_DIR": str(self._temp_dir / "cache"),
                    "REDIRECT_ENABLED": self.config.follow_redirects,
                    "DOWNLOAD_TIMEOUT": self.config.timeout,
                }
            )

            process = CrawlerProcess(settings)
            process.crawl(
                ScrapySpider,
                start_url=start_url,
                config=self.config,
                output_file=str(self._output_file),
            )
            process.start()

        # Start spider in separate process
        process = multiprocessing.Process(target=run_spider_process)
        process.start()

        # Monitor output file and yield results as they come in
        last_position = 0
        pages_yielded = 0

        while True:
            # Check if spider process is still running
            if not process.is_alive():
                # Read any remaining data
                if self._output_file.exists():
                    with open(self._output_file, "r", encoding="utf-8") as f:
                        f.seek(last_position)
                        for line in f:
                            if line.strip():
                                data = json.loads(line.strip())
                                yield ScrapedPage(**data)
                                pages_yielded += 1
                break

            # Read new data from output file
            if self._output_file.exists():
                with open(self._output_file, "r", encoding="utf-8") as f:
                    f.seek(last_position)
                    for line in f:
                        if line.strip():
                            data = json.loads(line.strip())
                            yield ScrapedPage(**data)
                            pages_yielded += 1

                            # Check page limit
                            if pages_yielded >= self.config.max_pages:
                                # Terminate the process
                                process.terminate()
                                process.join(timeout=5)
                                if process.is_alive():
                                    process.kill()
                                return

                    last_position = f.tell()

            # Small delay to avoid busy waiting
            await asyncio.sleep(0.1)

        logger.info(f"Scrapy scraping complete. Scraped {pages_yielded} pages")

======= scrape_tool/scrapers/selectolax.py | CHECKSUM_SHA256: e82a9017ce04f44b71845e5b22d83b4bb2488e72589a2b2b1f43db621b5eb8c8 ======
#!/usr/bin/env python3
# Copyright 2025 Franz und Franz GmbH
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""httpx + selectolax scraper backend for blazing fast HTML parsing."""

import asyncio
import logging
from typing import AsyncIterator, Set, Optional, Dict, Any
from urllib.parse import urljoin, urlparse
import re

try:
    import httpx
    from selectolax.parser import HTMLParser

    HTTPX_AVAILABLE = True
except ImportError:
    HTTPX_AVAILABLE = False

from .base import WebScraperBase, ScrapedPage, ScraperConfig

logger = logging.getLogger(__name__)


class SelectolaxScraper(WebScraperBase):
    """High-performance scraper using httpx for async HTTP and selectolax for parsing.

    This scraper is optimized for speed and low memory usage. It uses:
    - httpx: Modern async HTTP client with connection pooling
    - selectolax: Blazing fast HTML parser built on C libraries

    Best for:
    - Large-scale scraping where performance is critical
    - Simple HTML parsing without JavaScript
    - Minimal resource usage requirements
    """

    def __init__(self, config: ScraperConfig):
        """Initialize the selectolax scraper.

        Args:
            config: Scraper configuration

        Raises:
            ImportError: If httpx or selectolax are not installed
        """
        if not HTTPX_AVAILABLE:
            raise ImportError(
                "httpx and selectolax are required for this scraper. "
                "Install with: pip install httpx selectolax"
            )

        super().__init__(config)
        self._client: Optional[httpx.AsyncClient] = None
        self._visited_urls: Set[str] = set()

    async def __aenter__(self):
        """Enter async context and create HTTP client."""
        # Configure client with connection pooling for performance
        limits = httpx.Limits(
            max_keepalive_connections=20,
            max_connections=self.config.concurrent_requests * 2,
            keepalive_expiry=30.0,
        )

        self._client = httpx.AsyncClient(
            timeout=httpx.Timeout(self.config.timeout),
            limits=limits,
            follow_redirects=self.config.follow_redirects,
            headers={"User-Agent": self.config.user_agent},
        )

        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Exit async context and cleanup."""
        if self._client:
            await self._client.aclose()

    async def scrape_url(self, url: str) -> ScrapedPage:
        """Scrape a single URL.

        Args:
            url: URL to scrape

        Returns:
            ScrapedPage object with scraped content

        Raises:
            Exception: If scraping fails
        """
        if not self._client:
            raise RuntimeError("Scraper not initialized. Use async context manager.")

        try:
            # Make HTTP request
            response = await self._client.get(url)
            response.raise_for_status()

            # Parse HTML with selectolax
            html_parser = HTMLParser(response.text)

            # Extract title
            title = ""
            title_tag = html_parser.css_first("title")
            if title_tag:
                title = title_tag.text(strip=True)

            # Extract metadata
            metadata = {}

            # Get meta description
            meta_desc = html_parser.css_first('meta[name="description"]')
            if meta_desc:
                metadata["description"] = meta_desc.attributes.get("content", "")

            # Get meta keywords
            meta_keywords = html_parser.css_first('meta[name="keywords"]')
            if meta_keywords:
                metadata["keywords"] = meta_keywords.attributes.get("content", "")

            # Get Open Graph data
            for og_tag in html_parser.css('meta[property^="og:"]'):
                prop = og_tag.attributes.get("property", "")
                content = og_tag.attributes.get("content", "")
                if prop and content:
                    metadata[prop] = content

            # Detect encoding from meta tag or response
            encoding = response.encoding or "utf-8"
            meta_charset = html_parser.css_first("meta[charset]")
            if meta_charset:
                encoding = meta_charset.attributes.get("charset", encoding)
            else:
                # Check for http-equiv Content-Type
                meta_content_type = html_parser.css_first(
                    'meta[http-equiv="Content-Type"]'
                )
                if meta_content_type:
                    content = meta_content_type.attributes.get("content", "")
                    match = re.search(r"charset=([^;]+)", content)
                    if match:
                        encoding = match.group(1).strip()

            return ScrapedPage(
                url=str(response.url),  # Use final URL after redirects
                content=response.text,
                title=title,
                encoding=encoding,
                status_code=response.status_code,
                headers=dict(response.headers),
                metadata=metadata,
            )

        except httpx.HTTPError as e:
            logger.error(f"HTTP error scraping {url}: {e}")
            raise
        except Exception as e:
            logger.error(f"Error scraping {url}: {e}")
            raise

    async def scrape_site(self, start_url: str) -> AsyncIterator[ScrapedPage]:
        """Scrape an entire website starting from the given URL.

        Args:
            start_url: Starting URL for crawling

        Yields:
            ScrapedPage objects for each scraped page
        """
        if not self._client:
            raise RuntimeError("Scraper not initialized. Use async context manager.")

        # Parse start URL to get base domain
        parsed_start = urlparse(start_url)
        base_domain = parsed_start.netloc

        # Initialize queue with start URL
        queue = asyncio.Queue()
        await queue.put((start_url, 0))  # (url, depth)

        # Track visited URLs
        self._visited_urls.clear()
        self._visited_urls.add(start_url)

        # Semaphore for concurrent requests
        semaphore = asyncio.Semaphore(self.config.concurrent_requests)

        # Active tasks
        tasks = set()
        pages_scraped = 0

        async def process_url(url: str, depth: int):
            """Process a single URL."""
            async with semaphore:
                try:
                    # Respect request delay
                    if self.config.request_delay > 0:
                        await asyncio.sleep(self.config.request_delay)

                    # Scrape the page
                    page = await self.scrape_url(url)

                    # Extract links if not at max depth
                    if depth < self.config.max_depth:
                        html_parser = HTMLParser(page.content)

                        for link in html_parser.css("a[href]"):
                            href = link.attributes.get("href", "")
                            if not href:
                                continue

                            # Resolve relative URLs
                            absolute_url = urljoin(url, href)

                            # Parse URL
                            parsed_url = urlparse(absolute_url)

                            # Skip if different domain (unless allowed)
                            if self.config.allowed_domains:
                                if parsed_url.netloc not in self.config.allowed_domains:
                                    continue
                            elif parsed_url.netloc != base_domain:
                                continue

                            # Skip if matches exclude pattern
                            if self.config.exclude_patterns:
                                if any(
                                    re.match(pattern, absolute_url)
                                    for pattern in self.config.exclude_patterns
                                ):
                                    continue

                            # Skip if already visited
                            if absolute_url in self._visited_urls:
                                continue

                            # Skip non-HTTP(S) URLs
                            if parsed_url.scheme not in ("http", "https"):
                                continue

                            # Add to queue
                            self._visited_urls.add(absolute_url)
                            await queue.put((absolute_url, depth + 1))

                    return page

                except Exception as e:
                    logger.error(f"Error processing {url}: {e}")
                    return None

        # Process URLs from queue
        while not queue.empty() or tasks:
            # Start new tasks if under limit
            while not queue.empty() and len(tasks) < self.config.concurrent_requests:
                try:
                    url, depth = queue.get_nowait()

                    # Check max pages limit
                    if pages_scraped >= self.config.max_pages:
                        break

                    # Create task
                    task = asyncio.create_task(process_url(url, depth))
                    tasks.add(task)

                except asyncio.QueueEmpty:
                    break

            # Wait for at least one task to complete
            if tasks:
                done, tasks = await asyncio.wait(
                    tasks, return_when=asyncio.FIRST_COMPLETED
                )

                # Process completed tasks
                for task in done:
                    page = await task
                    if page:
                        pages_scraped += 1
                        yield page

                        # Check if we've hit the page limit
                        if pages_scraped >= self.config.max_pages:
                            # Cancel remaining tasks
                            for t in tasks:
                                t.cancel()
                            return

        logger.info(f"Scraping complete. Scraped {pages_scraped} pages")
